// # $URL$
// # $Revision$


#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <setjmp.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <limits.h>
#include <float.h>
#include <Windows.h>

//#include <ext\types.h>
#include "Utilities\Console.h"

#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "gen.h"
#include "main.h"
#include "C_Yacced.tab.h"

#include "ExprOptimize.h"


// Deliberate NON-optimizations
//  1. var | var => var         // repeated use of a variable name will cause repeated reads. 
//                              // Thus is the program reads something and checks it it will 
//                              // check the source value not a copy of the previously read value.
//                              // exception: a & 0 ==>0 where the result is predetermined all 
//                              // reads may be bypassed.


static TPExprNode OptimizeBinary(TPExprNode pN);    // forward
static TPExprNode Optimize(TPExprNode pN);          // forward decl

// ##########################################################################################################

// ##########################################################################
// #  Function: OptimizeUnaryMinus
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeUnaryMinus(TPExprNode pN) {
        ASSERT(pN->Usage == uUnary);
        ASSERT(pN->Use.Unary.Op == Minus);

        TPExprNode pSubNode = pN->Use.Unary.pOperand;

        if (pSubNode->Usage == uConst) {
            switch (CalcSizeOf(pSubNode->pType)) {
            case 1: pSubNode->Use.Const.lInteger = (long)(-(char)pSubNode->Use.Const.lInteger); break;
            case 2: pSubNode->Use.Const.lInteger = (long)(-(short)pSubNode->Use.Const.lInteger); break;
            case 4: pSubNode->Use.Const.lInteger = (long)(-(long)pSubNode->Use.Const.lInteger); break;
            default:
                Error(FATAL, "OptimizeUnaryMinus(): Whisky Tango Foxtrot");
            }
            pSubNode->pType = pN->pType;
            return pSubNode;
        }

        return pN;
}

// ##########################################################################
// #  Function: OptimizeUnaryPlus
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeUnaryPlus(TPExprNode pN) {
        ASSERT(pN->Usage == uUnary);
        ASSERT(pN->Use.Unary.Op == Plus);

        TPExprNode pSubNode = pN->Use.Unary.pOperand;

        if (pSubNode->Usage == uConst) {
            switch (CalcSizeOf(pSubNode->pType)) {
            case 1: pSubNode->Use.Const.lInteger = (long)((char)pSubNode->Use.Const.lInteger); break;
            case 2: pSubNode->Use.Const.lInteger = (long)((short)pSubNode->Use.Const.lInteger); break;
            case 4: pSubNode->Use.Const.lInteger = (long)((long)pSubNode->Use.Const.lInteger); break;
            default:
                Error(FATAL, "OptimizeUnaryPlus(): Whisky Tango Foxtrot");
            }
            pSubNode->pType = pN->pType;
            return pSubNode;
        }

        return pN;
}

// ##########################################################################
// #  Function: OptimizeUnaryPlus
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeUnaryNeg(TPExprNode pN) {
        ASSERT(pN->Usage == uUnary);
        ASSERT(pN->Use.Unary.Op == Neg);

        TPExprNode pSubNode = pN->Use.Unary.pOperand;

        if (pSubNode->Usage == uConst) {
            switch (CalcSizeOf(pSubNode->pType)) {
            case 1: pSubNode->Use.Const.lInteger = (long)(~(char)pSubNode->Use.Const.lInteger); break;
            case 2: pSubNode->Use.Const.lInteger = (long)(~(short)pSubNode->Use.Const.lInteger); break;
            case 4: pSubNode->Use.Const.lInteger = (long)(~(long)pSubNode->Use.Const.lInteger); break;
            default:
                Error(FATAL, "OptimizeUnaryNeg(): Whisky Tango Foxtrot");
            }
            pSubNode->pType = pN->pType;
            return pSubNode;
        }

        return pN;
}

// ##########################################################################
// #  Function: OptimizeUnaryPostInc
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeUnaryPostInc(TPExprNode pN) {
        ASSERT(pN->Usage == uUnary);
        ASSERT(pN->Use.Unary.Op == PostInc);

        // Nothing to do here.
        return pN;
}

// ##########################################################################
// #  Function: OptimizeUnaryPreInc
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeUnaryPreInc(TPExprNode pN) {
        ASSERT(pN->Usage == uUnary);
        ASSERT(pN->Use.Unary.Op == PreInc);

        // Nothing to do here.
        return pN;
}

// ##########################################################################
// #  Function: OptimizeUnaryPostDec
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeUnaryPostDec(TPExprNode pN) {
        ASSERT(pN->Usage == uUnary);
        ASSERT(pN->Use.Unary.Op == PostDec);
        
        // Nothing to do here.
        return pN;
}

// ##########################################################################
// #  Function: OptimizeUnaryPreDec
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeUnaryPreDec(TPExprNode pN) {
        ASSERT(pN->Usage == uUnary);
        ASSERT(pN->Use.Unary.Op == PreDec);
        
        // Nothing to do here.
        return pN;
}

// ##########################################################################
// #  Function: OptimizeUnarySizeOf
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeUnarySizeOf(TPExprNode pN) {
        ASSERT(pN->Usage == uUnary);
        ASSERT(pN->Use.Unary.Op == SizeOf);

        Error(FATAL, "OptimizeUnarySizeOf(): this should not exist!");
        return pN;
}

// ##########################################################################
// #  Function: OptimizeUnaryAddr
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeUnaryAddr(TPExprNode pN) {
        ASSERT(pN->Usage == uUnary);
        ASSERT(pN->Use.Unary.Op == Addr);
 
        // Nothing to do here.
        return pN;
}

// ##########################################################################
// #  Function: OptimizeUnaryPtr
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeUnaryPtr(TPExprNode pN) {
        ASSERT(pN->Usage == uUnary);
        ASSERT(pN->Use.Unary.Op == Ptr);
        
        TPExprNode pSubNode = pN->Use.Unary.pOperand;

        if (pSubNode->Usage == uUnary && pSubNode->Use.Unary.Op == Addr) {
            pSubNode->Use.Unary.pOperand->pType = pN->pType;
            return pSubNode->Use.Unary.pOperand;
        }

        return pN;
}

// ##########################################################################
// #  Function: OptimizeUnaryNot
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeUnaryNot(TPExprNode pN) {
        ASSERT(pN->Usage == uUnary);
        ASSERT(pN->Use.Unary.Op == Not);
        
        TPExprNode pSubNode = pN->Use.Unary.pOperand;

        if (pSubNode->Usage == uConst) {                        
            if (pSubNode->Use.Const.lInteger != 0) {
                pSubNode->Use.Const.lInteger = FALSE;
            }
            else {
                pSubNode->Use.Const.lInteger = TRUE;
            }
            pSubNode->pType = pN->pType;
            return pSubNode;
        }

        return pN;
}


// ##########################################################################################################

// ##########################################################################
// #  Function: OptimizeBinaryAdd
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeBinaryAdd(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == Add);
        
        TPExprNode pLeft  = pN->Use.Binary.pLeft;
        TPExprNode pRight = pN->Use.Binary.pRight;

        // Addition is commutative and constants on the right gives better assembler output.
        if (pLeft->Usage == uConst) {                                                               // left const
            pN->Use.Binary.pLeft = pRight;                                                          //
            pRight = pN->Use.Binary.pRight = pLeft;                                                 //
            pLeft = pN->Use.Binary.pLeft;                                                           //
            pRight = pN->Use.Binary.pRight;                                                         //
        }                                                                                           //

        if (pLeft->Usage == uConst) {                                                               // Left const
            pN->Usage = uConst;                                                                     //      Left Const & Right Const
            pN->Use.Const.lInteger = pLeft->Use.Const.lInteger + pRight->Use.Const.lInteger;        //      (c + c) ==> c
            return pN;                                                                              //      
        }                                                                                           //

        if (pRight->Usage == uConst) {                                                              // Right const
            if (pRight->Use.Const.lInteger == 0) {                                                  //      Right is const zero
                pLeft->pType = pN->pType;                                                           //      (v + 0) ==> v
                return pLeft;                                                                       //
            }                                                                                       //
            if ((pLeft->Usage == uBinary) &&                                                        //
                (pLeft->Use.Binary.Op == Add)) {                                                    //      left is addition
                TPExprNode pSubLeft = pLeft->Use.Binary.pLeft;                                      //
                TPExprNode pSubRight = pLeft->Use.Binary.pRight;                                    //
                if (pSubRight->Usage == uConst) {                                                   //
                    //no need to check left = const                                                 //
                    pRight->Use.Const.lInteger += pSubRight->Use.Const.lInteger;                    //     (v +  c) + c ==> v + c
                    pN->Use.Binary.pLeft = pSubLeft;                                                //
                    return OptimizeBinary(pN);                                                      //
                }                                                                                   //
            }                                                                                       //
            return pN;                                                                              //
        }                                                                                           //

        if ((pRight->Usage == uBinary) &&                                                           // Right is binary addition with a constant
            (pRight->Use.Binary.Op == Add) &&                                                       //
            (pRight->Use.Binary.pRight->Usage == uConst) &&                                         //
            (pLeft->Usage == uBinary) &&                                                            // so is left.
            (pLeft->Use.Binary.Op == Add) &&                                                        //
            (pRight->Use.Binary.pRight->Usage == uConst)) {                                         // (v+c)+(v+c) ==> (v+v)+c

            pRight->Use.Binary.pRight->Use.Const.lInteger += pLeft->Use.Binary.pRight->Use.Const.lInteger;
            pLeft->Use.Binary.pRight = pRight->Use.Binary.pLeft;
            pN->Use.Binary.pRight = pRight->Use.Binary.pRight;
            return OptimizeBinary(pN);
        }
        
        return pN;
}

// ##########################################################################
// #  Function: OptimizeBinarySub
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeBinarySub(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == Sub);

        TPExprNode pLeft = pN->Use.Binary.pLeft;
        TPExprNode pRight = pN->Use.Binary.pRight;

        if (pLeft->Usage == uConst) {                                                               // left const
            if (pRight->Usage == uConst) {                                                          //      
                pN->Usage = uConst;                                                                 // Left Const & Right Const
                pN->Use.Const.lInteger = pLeft->Use.Const.lInteger - pRight->Use.Const.lInteger;    //      do the maths and return new const.
                return pN;                                                                          //
            }
            if (pRight->Usage == uBinary) {
                TPExprNode pSubLeft = pRight->Use.Binary.pLeft;
                TPExprNode pSubRight = pRight->Use.Binary.pRight;
                if (pRight->Use.Binary.Op == Sub) {
                    if (pSubLeft->Usage == uConst) {                                                //     c - ( c - v) ==> c - v
                        pLeft->Use.Const.lInteger -= pSubLeft->Use.Const.lInteger;
                        pN->Use.Binary.pRight = pSubRight;
                        return pN;
                    }
                    if (pSubRight->Usage == uConst) {                                               //     c - ( v - c) ==> c - v
                        pLeft->Use.Const.lInteger -= pSubRight->Use.Const.lInteger;
                        pN->Use.Binary.pRight = pSubLeft;
                        return pN;
                    }
                }
            }
            return pN;
        }
        if (pRight->Usage == uConst) {                                                              // Right const
            if (pRight->Use.Const.lInteger == 0) {                                                  //      Right is const zero
                pLeft->pType = pN->pType;
                return pLeft;                                                                       //      (v - 0) ==> v
            }                                                                                       //
            if (pLeft->Usage == uBinary) {
                TPExprNode pSubLeft = pLeft->Use.Binary.pLeft;
                TPExprNode pSubRight = pLeft->Use.Binary.pRight;
                if (pLeft->Use.Binary.Op == Sub) {
                    if (pSubLeft->Usage == uConst) {                                                //     (c - v) - c ==> c - v
                        pSubLeft->Use.Const.lInteger -= pRight->Use.Const.lInteger;
                        pLeft->pType = pN->pType; 
                        return pLeft;
                    }
                    if (pSubRight->Usage == uConst) {                                               //     (v -  c) - c ==> v - c
                        pSubRight->Use.Const.lInteger += pRight->Use.Const.lInteger;
                        pLeft->pType = pN->pType; 
                        return pLeft;
                    }
                }
            }
            return pN;
        }
        
        return pN;
}

// ##########################################################################
// #  Function: OptimizeBinaryMul
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeBinaryMul(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == Mul);

        TPExprNode pLeft = pN->Use.Binary.pLeft;
        TPExprNode pRight = pN->Use.Binary.pRight;

        // Multiplication is commutative and constants on the right gives better assembler output.
        if (pLeft->Usage == uConst) {                                                               // left const
            pN->Use.Binary.pLeft = pRight;                                                          //
            pRight = pN->Use.Binary.pRight = pLeft;                                                 //
            pLeft = pN->Use.Binary.pLeft;                                                           //
            pRight = pN->Use.Binary.pRight;                                                         //
        }                                                                                           //

        if (pLeft->Usage == uConst) {                                                               // Left const
            pN->Usage = uConst;                                                                     //      Left Const & Right Const
            pN->Use.Const.lInteger = pLeft->Use.Const.lInteger * pRight->Use.Const.lInteger;        //      (c + c) ==> c
            return pN;                                                                              //      
        }                                                                                           //

        if (pRight->Usage == uConst) {                                                              // Right const
            if (pRight->Use.Const.lInteger == 0) {                                                  //      Right is const zero
                pRight->pType = pN->pType;                                                          //
                return pRight;                                                                      //      (v * 0) ==> 0
            }                                                                                       
            if (pRight->Use.Const.lInteger == 1) {                                                  //      Right is const one
                pLeft->pType = pN->pType;                                                           //
                return pLeft;                                                                       //      (v * 1) ==> v
            }                                                                                       
            if (pRight->Use.Const.lInteger == 2) {                                                  //      Right is const two
                pN->Use.Binary.pRight = pN->Use.Binary.pLeft;                                       //      (v * 2) ==> v + v
                pN->Use.Binary.Op = Add;                                                            //
                return pN;                                                                          //
            }                                                                                       
            if ((pLeft->Usage == uBinary) &&                                                        //
                (pLeft->Use.Binary.Op == Mul)) {                                                    //      left is multiplication
                TPExprNode pSubLeft = pLeft->Use.Binary.pLeft;                                      //
                TPExprNode pSubRight = pLeft->Use.Binary.pRight;                                    //
                if (pSubRight->Usage == uConst) {                                                   //
                                                                                                    //no need to check left = const                                                 //
                    pRight->Use.Const.lInteger *= pSubRight->Use.Const.lInteger;                    //     (v +  c) + c ==> v + c
                    pN->Use.Binary.pLeft = pSubLeft;                                                //
                    return OptimizeBinary(pN);                                                      //
                }                                                                                   //
            }                                                                                       //
            return pN;                                                                              //
        }                                                                                           //

        if ((pRight->Usage == uBinary) &&                                                           // Right is binary multiplication with a constant
            (pRight->Use.Binary.Op == Mul) &&                                                       //
            (pRight->Use.Binary.pRight->Usage == uConst) &&                                         //
            (pLeft->Usage == uBinary) &&                                                            // so is left.
            (pLeft->Use.Binary.Op == Mul) &&                                                        //
            (pRight->Use.Binary.pRight->Usage == uConst)) {                                         // (v+c)+(v+c) ==> (v+v)+c

            pRight->Use.Binary.pRight->Use.Const.lInteger *= pLeft->Use.Binary.pRight->Use.Const.lInteger;
            pLeft->Use.Binary.pRight = pRight->Use.Binary.pLeft;
            pN->Use.Binary.pRight = pRight->Use.Binary.pRight;
            return OptimizeBinary(pN);
        }

        return pN;
}

// ##########################################################################
// #  Function: OptimizeBinaryDiv
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeBinaryDiv(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == Div);

        TPExprNode pLeft = pN->Use.Binary.pLeft;
        TPExprNode pRight = pN->Use.Binary.pRight;

        if (pRight->Usage == uConst) {
            if (pRight->Use.Const.lInteger == 0) {                                                                  // division by zero
                Error(WARNINGX, "OptimizeBinaryDiv() detected division by zero (Substituted -1 for the result");    //
                pLeft->Use.Const.lInteger = -1;                                                                     //
                pLeft->pType = pN->pType;                                                                           //
                return pLeft;                                                                                       //
            }
            if (pRight->Use.Const.lInteger == 1) {                                                                  // division by one
                pLeft->pType = pN->pType;                                                                           //
                return pLeft;                                                                                       //
            }
            if (pLeft->Usage == uConst) {                                                                           // left & right const
                pLeft->Use.Const.lInteger /= pRight->Use.Const.lInteger;                                            //      (c / c) ==> c
                pLeft->pType = pN->pType;                                                                           //
                return pLeft;                                                                                       //      
            }
        }
        // Do not optimize beyond this binary pair.
        // integral division yields different results when the order changes.
        // a / 3 / 2 == (a/3)/2 != a/(3/2).
        return pN;
}

// ##########################################################################
// #  Function: OptimizeBinaryMod
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeBinaryMod(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == Mod);
        TPExprNode pLeft = pN->Use.Binary.pLeft;
        TPExprNode pRight = pN->Use.Binary.pRight;

        if (pRight->Usage == uConst) {
            if (pRight->Use.Const.lInteger == 0) {                                                                  // division by zero
                Error(WARNINGX, "OptimizeBinaryMod() detected division by zero (Substituted 0 for the result");     //
                pLeft->Use.Const.lInteger = 0;                                                                      //
                pLeft->pType = pN->pType;                                                                           //
                return pLeft;                                                                                       //
            }
            if (pRight->Use.Const.lInteger == 1) {                                                                  // x / 1 ==>  x rem 0
                pLeft->Use.Const.lInteger = 0;                                                                      //
                pLeft->pType = pN->pType;                                                                           //
                return pLeft;                                                                                       //
            }
            if (pLeft->Usage == uConst) {                                                                           // left & right const
                pLeft->Use.Const.lInteger %= pRight->Use.Const.lInteger;                                            //      (c % c) ==> c
                pLeft->pType = pN->pType;                                                                           //
                return pLeft;                                                                                       //      
            }
        }
        // Do not optimize beyond this binary pair.
        // integral division yields different results when the order changes.
        // a / 3 / 2 == (a/3)/2 != a/(3/2).
        return pN;
}

// ##########################################################################
// #  Function: OptimizeBinaryBAnd
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeBinaryBAnd(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == BAnd);
        
        TPExprNode pLeft = pN->Use.Binary.pLeft;
        TPExprNode pRight = pN->Use.Binary.pRight;

        // Anding is commutative and constants on the right gives better assembler output.
        if (pLeft->Usage == uConst) {                                                               // left const
            pN->Use.Binary.pLeft = pRight;                                                          //
            pRight = pN->Use.Binary.pRight = pLeft;                                                 //
            pLeft = pN->Use.Binary.pLeft;                                                           //
            pRight = pN->Use.Binary.pRight;                                                         //
        }                                                                                           //

        if (pLeft->Usage == uConst) {                                                               // Left const
            pLeft->Use.Const.lInteger &= pRight->Use.Const.lInteger;                                //      (c + c) ==> c
            pLeft->pType = pN->pType;                                                               //
            return pLeft;                                                                           //      
        }                                                                                           //

        if (pRight->Usage == uConst) {                                                              // Right const
            if (pRight->Use.Const.lInteger == 0) {                                                  //      Right is const zero
                pRight->pType = pN->pType;                                                          //
                return pRight;                                                                      //      (v & 0) ==> 0
            }                                                                                       //
            switch (CalcSizeOf(pLeft->pType)) {                                                     //      (v & ~0) ==> v
            case 1: if ((pRight->Use.Const.lInteger & 0xFF) == 0xFF) {                              //
                        pLeft->pType = pN->pType;                                                   //
                        return pLeft;                                                               //
                    }                                                                               //
                    break;                                                                          //
            case 2: if ((pRight->Use.Const.lInteger & 0xFFFF) == 0xFFFF) {                          //
                        pLeft->pType = pN->pType;                                                   //
                        return pLeft;                                                               //
                    }                                                                               //
                    break;                                                                          //
            case 4: if ((pRight->Use.Const.lInteger & 0xFFFFFFFF) == 0xFFFFFFFF) {                  //
                        pLeft->pType = pN->pType;                                                   //
                        return pLeft;                                                               //
                    }                                                                               //
                    break;                                                                          //
            }                                                                                       //
            if ((pLeft->Usage == uBinary) &&                                                        //
                (pLeft->Use.Binary.Op == BAnd)) {                                                   //      left is and
                TPExprNode pSubLeft = pLeft->Use.Binary.pLeft;                                      //
                TPExprNode pSubRight = pLeft->Use.Binary.pRight;                                    //
                if (pSubRight->Usage == uConst) {                                                   //
                                                                                                    //no need to check left = const                                                 //
                    pRight->Use.Const.lInteger &= pSubRight->Use.Const.lInteger;                    //     (v &  c) & c ==> v & c
                    pN->Use.Binary.pLeft = pSubLeft;                                                //
                    return OptimizeBinary(pN);                                                                      //
                }                                                                                   //
            }                                                                                       //
            return pN;                                                                              //
        }                                                                                           //

        if ((pRight->Usage == uBinary) &&                                                           // Right is binary addition with a constant
            (pRight->Use.Binary.Op == BAnd) &&                                                      //
            (pRight->Use.Binary.pRight->Usage == uConst) &&                                         //
            (pLeft->Usage == uBinary) &&                                                            // so is left.
            (pLeft->Use.Binary.Op == BAnd) &&                                                       //
            (pRight->Use.Binary.pRight->Usage == uConst)) {                                         // (v&c)&(v&c) ==> (v&v)&c

            pRight->Use.Binary.pRight->Use.Const.lInteger &= pLeft->Use.Binary.pRight->Use.Const.lInteger;
            pLeft->Use.Binary.pRight = pRight->Use.Binary.pLeft;
            pN->Use.Binary.pRight = pRight->Use.Binary.pRight;
            return OptimizeBinary(pN);
        }

        return pN;
}

// ##########################################################################
// #  Function: OptimizeBinaryBOr
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeBinaryBOr(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == BOr);
        
        TPExprNode pLeft = pN->Use.Binary.pLeft;
        TPExprNode pRight = pN->Use.Binary.pRight;

        // Or-ing is commutative and constants on the right gives better assembler output.
        if (pLeft->Usage == uConst) {                                                               // left const
            pN->Use.Binary.pLeft = pRight;                                                          //
            pRight = pN->Use.Binary.pRight = pLeft;                                                 //
            pLeft = pN->Use.Binary.pLeft;                                                           //
            pRight = pN->Use.Binary.pRight;                                                         //
        }                                                                                           //

        if (pLeft->Usage == uConst) {                                                               // Left const
            pLeft->Use.Const.lInteger |= pRight->Use.Const.lInteger;                                //      (c | c) ==> c
            pLeft->pType = pN->pType;                                                               //
            return pLeft;                                                                           //      
        }                                                                                           //

        if (pRight->Usage == uConst) {                                                              // Right const
            if (pRight->Use.Const.lInteger == 0) {                                                  //      Right is const zero
                pLeft->pType = pN->pType;                                                           //
                return pLeft;                                                                       //      (v | 0) ==> v
            }                                                                                       //
            switch (CalcSizeOf(pLeft->pType)) {                                                     //      (v | ~0) ==> ~0
            case 1: if ((pRight->Use.Const.lInteger & 0xFF) == 0xFF) {                              //
                        pRight->pType = pN->pType;                                                  //
                        return pRight;                                                              //
                    }                                                                               //
                    break;                                                                          //
            case 2: if ((pRight->Use.Const.lInteger & 0xFFFF) == 0xFFFF) {                          //
                        pRight->pType = pN->pType;                                                  //
                        return pRight;                                                              //
                    }                                                                               //
                    break;                                                                          //
            case 4: if ((pRight->Use.Const.lInteger & 0xFFFFFFFF) == 0xFFFFFFFF) {                  //
                        pRight->pType = pN->pType;                                                  //
                        return pRight;                                                              //
                    }                                                                               //
                    break;                                                                          //
            }                                                                                       //
            if ((pLeft->Usage == uBinary) &&                                                        //
                (pLeft->Use.Binary.Op == BOr)) {                                                    //      left is or
                TPExprNode pSubLeft = pLeft->Use.Binary.pLeft;                                      //
                TPExprNode pSubRight = pLeft->Use.Binary.pRight;                                    //
                if (pSubRight->Usage == uConst) {                                                   //no need to check left = const                                                 //
                    pRight->Use.Const.lInteger |= pSubRight->Use.Const.lInteger;                    //     (v |  c) | c ==> v | c
                    pN->Use.Binary.pLeft = pSubLeft;                                                //
                    return OptimizeBinary(pN);                                                      //
                }                                                                                   //
            }                                                                                       //
            return pN;                                                                              //
        }                                                                                           //

        if ((pRight->Usage == uBinary) &&                                                           // Right is binary addition with a constant
            (pRight->Use.Binary.Op == BOr) &&                                                       //
            (pRight->Use.Binary.pRight->Usage == uConst) &&                                         //
            (pLeft->Usage == uBinary) &&                                                            // so is left.
            (pLeft->Use.Binary.Op == BOr) &&                                                        //
            (pRight->Use.Binary.pRight->Usage == uConst)) {                                         // (v|c)|(v|c) ==> (v|v)|c

            pRight->Use.Binary.pRight->Use.Const.lInteger |= pLeft->Use.Binary.pRight->Use.Const.lInteger;
            pLeft->Use.Binary.pRight = pRight->Use.Binary.pLeft;
            pN->Use.Binary.pRight = pRight->Use.Binary.pRight;
            return OptimizeBinary(pN);
        }

        return pN;
}

// ##########################################################################
// #  Function: OptimizeBinaryBXor
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static TPExprNode OptimizeBinaryBXor(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == BXor);
        
        TPExprNode pLeft = pN->Use.Binary.pLeft;
        TPExprNode pRight = pN->Use.Binary.pRight;

        // Or-ing is commutative and constants on the right gives better assembler output.
        if (pLeft->Usage == uConst) {                                                               // left const
            pN->Use.Binary.pLeft = pRight;                                                          //
            pRight = pN->Use.Binary.pRight = pLeft;                                                 //
            pLeft = pN->Use.Binary.pLeft;                                                           //
            pRight = pN->Use.Binary.pRight;                                                         //
        }                                                                                           //

        if (pLeft->Usage == uConst) {                                                               // Left const
            pLeft->Use.Const.lInteger ^= pRight->Use.Const.lInteger;                                //      (c | c) ==> c
            pLeft->pType = pN->pType;                                                               //
            return pLeft;                                                                           //      
        }                                                                                           //

        if (pRight->Usage == uConst) {                                                              // Right const
            if (pRight->Use.Const.lInteger == 0) {                                                  //      Right is const zero
                pLeft->pType = pN->pType;                                                           //
                return pLeft;                                                                       //      (v ^ 0) ==> v
            }                                                                                       //
            switch (CalcSizeOf(pLeft->pType)) {                                                     //      (v ^ ~0) ==> ~v
            case 1: if ((pRight->Use.Const.lInteger & 0xFF) == 0xFF) {                              //
                        pRight->Usage = uUnary;                                                     //
                        pRight->Use.Unary.Op = Neg;                                                 //
                        pRight->Use.Unary.pOperand = pLeft;                                         //
                        pRight->pType = pLeft->pType;                                               //
                        pRight->pType = pN->pType;                                                  //
                        return pRight;                                                              //
                    }
                    break;                                                                          //
            case 2: if ((pRight->Use.Const.lInteger & 0xFFFF) == 0xFFFF) {                          //
                        pRight->Usage = uUnary;                                                     //
                        pRight->Use.Unary.Op = Neg;                                                 //
                        pRight->Use.Unary.pOperand = pLeft;                                         //
                        pRight->pType = pLeft->pType;                                               //
                        return pRight;                                                              //
                    }                                                                               
                    break;                                                                          //
            case 4: if ((pRight->Use.Const.lInteger & 0xFFFFFFFF) == 0xFFFFFFFF) {                  //
                        pRight->Usage = uUnary;                                                     //
                        pRight->Use.Unary.Op = Neg;                                                 //
                        pRight->Use.Unary.pOperand = pLeft;                                         //
                        pRight->pType = pLeft->pType;                                               //
                        return pRight;                                                              //
                    }
                    break;                                                                          //
            }                                                                                       //
            if ((pLeft->Usage == uBinary) &&                                                        //
                (pLeft->Use.Binary.Op == BXor)) {                                                   //      left is xor
                TPExprNode pSubLeft = pLeft->Use.Binary.pLeft;                                      //
                TPExprNode pSubRight = pLeft->Use.Binary.pRight;                                    //
                if (pSubRight->Usage == uConst) {                                                   //no need to check left = const                                                 //
                    pRight->Use.Const.lInteger ^= pSubRight->Use.Const.lInteger;                    //     (v ^  c) ^ c ==> v ^ c
                    pN->Use.Binary.pLeft = pSubLeft;                                                //
                    return OptimizeBinary(pN);                                                      //
                }                                                                                   //
            }                                                                                       //
            return pN;                                                                              //
        }                                                                                           //

        if ((pRight->Usage == uBinary) &&                                                           // Right is binary addition with a constant
            (pRight->Use.Binary.Op == BXor) &&                                                       //
            (pRight->Use.Binary.pRight->Usage == uConst) &&                                         //
            (pLeft->Usage == uBinary) &&                                                            // so is left.
            (pLeft->Use.Binary.Op == BXor) &&                                                        //
            (pRight->Use.Binary.pRight->Usage == uConst)) {                                         // (v^c)^(v^c) ==> (v^v)^c

            pRight->Use.Binary.pRight->Use.Const.lInteger ^= pLeft->Use.Binary.pRight->Use.Const.lInteger;
            pLeft->Use.Binary.pRight = pRight->Use.Binary.pLeft;
            pN->Use.Binary.pRight = pRight->Use.Binary.pRight;
            return OptimizeBinary(pN);
        }

        return pN;
}

static TPExprNode OptimizeBinaryCEQ(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == CEQ);
#pragma message("    OptimizeBinaryCEQ(): Needs implementing")
        
        return pN;
}

static TPExprNode OptimizeBinaryCNE(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == CNE);
#pragma message("    OptimizeBinaryCNE(): Needs implementing")
        
        return pN;
}

static TPExprNode OptimizeBinaryCLT(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == CLT);
#pragma message("    OptimizeBinaryCLT(): Needs implementing")
        
        return pN;
}

static TPExprNode OptimizeBinaryCLE(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == CLE);
#pragma message("    OptimizeBinaryCLE(): Needs implementing")
        
        return pN;
}

static TPExprNode OptimizeBinaryCGT(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == CGT);
#pragma message("    OptimizeBinaryCGT(): Needs implementing")
        
        return pN;
}

static TPExprNode OptimizeBinaryCGE(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == CGE);
#pragma message("    OptimizeBinaryCGE(): Needs implementing")
        
        return pN;
}

static TPExprNode OptimizeBinaryLAnd(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == LAnd);
#pragma message("    OptimizeBinaryLAnd(): Needs implementing")
        
        return pN;
}

static TPExprNode OptimizeBinaryLOr(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == LOr);
#pragma message("    OptimizeBinaryLOr(): Needs implementing")
        
        return pN;
}

static TPExprNode OptimizeBinaryBSR(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == BSR);
#pragma message("    OptimizeBinaryBSR(): Needs implementing")
        
        return pN;
}

static TPExprNode OptimizeBinaryBSL(TPExprNode pN) {
        ASSERT(pN->Usage == uBinary);
        ASSERT(pN->Use.Binary.Op == BSL);
#pragma message("    OptimizeBinaryBSL(): Needs implementing")
        
        return pN;
}


// ##########################################################################################################

static TPExprNode OptimizeUnary(TPExprNode pN) {
    ASSERT(pN->Usage == uUnary);
    pN->Use.Unary.pOperand = Optimize(pN->Use.Unary.pOperand);

    switch (pN->Use.Unary.Op) {
    case Minus:     return OptimizeUnaryMinus(pN);
    case Plus:      return OptimizeUnaryPlus(pN);
    case Neg:       return OptimizeUnaryNeg(pN);
    case PostInc:   return OptimizeUnaryPostInc(pN);
    case PreInc:    return OptimizeUnaryPreInc(pN);
    case PostDec:   return OptimizeUnaryPostDec(pN);
    case PreDec:    return OptimizeUnaryPreDec(pN);
    case SizeOf:    return OptimizeUnarySizeOf(pN);
    case Addr:      return OptimizeUnaryAddr(pN);
    case Ptr:       return OptimizeUnaryPtr(pN);
    case Not:       return OptimizeUnaryNot(pN);
    default:
        Error(FATAL, "OptimizeUnary(): What [%d]\n", pN->Use.Unary.Op);
    }
    return pN;
}

static TPExprNode OptimizeBinary(TPExprNode pN) {
    ASSERT(pN->Usage == uBinary);
    pN->Use.Binary.pLeft = Optimize(pN->Use.Binary.pLeft);
    pN->Use.Binary.pRight = Optimize(pN->Use.Binary.pRight);
    
    switch (pN->Use.Binary.Op) {
    case Add:  return OptimizeBinaryAdd(pN);
    case Sub:  return OptimizeBinarySub(pN);
    case Mul:  return OptimizeBinaryMul(pN);
    case Div:  return OptimizeBinaryDiv(pN);
    case Mod:  return OptimizeBinaryMod(pN);
    case BAnd: return OptimizeBinaryBAnd(pN);
    case BOr:  return OptimizeBinaryBOr(pN);
    case BXor: return OptimizeBinaryBXor(pN);
    case CEQ:  return OptimizeBinaryCEQ(pN);
    case CNE:  return OptimizeBinaryCNE(pN);
    case CLT:  return OptimizeBinaryCLT(pN);
    case CLE:  return OptimizeBinaryCLE(pN);
    case CGT:  return OptimizeBinaryCGT(pN);
    case CGE:  return OptimizeBinaryCGE(pN);
    case LAnd: return OptimizeBinaryLAnd(pN);
    case LOr:  return OptimizeBinaryLOr(pN);
    case BSR:  return OptimizeBinaryBSR(pN);
    case BSL:  return OptimizeBinaryBSL(pN);
    default:   
        Error(FATAL, "OptimizeBinary(): What [%d]\n", pN->Use.Binary.Op);
    }
    return pN;
}


static TPExprNode OptimizeTernary(TPExprNode pN) {
    ASSERT(pN->Usage == uTernary);
    pN->Use.Ternary.First = Optimize(pN->Use.Ternary.First);
    pN->Use.Ternary.Second = Optimize(pN->Use.Ternary.Second);
    pN->Use.Ternary.Third = Optimize(pN->Use.Ternary.Third);
    return pN;
}

static TPExprNode OptimizeDotExpr(TPExprNode pN) {
    ASSERT(pN->Usage == uDot);
    pN->Use.Dot.pRecord = Optimize(pN->Use.Dot.pRecord);
    return pN;
}


static TPExprNode OptimizeArrowExpr(TPExprNode pN) {
    ASSERT(pN->Usage == uArrow);
    pN->Use.Arrow.pRecord = Optimize(pN->Use.Arrow.pRecord);
    return pN;
}


static TPExprNode OptimizeArrayExpr(TPExprNode pN) {
    ASSERT(pN->Usage == uArray);
    pN->Use.Array.pVector = Optimize(pN->Use.Array.pVector);
    pN->Use.Array.pIndex = Optimize(pN->Use.Array.pIndex);
    return pN;
}


static TPExprNode OptimizeAssign(TPExprNode pN) {
    ASSERT(pN->Usage == uAssign);
    pN->Use.Assign.pLval = Optimize(pN->Use.Assign.pLval);
    pN->Use.Assign.pRval = Optimize(pN->Use.Assign.pRval);
    return pN;
}


static TPExprNode Optimize(TPExprNode pN) {
    if (pN == NULL) {
        Error(FATAL, "Optimizing a NULL expression");
        return pN;
    }

    switch (pN->Usage) {
    case uConst:    return pN;                          // We can't improve on a single Const value;
    case uVar:      return pN;                          // We can't improve on a single variable value;
    case uUnary:    return OptimizeUnary(pN);           // Do what we can with unary opaeration.
    case uBinary:   return OptimizeBinary(pN);          // Do what we can with binary operations.
    case uTernary:  return OptimizeTernary(pN);         // Do what we can with Ternaryoperations.
    case uDot:      return OptimizeDotExpr(pN);         // Do what we can with structure DOT expression.
    case uArrow:    return OptimizeArrowExpr(pN);       // Do what we can with structure Arrow expression.
    case uArray:    return OptimizeArrayExpr(pN);       // Do what we can with Array expression.
    case uFunc:     return pN;                          // We can't improve on a function call.
    case uCast_c2s:
    case uCast_c2l:                                     // Currently ignoring Casts (is this wize?)
    case uCast_s2l:
    case uCast_b2s:
    case uCast_b2l:
    case uCast_u2l:
    case uCast_l2s:
    case uCast_l2b:
    case uCast_s2b: return Optimize(pN->Use.Cast.pTarget);
    case uAssign:   return OptimizeAssign(pN);          // Do what we can with assignments.
    default:        Error(FATAL, "ParseExpr: What [%d]\n", pN->Usage);
        return NULL;
    }
}





// ##########################################################################
// #  Function: ExprOptimize
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
TPExprNode  ExprOptimize(TPExprNode pN) {

    ConsolePrintf(CON_WHITE_BRIGHT, "Optimizer  Before\n");
    GenExpressionPrettyPrint(4, pN);
    
    pN = Optimize(pN);
    
    ConsolePrintf(CON_WHITE_BRIGHT, "Optimizer  After\n");    
    GenExpressionPrettyPrint(4, pN);
    
    ConsolePrintf(CON_WHITE_BRIGHT, "Optimizer  End\n");  

    return pN;
}    



/* eof */

