
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <setjmp.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <limits.h>
#include <float.h>
#include <Windows.h>

//#include <ext\types.h>

#include "C_Yacced.tab.h"
#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "main.h"


/* *************************************************************** */

#define GEN_PREFIX "L"
static DWORD GenCount = 0;

LPSTR
GenLabel(LPSTR PreFix) {
    LPSTR Label = New(strlen(GEN_PREFIX)+strlen(PreFix)+6+1);
    sprintf(Label, GEN_PREFIX "%s%06ld", PreFix, GenCount++);
    return Label;
 }

/* ******************************************************* */
/*  General Expression Housekeeping  */
/* ********************************* */

static LpExprNode
NewExprNode(ExprUsage Use) {
    LpExprNode NewEl;
    NewEl = New(sizeof(ExprNode));
    NewEl->Usage   = Use;
    NewEl->Type    = NULL;
    return NewEl;
 }

LpExprNode
MakeExprConstC(LONG Value) {
    LpExprNode New;
    New = NewExprNode(uConst);
    New->Type = NewSpecType(TypeCHAR,NULL);
    New->Use.Const.Integer = Value;
    return New;
 }

LpExprNode
MakeExprConstI(LONG Value) {
    LpExprNode New;
    New = NewExprNode(uConst);
    if      ((SCHAR_MIN <= Value) && (Value <= SCHAR_MAX)) New->Type = NewSpecType(TypeSIGNED|  TypeCHAR, NULL);
    else if ((0 <= Value)         && (Value <= UCHAR_MAX)) New->Type = NewSpecType(TypeUNSIGNED|TypeCHAR, NULL);
    else if ((SHRT_MIN <= Value)  && (Value <= SHRT_MAX))  New->Type = NewSpecType(TypeSIGNED|  TypeSHORT,NULL);
    else if ((0 <= Value)         && (Value <= USHRT_MAX)) New->Type = NewSpecType(TypeUNSIGNED|TypeSHORT,NULL);
    else if ((LONG_MIN <= Value)  && (Value <= LONG_MAX))  New->Type = NewSpecType(TypeSIGNED|  TypeLONG, NULL);
    else                                                   New->Type = NewSpecType(TypeUNSIGNED|TypeLONG, NULL);
    New->Use.Const.Integer = Value;
    return New;
 }

LpExprNode
MakeExprConstF(DOUBLE Value) {
    Warning0("Floating point numbers are not supported.","");
    return MakeExprConstI((LONG)Value);
 }

LpExprNode
MakeExprConstS(LPSTR Str) {
    LPSTR Lab = GenLabel("Str");
    LpDeclSpec p;
    p = NewIdentifier(Lab);
    p = NewArray(p,NULL);
    p = AddInitializerStr(p,Str);
    p = AppendDecl(p,NewSpecType(TypeCHAR,NULL));
    Declaration(p,TRUE);
    return MakeExprVar(Lab);
 }

LpExprNode
MakeExprVar(LPSTR Variable) {
    LpExprNode New;
    LpDeclSpec V;
    New = NewExprNode(uVar);
    V   = FindLocalObject(Variable);
    if (!V) V = FindGlobalObject(Variable);
    if (!V) {
        Error0("Unknown Variable ",Variable);
        New->Type = NewSpecType(TypeLONG,NULL);
    } else {
        New->Type = V->Use.DecId.pTarget;
    }
    New->Use.Var.Identifier = Variable;
    return New;
 }

/* *************************************************** */

#define IsStruct(n)    (((n)->Usage == DecSpec) &&  ((n)->Use.DecSpec.Type & TypeSTRUCT))
#define IsSimple(n)    (((n)->Usage == DecSpec) && !((n)->Use.DecSpec.Type & TypeSTRUCT))
#define IsPointer(n)    ((n)->Usage == DecPtr)
#define IsArray(n)      ((n)->Usage == DecArray)
#define IsFunc(n)       ((n)->Usage == DecFunc)
#define IsReference(n)  (IsPointer(n) || IsArray(n))
#define IsPtrStruct(n)  (IsPointer(n) && IsStruct((n)->Use.DecPtr.pTarget))

/* *************************************************** */
      
DeclSpec    Std_Ubyte   = { DecSpec, NULL, { 0, TypeUNSIGNED|TypeCHAR, 0, NULL } } ;
DeclSpec    Std_Sbyte   = { DecSpec, NULL, { 0, TypeSIGNED|TypeCHAR,   0, NULL } } ;
DeclSpec    Std_Uword   = { DecSpec, NULL, { 0, TypeUNSIGNED|TypeSHORT,0, NULL } } ;
DeclSpec    Std_Sword   = { DecSpec, NULL, { 0, TypeSIGNED|TypeSHORT,  0, NULL } } ;
DeclSpec    Std_Ulong   = { DecSpec, NULL, { 0, TypeUNSIGNED|TypeLONG, 0, NULL } } ;
DeclSpec    Std_Slong   = { DecSpec, NULL, { 0, TypeSIGNED|TypeLONG,   0, NULL } } ;

LpDeclSpec  LpStd_Ubyte = &Std_Ubyte;
LpDeclSpec  LpStd_Sbyte = &Std_Sbyte;
LpDeclSpec  LpStd_Uword = &Std_Uword;
LpDeclSpec  LpStd_Sword = &Std_Sword;
LpDeclSpec  LpStd_Ulong = &Std_Ulong;
LpDeclSpec  LpStd_Slong = &Std_Slong;




//static LpExprNode
//Cast(LpExprNode Left, LpDeclSpec Newtype) {
//#pragma message("Cast:  insert convert operand size code.")
//    return Left;
//}

///* ************************************************************ */
///*  pointer and node return the smallest integral pointer type  */
///* ************************************************************ */
//
//static LpDeclSpec
//CastToValidPointer(LpDeclSpec Ptr) {
//    if      (CalcSizeOf(Ptr) <= SIZE_CHAR)  return NewSpecType(TypeUNSIGNED|TypeCHAR,NULL);
//    else if (CalcSizeOf(Ptr) <= SIZE_SHORT) return NewSpecType(TypeUNSIGNED|TypeSHORT,NULL);
//    else                                    return NewSpecType(TypeUNSIGNED|TypeLONG,NULL);
//}

///* ************************************************************ */
///*  Make a binary node and insert the required castings         */
///* ************************************************************ */
//
//static LpExprNode
//FixCastings(LpExprNode New, LpExprNode Left, LpExprNode Right) {
//    if (!CompDecl(New->Type,Left->Type))  Left = MakeCastNode(New->Type, Left);
//    if (!CompDecl(New->Type,Right->Type)) Right= MakeCastNode(New->Type, Right);
//    New->Use.Binary.Left  = Left;
//    New->Use.Binary.Right = Right;
//    return New;
// }

/* ************************************************** */
/*  Unary  */
/* ******* */

static LpExprNode
NewUnary(WORD Op,  LpExprNode Node) {
    LpExprNode New;
    New = NewExprNode(uUnary);
    New->Use.Unary.Op = Op;             // operation  
    New->Use.Unary.Operand = Node;      // target of operation
    New->Type = Node->Type;             // assume no change in type.
    return New;
 }
 
static LpExprNode
UMinus(LpExprNode Node) {
    LpExprNode New;
    if (!IsSimple(Node->Type)) {
        Warning0("Unary arithmetic is only posible on simple types.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Node->Use.Const.Integer = -(Node->Use.Const.Integer);
        return Node;
    } else {
        New = NewUnary(Minus, Node);
        return  New;
    }
 }
 
static LpExprNode
UPlus(LpExprNode Node) {
    if (!IsSimple(Node->Type)) {
        Warning0("Unary arithmetic is only posible on simple types.","");
        return Node;
    }
    return Node;
 }
 
static LpExprNode
UNeg(LpExprNode Node) {
    LpExprNode New;
    if (!IsSimple(Node->Type)) {
        Warning0("Unary arithmetic is only posible on simple types.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Node->Use.Const.Integer = ~(Node->Use.Const.Integer);
        return Node;
    } else {
        New = NewUnary(Neg, Node);
        return  New;
    }
 }
 
static LpExprNode
UNot(LpExprNode Node) {
    LpExprNode New;
    if (IsStruct(Node->Type)) {
        Warning0("Unary logic is not possible on struct/union.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Node->Use.Const.Integer = !(Node->Use.Const.Integer);
        return Node;
    } else {
        New = NewUnary(Not, Node);
        New->Type = LpStd_Ubyte;
        return  New;
    }
 }
 
static LpExprNode
UPostInc(LpExprNode Node) {
    LpExprNode New;
    if (IsStruct(Node->Type)) {
        Warning0("Cannot perform '++'/'--' on a structure.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error0("'++' or '--' on a Constant is bit dumb.","");
        return Node;
    } else {
        New = NewUnary(PostInc, Node);
        return  New;
    }
 }
 
static LpExprNode
UPreInc(LpExprNode Node) {
    LpExprNode New;
    if (IsStruct(Node->Type)) {
        Warning0("Cannot perform '++'/'--' on a structure.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error0("'++' or '--' on a Constant is bit dumb.","");
        return Node;
    } else {
        New = NewUnary(PreInc, Node);
        return  New;
    }
 }
 
static LpExprNode
UPostDec(LpExprNode Node) {
    LpExprNode New;
    if (IsStruct(Node->Type)) {
        Warning0("Cannot perform '++'/'--' on a structure.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error0("'++' or '--' on a Constant is bit dumb.","");
        return Node;
    } else {
        New = NewUnary(PostDec, Node);
        return  New;
    }
 }
 
static LpExprNode
UPreDec(LpExprNode Node) {
    LpExprNode New;
    if (IsStruct(Node->Type)) {
        Warning0("Cannot perform '++'/'--' on a structure.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error0("'++' or '--' on a Constant is bit dumb.","");
        return Node;
    } else {
        New = NewUnary(PreDec, Node);
        return  New;
    }
 }
 
static LpExprNode
USizeof(LpExprNode Node) {
    return MakeExprConstI(CalcSizeOf(Node->Type));
 }
 
static LpExprNode
UAddr(LpExprNode Node) {
    LpExprNode New;
    if (Node->Usage == uConst)  {
        Error0("Address of constant is meaningless.","");
        return Node;
    } else {
        New = NewUnary(Addr, Node);
        New->Type = NewPointer(NULL,Node->Type);
        return  New;
    }
 }

                          
static LpExprNode
UPtr(LpExprNode Node) {
    LpExprNode New;
    if (Node->Type->Usage == DecPtr) {
        New = NewUnary(Ptr, Node);
        New->Type = Node->Type->Use.DecPtr.pTarget;
        return  New;
    } else if (Node->Type->Usage == DecArray) {
        New = NewUnary(Ptr, Node);
        New->Type = Node->Type->Use.DecArray.pTarget;
        return  New;
    } else {
        Error0("De-Reference of a Non pointer type","");
        return Node;
    }
 }


LpExprNode
MakeUnaryNode(WORD Op,  LpExprNode Node) {
    switch (Op) {
        case    Minus:      return UMinus(Node);
        case    Plus:       return UPlus(Node);
        case    Neg:        return UNeg(Node);
        case    Not:        return UNot(Node);
        case    PostInc:    return UPostInc(Node);
        case    PreInc:     return UPreInc(Node);
        case    PostDec:    return UPostDec(Node);
        case    PreDec:     return UPreDec(Node);
        case    SizeOf:     return USizeof(Node);
        case    Addr:       return UAddr(Node);
        case    Ptr:        return UPtr(Node);
        default:            printf("MakeUnaryNode: UnKnown Unary Operator %d\n", Op);
                            return Node;        
    }
 }

/* ************************************************** */
/*  Binary  */
/* ******** */

static LpDeclSpec
ResultingType(LpDeclSpec Left, LpDeclSpec Right) {
#pragma message("ResultingType: calculate result of combination.")
    return Left;
}


static LpExprNode
NewBinary(WORD Op,  LpExprNode Left, LpExprNode Right) {
    LpExprNode New;
    New = NewExprNode(uBinary);
    New->Use.Binary.Op    = Op;                         // operation  
    New->Use.Binary.Left  = Left;                       // target of operation
    New->Use.Binary.Right = Right;                      // target of operation
    New->Type = ResultingType(Left->Type,Right->Type);  // assume no change in type.
    return New;
 }

static LpExprNode Badd (LpExprNode Left, LpExprNode Right);
static LpExprNode Bsub (LpExprNode Left, LpExprNode Right);
static LpExprNode Bmul (LpExprNode Left, LpExprNode Right);
static LpExprNode Bdiv (LpExprNode Left, LpExprNode Right);
static LpExprNode Bmod (LpExprNode Left, LpExprNode Right);
static LpExprNode Bband(LpExprNode Left, LpExprNode Right);
static LpExprNode Bbor (LpExprNode Left, LpExprNode Right);
static LpExprNode Bbxor(LpExprNode Left, LpExprNode Right);
static LpExprNode Bceq (LpExprNode Left, LpExprNode Right);
static LpExprNode Bcne (LpExprNode Left, LpExprNode Right);
static LpExprNode Bclt (LpExprNode Left, LpExprNode Right);
static LpExprNode Bcle (LpExprNode Left, LpExprNode Right);
static LpExprNode Bcgt (LpExprNode Left, LpExprNode Right);
static LpExprNode Bcge (LpExprNode Left, LpExprNode Right);
static LpExprNode Bland(LpExprNode Left, LpExprNode Right);
static LpExprNode Blor (LpExprNode Left, LpExprNode Right);
static LpExprNode Bbsr (LpExprNode Left, LpExprNode Right);
static LpExprNode Bbsl (LpExprNode Left, LpExprNode Right);



static LpExprNode
Badd (LpExprNode Left, LpExprNode Right) {
    LpExprNode New;
    LpDeclSpec NewType;
    if (IsStruct(Left->Type) || IsStruct(Right->Type)) {
        Error0("Addition of Structures is not possible.\n","");
        return Left;
    }
    if (IsReference(Left->Type) && IsReference(Right->Type)) {
        Error0("Addition of References is not possible.\n","");
        return Left;
    }
    if (IsSimple(Left->Type) && IsReference(Right->Type)) {
        New   = Right;
        Right = Left;
        Left  = New;
        /* fall through (then pass) next test */
    }
    if (IsReference(Left->Type) && IsSimple(Right->Type)) {
        if (IsPointer(Left->Type)) Right = Bmul(Right, MakeExprConstI(CalcSizeOf(Left->Type->Use.DecPtr.pTarget)));
        else                       Right = Bmul(Right, MakeExprConstI(CalcSizeOf(Left->Type->Use.DecArray.pTarget)));
        /* fall through to simple add */
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.Integer += Right->Use.Const.Integer;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Add")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType, Left);
        Right   = MakeCastNode(NewType, Right);
        return NewBinary(Add,Left,Right);
    }
 }

static LpExprNode
Bsub (LpExprNode Left, LpExprNode Right) {
    LpExprNode New;
    LpDeclSpec NewType;
    if (IsStruct(Left->Type) || IsStruct(Right->Type)) {
        Error0("Subtraction of Structures is not possible.\n","");
        return Left;
    }
    if (IsReference(Left->Type) && IsReference(Right->Type)) {
        if (!CompDecl(Left->Type, Right->Type)) {
            Error0("Subtraction of dissimilar references is not possible.\n","");
            return Left;
        }
        if (Left->Usage == uConst && Right->Usage == uConst) {
            Left->Use.Const.Integer -= Right->Use.Const.Integer;
            Left->Use.Const.Integer /= CalcSizeOf(Right->Type->Use.DecPtr.pTarget);
            switch(CalcSizeOf(Left->Type)) {
                case 1: Left = MakeCastNode(LpStd_Ubyte, Left); break;
                case 2: Left = MakeCastNode(LpStd_Uword, Left); break;
                default:Left = MakeCastNode(LpStd_Ulong, Left); break;
            }
            CleanUp(Right);
            return Left;
        } else {
            New = NewBinary(Sub,Left,Right);
            New = NewBinary(Div,New,MakeExprConstI(CalcSizeOf(Left->Type->Use.DecArray.pTarget)));
            switch(CalcSizeOf(New->Type)) {
                case 1: New = MakeCastNode(LpStd_Ubyte, New); break;
                case 2: New = MakeCastNode(LpStd_Uword, New); break;
                default:New = MakeCastNode(LpStd_Ulong, New); break;
            }
            return New;
        }
    }
    if (IsReference(Right->Type)) {
        Error0("Subtraction of a reference is not possible.\n","");
        return Left;
    }
    if (IsReference(Left->Type) && IsSimple(Right->Type)) {
        if (IsPointer(Left->Type)) Right = Bmul(Right, MakeExprConstI(CalcSizeOf(Left->Type->Use.DecPtr.pTarget)));
        else                       Right = Bmul(Right, MakeExprConstI(CalcSizeOf(Left->Type->Use.DecArray.pTarget)));
        /* fall through to simple sub */
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.Integer -= Right->Use.Const.Integer;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Sub")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(Sub,Left,Right);
    }
 }

static LpExprNode
Bmul (LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (!IsSimple(Left->Type) || !IsSimple(Right->Type)) {
            Error0("Multiplication of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.Integer   *= Right->Use.Const.Integer;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Mul")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(Mul,Left,Right);
    }
 }

static LpExprNode
Bdiv (LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (!IsSimple(Left->Type) || !IsSimple(Right->Type)) {
            Error0("Division of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.Integer /= Right->Use.Const.Integer;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Div")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(Div,Left,Right);
    }
 }


static LpExprNode
Bmod (LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (!IsSimple(Left->Type) || !IsSimple(Right->Type)) {
            Error0("Modulus of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.Integer %= Right->Use.Const.Integer;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Mod")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(Mod,Left,Right);
    }
 }


static LpExprNode
Bband(LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (!IsSimple(Left->Type) || !IsSimple(Right->Type)) {
            Error0("Bitwise-And of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.Integer &= Right->Use.Const.Integer;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize And")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(BAnd,Left,Right);
    }
 }

static LpExprNode
Bbor (LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (!IsSimple(Left->Type) || !IsSimple(Right->Type)) {
            Error0("Bitwise-Or of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.Integer |= Right->Use.Const.Integer;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Or")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(BOr,Left,Right);
    }
 }

static LpExprNode
Bbxor(LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (!IsSimple(Left->Type) || !IsSimple(Right->Type)) {
            Error0("Bitwise-Xor of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.Integer ^= Right->Use.Const.Integer;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Xor")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(BXor,Left,Right);
    }
 }

static LpExprNode
Bbsr (LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (!IsSimple(Left->Type) || !IsSimple(Right->Type)) {
            Error0("Shift-Right of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.Integer >>= Right->Use.Const.Integer;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize >>")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(BSR,Left,Right);
    }
 }

static LpExprNode
Bbsl (LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (!IsSimple(Left->Type) || !IsSimple(Right->Type)) {
            Error0("Shift-Left of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.Integer <<= Right->Use.Const.Integer;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize <<")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(BSL,Left,Right);
    }
 }

static LpExprNode
Bceq (LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (IsStruct(Left->Type)  || IsStruct(Right->Type)) {
        Error0("Comparison of structures is not possible.\n","");                                           
        return Left;
    }                                                                                                      
    if ((IsReference(Left->Type)  && IsSimple(Right->Type)) ||                                             
        (IsSimple(Left->Type)     && IsReference(Right->Type))) {                                          
            Error0("Comparison a reference to a non-reference is not possible.\n","");                     
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.Integer = (Left->Use.Const.Integer == Right->Use.Const.Integer) ? TRUE : FALSE;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize ==")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(CEQ,Left,Right);
    }
}

static LpExprNode
Bcne (LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (IsStruct(Left->Type)  || IsStruct(Right->Type)) {
        Error0("Comparison of structures is not possible.\n","");
        return Left;
    }
    if ((IsReference(Left->Type)  && IsSimple(Right->Type)) ||
        (IsSimple(Left->Type)     && IsReference(Right->Type))) {
            Error0("Comparison a reference to a non-reference is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.Integer = (Left->Use.Const.Integer != Right->Use.Const.Integer) ? TRUE : FALSE;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize !=")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(CNE,Left,Right);
    }
}                                                                                                          

static LpExprNode
Bclt (LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (IsStruct(Left->Type)  || IsStruct(Right->Type)) {                                                  \
       Error0("Comparison of structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if ((IsReference(Left->Type)  && IsSimple(Right->Type)) ||                                             \
        (IsSimple(Left->Type)     && IsReference(Right->Type))) {                                          \
            Error0("Comparison a reference to a non-reference is not possible.\n","");                     \
            return Left;                                                                                   \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.Integer = (Left->Use.Const.Integer < Right->Use.Const.Integer) ? TRUE : FALSE;        \
        CleanUp(Right);                                                                                        \
        return Left;
    } else {
#pragma message("Optimize <")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(CLT,Left,Right);
    }
}                                                                                                          \

static LpExprNode
Bcle (LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (IsStruct(Left->Type)  || IsStruct(Right->Type)) {                                                  \
        Error0("Comparison of structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if ((IsReference(Left->Type)  && IsSimple(Right->Type)) ||                                             \
        (IsSimple(Left->Type)     && IsReference(Right->Type))) {                                          \
            Error0("Comparison a reference to a non-reference is not possible.\n","");                     \
            return Left;                                                                                   \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.Integer = (Left->Use.Const.Integer <= Right->Use.Const.Integer) ? TRUE : FALSE;        \
        CleanUp(Right);                                                                                        \
        return Left;
    } else {
#pragma message("Optimize <=")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(CLE,Left,Right);
    }
}                                                                                                          \

static LpExprNode
Bcgt (LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (IsStruct(Left->Type)  || IsStruct(Right->Type)) {                                                  \
       Error0("Comparison of structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if ((IsReference(Left->Type)  && IsSimple(Right->Type)) ||                                             \
        (IsSimple(Left->Type)     && IsReference(Right->Type))) {                                          \
            Error0("Comparison a reference to a non-reference is not possible.\n","");                     \
            return Left;                                                                                   \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.Integer = (Left->Use.Const.Integer > Right->Use.Const.Integer) ? TRUE : FALSE;        \
        CleanUp(Right);                                                                                        \
        return Left;
    } else {
#pragma message("Optimize >")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(CGT,Left,Right);
    }
}                                                                                                          \

static LpExprNode
Bcge (LpExprNode Left, LpExprNode Right) {
    LpDeclSpec NewType;
    if (IsStruct(Left->Type)  || IsStruct(Right->Type)) {                                                  \
       Error0("Comparison of structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if ((IsReference(Left->Type)  && IsSimple(Right->Type)) ||                                             \
        (IsSimple(Left->Type)     && IsReference(Right->Type))) {                                          \
            Error0("Comparison a reference to a non-reference is not possible.\n","");                     \
            return Left;                                                                                   \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.Integer = (Left->Use.Const.Integer >= Right->Use.Const.Integer) ? TRUE : FALSE;        \
        CleanUp(Right);                                                                                        \
        return Left;
    } else {
#pragma message("Optimize >=")
        NewType = ResultingType(Left->Type,Right->Type);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(CGE,Left,Right);
    }
}                                                                                                          \



static LpExprNode
Bland(LpExprNode Left, LpExprNode Right) {
    if (IsStruct(Left->Type)  || IsStruct(Right->Type)) {                                                  \
       Error0("Logical Operations on structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.Integer = Left->Use.Const.Integer && Right->Use.Const.Integer;
        CleanUp(Right);
        Left->Type = LpStd_Ubyte;
        return Left;
    } else {
#pragma message("Optimize &&")
        Left    = MakeCastNode(LpStd_Ubyte,Left);
        Right   = MakeCastNode(LpStd_Ubyte,Right);
        return NewBinary(LAnd,Left,Right);
    }
}                                                                                                          \

static LpExprNode
Blor (LpExprNode Left, LpExprNode Right) {
    if (IsStruct(Left->Type)  || IsStruct(Right->Type)) {                                                  \
       Error0("Logical Operations on structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.Integer = Left->Use.Const.Integer || Right->Use.Const.Integer;
        CleanUp(Right);
        Left->Type = LpStd_Ubyte;
        return Left;
    } else {
#pragma message("Optimize ||")
        Left    = MakeCastNode(LpStd_Ubyte,Left);
        Right   = MakeCastNode(LpStd_Ubyte,Right);
        return NewBinary(LOr,Left,Right);
    }
}


LpExprNode
MakeBinaryNode(WORD Op, LpExprNode Left, LpExprNode Right) {
    switch (Op) {
        case    Add:    return Badd (Left,Right);
        case    Sub:    return Bsub (Left,Right);
        case    Mul:    return Bmul (Left,Right);
        case    Div:    return Bdiv (Left,Right);
        case    Mod:    return Bmod (Left,Right);
        case    BAnd:   return Bband(Left,Right);
        case    BOr:    return Bbor (Left,Right);
        case    BXor:   return Bbxor(Left,Right);
        case    CEQ:    return Bceq (Left,Right);
        case    CNE:    return Bcne (Left,Right);
        case    CLT:    return Bclt (Left,Right);
        case    CLE:    return Bcle (Left,Right);
        case    CGT:    return Bcgt (Left,Right);
        case    CGE:    return Bcge (Left,Right);
        case    LAnd:   return Bland(Left,Right);
        case    LOr:    return Blor (Left,Right);
        case    BSR:    return Bbsr (Left,Right);
        case    BSL:    return Bbsl (Left,Right);
        default:        printf("MakeBinaryNode: UnKnown Binary Operator %d\n", Op);
                        return Left;
    }
 }



/* ************************************************** */
/*  Ternary  */
/* ********* */

LpExprNode
TernaryCondExp(LpExprNode First, LpExprNode Second, LpExprNode Third) {
    LpExprNode New;
    if (First->Usage == uConst) {
        if (First->Use.Const.Integer) {
            CleanUp(First);
            CleanUp(Third);
            return Second;
        } else {
            CleanUp(First);
            CleanUp(Second);
            return Third;
        }
    }
    New = NewExprNode(uTernary);
    New->Type = ResultingType(Second->Type,Third->Type);
    New->Use.Ternary.Op     = CondExp;
    New->Use.Ternary.First  = First;
    New->Use.Ternary.Second = MakeCastNode(New->Type,Second);
    New->Use.Ternary.Third  = MakeCastNode(New->Type,Third);
    return New;
 }

LpExprNode
MakeTernaryNode(WORD Op,  LpExprNode First, LpExprNode Second, LpExprNode Third) {
    switch (Op) {
        case  CondExp:  return TernaryCondExp(First,Second,Third);
                        break;
        default:        printf("MakeTernaryNode: UnKnown Ternary Operator %d\n", Op);
                        return First;
    }
}



/* *************************************************************************** */
/*  Action Nodes                                                               */
/*  need some run time action to be performed in order to determin the result  */
/* *************************************************************************** */


    

LpExprNode
MakeDotNode(LpExprNode Left,  LPSTR Field) {
    LpExprNode New;
    if (!IsStruct(Left->Type)) {
        Error0("Dot expected to be preceeded by a Struct/Union\n","");
        return Left;
    }
    if (CalcStructElementOffset(Left->Type->Use.DecSpec.Ptr, Field) < 0) {
        Error0("Unknown struct/union field",Field);
        return Left;
    }
    New = NewExprNode(uDot);
    New->Type = CalcStructElementType(Left->Type->Use.DecSpec.Ptr, Field);
    New->Use.Dot.Record = Left;
    New->Use.Dot.Field  = Field;
    return New;  
}

LpExprNode
MakeArrowNode(LpExprNode Left,  LPSTR Field) {
    LpExprNode New;
    if (!IsPtrStruct(Left->Type)) {
        Error0("Arrow expected to be preceeded by a Pointer to Struct/Union\n","");
        return Left;
    }
    if (CalcStructElementOffset(Left->Type->Use.DecPtr.pTarget->Use.DecSpec.Ptr, Field) < 0) {
        Error0("Unknown struct/union field",Field);
        return Left;
    }
    New = NewExprNode(uDot);
    New->Type = CalcStructElementType(Left->Type->Use.DecPtr.pTarget->Use.DecSpec.Ptr, Field);
    New->Use.Dot.Record = Left;
    New->Use.Dot.Field  = Field;
    return New;  
}


LpExprNode
MakeArrayNode(LpExprNode Vec,  LpExprNode Ind) {
    LpExprNode New;
    if (!IsReference(Vec->Type) && IsSimple(Ind->Type)) {
        Error0("Reference expected before [...]","");
        return Vec;
    }
    New = NewExprNode(uArray);
    New->Use.Array.Vector = Vec;
    if (IsPointer(Vec->Type)) {
        New->Use.Array.Index = Bmul(Ind, MakeExprConstI(CalcSizeOf(Vec->Type->Use.DecPtr.pTarget)));
        New->Type = Vec->Type->Use.DecPtr.pTarget;
    } else {
        New->Use.Array.Index = Bmul(Ind, MakeExprConstI(CalcSizeOf(Vec->Type->Use.DecArray.pTarget)));
        New->Type = Vec->Type->Use.DecArray.pTarget;
    }
    return New;
 }



LpExprNode
MakeFuncNode(LpExprNode Func,  LpExprNode Params) {
    LpExprNode New;
    if (!IsFunc(Func->Type)) {
        Error0("Function expected before (...)","");
        return Func;
    }
    New = NewExprNode(uFunc);
    New->Type = Func->Type->Use.DecFunc.pTarget;
    New->Use.Func.Func   = Func;                  // Funky !
    New->Use.Func.Params = Params;
    return New;
 }


/* ************************************************** */
/*  Assignment */
/* *********** */

LpExprNode
MakeAssignNode(WORD Op, LpExprNode Lval, LpExprNode Rval) {
    LpExprNode New;
    New = NewExprNode(uAssign);
    New->Use.Assign.Op    = Op;
    New->Type             = Lval->Type;    
    New->Use.Assign.Lval  = Lval;
    New->Use.Assign.Rval  = Rval;
    return New;
}

/* ************************************************** */
/*  Cast  */
/* ****** */
static LONG
TypeConvert(LpDeclSpec NewType, LpDeclSpec OldType, LONG Const) {
    WORD SzOld, SzNew;
    if (IsStruct(NewType) || IsStruct(OldType)) {
        Error0("Casting to/from struct is not possible.\n","");
        return 0L;
    }
    SzOld = (WORD)CalcSizeOf(OldType);
    SzNew = (WORD)CalcSizeOf(NewType);
    if (IsReference(NewType) && IsReference(OldType) && (SzOld != SzNew)) {
        Warning0("Conversion between near & far pointers.","");
    }
    if (!(IsReference(NewType) || IsReference(OldType))) {
        if (SzNew > SzOld) {                                            // Cast up
            if (OldType->Use.DecSpec.Type & TypeUNSIGNED) {
                switch (SzOld) {                                        // Cast up Unsigned
                    case 1: Const &= 0x000000ff; break;
                    case 2: Const &= 0x0000ffff; break;
                    case 3: Const &= 0x00ffffff; break;
                    case 4: Const &= 0xffffffff; break;
                    default: Error0("Casting unsigned constant from an unsupported size.\n","");
                }
            } else {                                                    // Cast up signed
                switch (SzOld) {
                    case 1: if (Const & 0x00000080) Const |= 0xffffff00; else Const &= 0x000000ff; break;
                    case 2: if (Const & 0x00008000) Const |= 0xffff0000; else Const &= 0x0000ffff; break;
                    case 3: if (Const & 0x00800000) Const |= 0xff000000; else Const &= 0x00ffffff; break;
                    case 4: if (Const & 0x80000080) Const |= 0x00000000; else Const &= 0xffffffff; break;
                    default: Error0("Casting signed constant from an unsupported size.\n","");
                }
            }
        }
    }
    switch (SzNew) {
        case 1: Const &= 0x000000ff; break;
        case 2: Const &= 0x0000ffff; break;
        case 3: Const &= 0x00ffffff; break;
        case 4: Const &= 0xffffffff; break;
        default: Error0("Casting constant to an unsupported size.\n","");
    }
    return Const;
}

LpExprNode MakeCastNode(LpDeclSpec Type, LpExprNode Node) {
    LpExprNode New;
    if (Node->Usage == uConst) {
        Node->Use.Const.Integer = TypeConvert(Type, Node->Type, Node->Use.Const.Integer);
        Node->Type = Type;
        return Node;
    } else {
        New = NewExprNode(uCast);
        New->Type = Type;
        New->Use.Cast.pTarget = Node;
        return New;
    }
 }


LpExprNode MakeInitNode(LpExprNode pNode) {
    LpExprNode pNew;
    pNew = NewExprNode(uInit);
    pNew->Use.Init.Assignment = pNode;
    pNew->Use.Init.Sibling    = NULL;
    pNew->Use.Init.Children   = NULL;
    return pNew;
}

LpExprNode MakeInitList(LpExprNode pNode) {
    LpExprNode pNew;
    pNew = NewExprNode(uInit);
    pNew->Use.Init.Assignment = NULL;
    pNew->Use.Init.Sibling    = NULL;
    pNew->Use.Init.Children   = pNode;
    return pNew;
}

LpExprNode MakeInitConcat(LpExprNode Node, LpExprNode Brother) {
    LpExprNode n;
    for (n=Node; n->Use.Init.Sibling; n=n->Use.Init.Sibling);
    n->Use.Init.Sibling = Brother;
    return Node;
}

#ifdef _DEBUG
void PrintNode(LpExprNode n) {
    switch (n->Usage) {
        case uConst:printf("%lx ",  n->Use.Const.Integer);
                    break;
        case uVar:  printf("<%s> ",  n->Use.Var.Identifier);
                    break;
        default:    printf("Other ");
                    break;
    }
}

void PrintInit(LpExprNode n) {
    while (n) {
        if (n->Usage != uInit) printf("PrintInit: What !\n");
        if (n->Use.Init.Assignment) {
            PrintNode(n->Use.Init.Assignment);
        }
        if (n->Use.Init.Children) {
            printf("{ ");
            PrintInit(n->Use.Init.Children);
            printf("} ");
        }
        n=n->Use.Init.Sibling;
    }
}
#endif // _DEBUG


/* ****************************************************************** */

DWORD
ConstInt(LpExprNode E) {
    if (E->Usage != uConst) {
        Error0("Initializer must be a Constant value.","");
        return 0L;
    }
    return E->Use.Const.Integer;
 }


/* ****************************************************************** */


void
CleanUp(LpExprNode n) {
    if (!n) {
        printf("Cleanup: Null\n");
        return;
    }
    switch (n->Usage) {
        case    uConst:
        case    uVar:       break;
        case    uUnary:     CleanUp(n->Use.Unary.Operand);
                            break;
        case    uBinary:    CleanUp(n->Use.Binary.Left);
                            CleanUp(n->Use.Binary.Right);
                            break;
        case    uTernary:   CleanUp(n->Use.Ternary.First);
                            CleanUp(n->Use.Ternary.Second);
                            CleanUp(n->Use.Ternary.Third);
                            break;
        default:            printf("CleanUp: More to clean ! [%d]\n", n->Usage);
                            break;
    }
    Dispose(n);
}

/* *************************************************** */



/* *************************************************** */


#ifdef _DEBUG

char *Uops[] = {  "-u",  "+u",  "~u",    "u++",  "++u",
                  "u--", "--u", "sizeof","addr", "ptr", "!u" };

char *Bops[] = {  "+b",  "-b",  "*b",    "/b",   "%b",
                  "&b",  "|b",  "^b",    "==b",  "!=b",
                  "<b",  "<=b", ">b",    ">=b",  "&&b",
                  "||b", ">>b", "<<b" };

void
PrintPack(int depth) {
    while (depth--) printf(".  ");
}

void
PrintType(LpExprNode n) {
    printf(" ==> ");
    ParseDeclSpec(n->Type,FALSE);
 }

void
ParseExpr(LpExprNode n,int depth) {
    if (!n) {
        printf("..Null\n");
        return;
    }
    
    switch (n->Usage) {
        case    uConst:     PrintPack(depth);
                            printf("%ld",    n->Use.Const.Integer);
                            PrintType(n);
                            break;
        case    uVar:       PrintPack(depth);
                            printf("[%s]",  n->Use.Var.Identifier);
                            PrintType(n);
                            break;
        case    uUnary:     PrintPack(depth);
                            printf("%s", Uops[n->Use.Unary.Op]);
                            PrintType(n);
                            ParseExpr(n->Use.Unary.Operand,depth+1);
                            break;
        case    uBinary:    ParseExpr(n->Use.Binary.Left, depth+1);
                            PrintPack(depth);
                            printf("%s", Bops[n->Use.Unary.Op]);
                            PrintType(n);
                            ParseExpr(n->Use.Binary.Right,depth+1);
                            break;
        case    uTernary:   PrintPack(depth);
                            printf("Tern");
                            PrintType(n);
                            ParseExpr(n->Use.Ternary.First, depth+1);
                            PrintPack(depth);
                            printf("Then\n");
                            ParseExpr(n->Use.Ternary.Second, depth+1);
                            PrintPack(depth);
                            printf("Else\n");
                            ParseExpr(n->Use.Ternary.Third, depth+1);
                            break;
        case    uDot:       ParseExpr(n->Use.Dot.Record, depth+1);
                            PrintPack(depth);
                            printf("Dot");
                            PrintType(n);
                            PrintPack(depth);
                            printf("[%s]\n",n->Use.Dot.Field);
                            break;
        case    uArrow:     ParseExpr(n->Use.Arrow.Record, depth+1);
                            PrintPack(depth);
                            printf("Arrow");
                            PrintType(n);
                            PrintPack(depth);
                            printf("[%s]\n",n->Use.Arrow.Field);
                            break;
        case    uArray:     ParseExpr(n->Use.Array.Vector, depth+1);
                            PrintPack(depth);
                            printf("Array");
                            PrintType(n);
                            ParseExpr(n->Use.Array.Index, depth+1);
                            break;
        case    uFunc:      ParseExpr(n->Use.Func.Func, depth+1);
                            PrintPack(depth);
                            printf("Function");
                            PrintType(n);
                            ParseExpr(n->Use.Func.Params, depth+1);
                            break;
        case    uCast:      PrintPack(depth);
                            printf("Cast");
                            PrintType(n);
                            ParseExpr(n->Use.Cast.pTarget, depth+1);
                            break;
        default:            printf("ParseExpr: What [%d]\n", n->Usage);
                            break;
    }
}
#endif // _DEBUG

/* eof */

