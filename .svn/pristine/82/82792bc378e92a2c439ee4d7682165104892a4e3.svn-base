// # ---------------------------------------------------------------------------------------------
// #  $URL$
// # ---------------------------------------------------------------------------------------------
// #  File:                  $Id$
// #  Last committed:  $Revision$
// # ---------------------------------------------------------------------------------------------

#include <conio.h>
#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <setjmp.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <Windows.h>

//#include <ext\types.h>
#include "Utilities\Console.h"

#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "Initializers.h"
#include "Statements.h"
#include "main.h"
#include "C_Yacced.tab.h"

/* *********************************************** */

/* *********************************************** */

/********************/
/* ENUM descriptors */
/********************/

TPEnumSet   Enums = NULL;

static BOOL
FindEnum(TPEnumElement El, LPSTR Name) {
    for (;El;El=El->pNext) {
        if (!strcmp(El->pszElementName, Name)) return TRUE;
    }
    return FALSE;
 }
    

TPEnumElement EnumElementFind(LPSTR pszName) {
    TPEnumSet       Set;
    TPEnumElement   El;
    for (Set=Enums; Set; Set=Set->pNext)
        for (El=Set->pElements; El; El=El->pNext)
            if (!strcmp(El->pszElementName, pszName))
                return El;
    return NULL;
 }
 
static BOOL
EnumDuplicate(LPSTR Name) {
    return (EnumElementFind(Name)) ? TRUE : FALSE;
 }

TPEnumElement EnumElementMake(LPSTR pszName, TPExprNode pExpr) {
    TPEnumElement NewEl;
    if (EnumDuplicate(pszName)) {
        Error(ERROR1, "Duplicate Enumeration Constant '%s'.", pszName);
    }
    NewEl = New(sizeof(TEnumElement));
    NewEl->pszElementName  = pszName;
    NewEl->fAssigned     = FALSE;
    if (pExpr) {
        NewEl->fAssigned = TRUE;
        NewEl->dwValue    = ExprConstInt(pExpr);
    }
    NewEl->pNext         = NULL;
    return NewEl;
 }


TPEnumElement EnumElementAdd(TPEnumElement pList, TPEnumElement pNew) {
    TPEnumElement Old = pList;
    if (FindEnum(pList, pNew->pszElementName)) {
        Error(ERROR1, "Repeated Enumeration Constant '%s'.", pNew->pszElementName);
    }
    if (!pList) {
        if (!pNew->fAssigned) pNew->dwValue = 0;
        return pNew;
    }
    for (;Old->pNext;Old = Old->pNext);
    Old->pNext = pNew;
    if (!pNew->fAssigned) pNew->dwValue = 1+Old->dwValue;
    pNew->pNext = NULL;
    return pList;
 }


#ifdef _DEBUG
void EnumElementPrintList(TPEnumElement pEl) {
    printf("[ ");
    for (;pEl;pEl=pEl->pNext) {
        printf("%s=%d%c ", pEl->pszElementName, pEl->dwValue, (pEl->pNext)?',':' ');
    }
    printf("] ");
 }
#endif //_DEBUG

TPEnumSet
FindEnumSet(LPSTR Name) {
    TPEnumSet Set=Enums;
    if (!strcmp(Name,"")) return NULL;                          // always fail with anonimous Set
    for (;(Set && strcmp(Name,Set->pszSetName)); Set=Set->pNext) ;  // try find others
    return Set;
 }

TPEnumSet EnumSetAdd(LPSTR szName, TPEnumElement pElements) {
    TPEnumSet NewSet;
    if ((NewSet = FindEnumSet(szName)) == NULL) {                 // non existant so make new one
        NewSet = New(sizeof(TEnumSet));
        NewSet->pszSetName  = szName;
        NewSet->pElements = pElements;
        NewSet->pNext     = Enums;
        Enums = NewSet;
    } else {
        if (NewSet->pElements == NULL) {                         // first definition after a forward referance
            NewSet->pElements = pElements;
        } else {
            if (pElements != NULL) {                             // Attempted redefinition
                Error(ERROR0, "Redefinition of Enumerated Set '%s'.",szName);
            } else {
                ;                                               // backwards reference. OK ... do nowt
            }
                
        }
    }
    return NewSet;
 }

#ifdef _DEBUG

void EnumSetPrint(int iDepth, TPEnumSet pSet) {
    printf("Enum\t'%s'\t", pSet->pszSetName);
    EnumElementPrintList(pSet->pElements);
}

void EnumSetPrintList(int iDepth) {
    TPEnumSet Set=Enums;
    printf("EMUMS\n");
    for (;Set; Set=Set->pNext) {
        EnumSetPrint(iDepth+1, Set);
        printf("\n");
    }
    printf("\n");

}
#endif // _DEBUG

/****************************/
/* STRUCT/UNION descriptors */
/****************************/

TPStructSet Structs = NULL;

TPStructSet
FindStructSet(LPSTR Name) {
    TPStructSet Set=Structs;
    if (!strcmp(Name,"")) return NULL;                          // always fail with anonimous Set
    for (;(Set && strcmp(Name,Set->szSetName)); Set=Set->pNext) ;  // try find others
    return Set;
}

TPStructSet
AddStructSet(LPSTR Name, BOOL Union, TPDeclSpec Elements) {
    TPStructSet NewSet;
    if ((NewSet = FindStructSet(Name)) == NULL) {               // non existant so make new one
        NewSet = New(sizeof(TStructSet));
        NewSet->szSetName  = Name;
        NewSet->fUnion    = Union;
        NewSet->pElements = Elements;
        NewSet->pNext     = Structs;
        Structs          = NewSet;
    } else {
        if ((NewSet->fUnion == Union) &&
            (NewSet->pElements == NULL)) {                       // first definition after a forward reference
            NewSet->pElements = Elements;
        } else {
            if (Elements != NULL) {                             // Attempted redefinition
                Error(ERROR0, "Redefinition of Struct/Union '%s'",Name);
            } else {
                ;                                               // backwards reference. OK ... do nowt
            }
                
        }
    }
    return NewSet;
}


#ifdef _DEBUG

static void
PrintStructSet(int iDepth, TPStructSet Set, BOOL Expand) {
    if (Set->fUnion) printf("Union\t");
    else            printf("Struct\t");
    printf("'%s'", Set->szSetName);
    if (Expand) {
        printf("\t{\n");
        ParseDeclSpec(iDepth+1, Set->pElements, TRUE);
        printf("}");
    }
}


void PrintStructSets(int iDepth) {
    TPStructSet Set = Structs;
    printf("STRUCTS\n");
    for (;Set;Set=Set->pNext) {
        PrintStructSet(iDepth+1, Set,TRUE);
        printf("\n");
    }
    printf("\n");
}

#endif // _DEBUG



/* ******************************************************* */
/*  General Type Housekeeping  */
/* *************************** */

static TPDeclSpec
NewDeclSpec(TUsage Use) {
    TPDeclSpec NewEl;
    NewEl = New(sizeof(TDeclSpec));
    NewEl->Usage = Use;
    NewEl->pChain = NULL;
    return NewEl;
 }


static TPDeclSpec
NewSpecBlank(TUsage Use) {
    TPDeclSpec NewEl;
    NewEl = NewDeclSpec(Use);
    switch (Use) {
        case DecSpec:   NewEl->Use.DecSpec.Class  = 0;
                        NewEl->Use.DecSpec.Type   = 0;
                        NewEl->Use.DecSpec.Qual   = 0;
                        NewEl->Use.DecSpec.pPtr    = NULL;
                        break;
        default:        Error(FATAL, "NewSpecBlank: %d is unknown !\n",(int)Use);
                        break;
    }
    return NewEl;
 }

/* ******************************************************* */
/*  Basic Types  */
/* ************* */

static WORD
DeclClass( WORD Set, WORD Element) {
    if (Set && (Set != Element))
        Error(WARNING0, "More than one storage class specified");
    else
        Set |= Element;
    return Set;
 }




static WORD
DeclType(WORD Set, WORD Element) {
    if (((Element == TypeVOID)    && (Set & (         TypeCHAR|TypeINT|TypeFLOAT|TypeDOUBLE|TypeSIGNED|TypeUNSIGNED|TypeSHORT|TypeLONG))) ||
        ((Element == TypeCHAR)    && (Set & (TypeVOID|         TypeINT|TypeFLOAT|TypeDOUBLE                                           ))) ||
        ((Element == TypeINT)     && (Set & (TypeVOID|TypeCHAR|        TypeFLOAT|TypeDOUBLE                                           ))) ||
        ((Element == TypeFLOAT)   && (Set & (TypeVOID|TypeCHAR|TypeINT|          TypeDOUBLE|TypeSIGNED|TypeUNSIGNED|TypeSHORT|TypeLONG))) ||
        ((Element == TypeDOUBLE)  && (Set & (TypeVOID|TypeCHAR|TypeINT|TypeFLOAT|           TypeSIGNED|TypeUNSIGNED|TypeSHORT         ))) ||
        ((Element == TypeSHORT)   && (Set & (TypeVOID|TypeCHAR|        TypeFLOAT|TypeDOUBLE|                                  TypeLONG))) ||
        ((Element == TypeLONG)    && (Set & (TypeVOID|TypeCHAR|        TypeFLOAT|                                   TypeSHORT         ))) ||
        ((Element == TypeSIGNED)  && (Set & (TypeVOID|                 TypeFLOAT|TypeDOUBLE|           TypeUNSIGNED                   ))) ||
        ((Element == TypeUNSIGNED)&& (Set & (TypeVOID|                 TypeFLOAT|TypeDOUBLE|TypeSIGNED                                ))) ||
        ((Element == TypeENUM)    && (Set & (TypeVOID|TypeCHAR|TypeINT|TypeFLOAT|TypeDOUBLE|TypeSIGNED|TypeUNSIGNED|TypeSHORT|TypeLONG))) ||
        ((Element == TypeSTRUCT)  && (Set & (TypeVOID|TypeCHAR|TypeINT|TypeFLOAT|TypeDOUBLE|TypeSIGNED|TypeUNSIGNED|TypeSHORT|TypeLONG))) ||
        ((Element == TypeTYPEDEF) && (Set & (TypeVOID|TypeCHAR|TypeINT|TypeFLOAT|TypeDOUBLE|TypeSIGNED|TypeUNSIGNED|TypeSHORT|TypeLONG))))
            Error(WARNING0, "Type declaration contains contradictory properties");
    else Set |= Element;
    return Set;
 }

static WORD
DeclQual(WORD Set, WORD Element) {
    if ((Set == 0) || (Set == Element)) return Element;
    Error(WARNING0, "Type Qualification contains contradictory properties");
    return Set;
 }

static LPVOID
DeclPtr(LPVOID Set, LPVOID Element) {
    if (Set == 0) return Element;
    Error(WARNING0, "Complex Type Qualification contains contradictory properties");
    return Set;
 }

TPDeclSpec
NewSpecClass(WORD Class) {
    TPDeclSpec NewEl = NewSpecBlank(DecSpec);
    NewEl->Use.DecSpec.Class = Class;
    return NewEl;
 }  
 
TPDeclSpec
NewSpecType(WORD Type, LPVOID Ptr) {
    TPDeclSpec NewEl = NewSpecBlank(DecSpec);
    NewEl->Use.DecSpec.Type = Type;
    NewEl->Use.DecSpec.pPtr  = Ptr;
    return NewEl;
 }

TPDeclSpec
NewSpecQual(WORD Qual) {
    TPDeclSpec NewEl = NewSpecBlank(DecSpec);
    NewEl->Use.DecSpec.Qual = Qual;
    return NewEl;
 }

static TPDeclSpec FindTarget(TPDeclSpec Ptr) {
    while (Ptr) {
        switch (Ptr->Usage) {
            case DecId:
                 Ptr = Ptr->Use.DecId.pTarget;
                 break;
            case DecSpec:
                 return Ptr;
            case DecPtr:
                 Ptr = Ptr->Use.DecPtr.pTarget;
                 break;
            case DecArray:
                 Ptr = Ptr->Use.DecArray.pTarget;
                 break;
            case DecFunc:
                 Ptr = Ptr->Use.DecFunc.pReturnType;
                 break;
            default:
                Error(FATAL,"FindTarget: Unknown Use [%02x]\n", Ptr->Usage);
                return Ptr;
        }
    }
    ASSERT(FALSE);
    return 0;
 }


TPDeclSpec
ConcatDeclSpec(TPDeclSpec Old, TPDeclSpec New) {
    TPDeclSpec O=FindTarget(Old);
    TPDeclSpec N=FindTarget(New);
    if (O->Usage != DecSpec) Error(FATAL, "ConcatDeclSpec: What 1!\n");
    if (N->Usage != DecSpec) Error(FATAL, "ConcatDeclSpec: What 2!\n");
    if (N->Use.DecSpec.Class)
        O->Use.DecSpec.Class = DeclClass(O->Use.DecSpec.Class,N->Use.DecSpec.Class); 
    if (N->Use.DecSpec.Type)
        O->Use.DecSpec.Type  = DeclType( O->Use.DecSpec.Type, N->Use.DecSpec.Type);
    if (N->Use.DecSpec.Qual)
        O->Use.DecSpec.Qual  = DeclQual( O->Use.DecSpec.Qual, N->Use.DecSpec.Qual); 
    if (N->Use.DecSpec.pPtr)
        O->Use.DecSpec.pPtr   = DeclPtr(  O->Use.DecSpec.pPtr,  N->Use.DecSpec.pPtr); 
    return Old;
 }

/* ******************************************** */

TPDeclSpec
NewPointer(TPDeclSpec Qualifier, TPDeclSpec Target) {
    WORD       q;
    if (!Qualifier) Qualifier = NewSpecQual(0);
    q = Qualifier->Use.DecSpec.Qual;
    Qualifier->Usage = DecPtr;                      // recycle as pointer
    Qualifier->Use.DecPtr.pTarget = Target;         // recycle as pointer
    Qualifier->Use.DecPtr.Qual   = q;               // recycle as pointer
    return Qualifier;
 }

TPDeclSpec
NewIdentifier(LPSTR Name) {
    TPDeclSpec N;
    N = NewDeclSpec(DecId);
    N->Use.DecId.pszName = Name;
    N->Use.DecId.pTarget = NULL;
    N->Use.DecId.pszInitializedStr = NULL;
    N->Use.DecId.pInitializer = NULL;
    N->Use.DecId.pBrother = NULL;
    N->Use.DecId.UsedFlags = 0;
    return N;
 }

TPDeclSpec NewArray(TPDeclSpec Dec, TPExprNode Expr) {
    TPDeclSpec N;
    N = NewDeclSpec(DecArray);
    if (Expr) {
        if (Expr->Usage != uConst) {
            //ParseExpr(Expr, 0);
            Error(ERROR0, "Constant required for Array Dimensions.");
            N->Use.DecArray.Size = 0;
        } else {
            N->Use.DecArray.Size = ExprConstInt(Expr);
            if ((long)N->Use.DecArray.Size < 0) {
                Error(ERROR0, "Array dimension = %ld. Must be >= 0.", N->Use.DecArray.Size);
                N->Use.DecArray.Size = 0;
            }
        }
    } else {
            N->Use.DecArray.Size = 0;
    }
    N->Use.DecArray.pTarget = NULL;
    return AppendDecl(Dec,N);
 }

TPDeclSpec DeclNewFunc(TPDeclSpec Dec, TPDeclSpec PList, TPDeclSpec IdList) {
    TPDeclSpec N;
    N = NewDeclSpec(DecFunc);
    if (PList != NULL) {
        N->Use.DecFunc.pPList = PList;
        // DeclareParameters(PList);
    }
    N->Use.DecFunc.pIdList = IdList;
    N->Use.DecFunc.pReturnType = NULL;
    return AppendDecl(Dec, N);
}

void FuncParams(TPDeclSpec pFunc) {                     // make the parameters from the parameter.
    ASSERT(pFunc                    && pFunc->Usage == DecId);
    ASSERT(pFunc->Use.DecId.pTarget && pFunc->Use.DecId.pTarget->Usage == DecFunc);
    DeclareParameters(pFunc->Use.DecId.pTarget->Use.DecFunc.pPList);
}

TPDeclSpec  FunctionBody(TPDeclSpec pType, TPDeclSpec pFunc, TPDeclSpec pIdList, TPStatement pBody) {
    
    ASSERT(pFunc->Usage == DecId && pFunc->Use.DecId.pTarget->Usage == DecFunc);
    
    AppendDecl(pFunc->Use.DecId.pTarget, pType);
    pFunc->Use.DecId.pTarget->Use.DecFunc.pIdList = pIdList;
    pFunc->Use.DecId.pTarget->Use.DecFunc.pBody = pBody;

    UndeclareParameters(pFunc->Use.DecId.pTarget->Use.DecFunc.pPList);

    if (pIdList != NULL) {
        Error(ERROR0, "K&R 'C' parameters are not supported yet. See source function '%s'", pFunc->Use.DecId.pszName);
        // pIdList is same list structure (ie id.boother-> id->brother-> etc.)
        // not simple as the param names may be in a different order 
    }

    return pFunc;

}



TPDeclSpec AddInitializerStr(TPDeclSpec pDec, LPSTR pStr) {         // these are our pseudo variables used when anonomous strings are defined.
    if (pDec->Usage != DecId) {
        Error(FATAL, "AddInitializerStr(): Error1\n");
        return pDec;
    }
    pDec->Use.DecId.pszInitializedStr = pStr;
    //PrintInit(pStr); printf("\n");
    return pDec;
}


TPDeclSpec  AddInitializer(TPDeclSpec pDec, TPExprNode pInit) {
    if (pDec->Usage != DecId) {
        Error(FATAL, "AddInitializer(): Error1\n");
        return pDec;
    }
    pDec->Use.DecId.pInitializer = pInit;
    //PrintInit(pInit); printf("\n");
    return pDec;
 }


/*
TPDeclSpec DeclVarAddType(TPDeclSpec pIdList, TPDeclSpec pSpec) {           // Add type to all the variables in a list.
    ASSERT(pIdList && pIdList->Usage == DecId);
    ASSERT(pSpec && pSpec->Usage == DecSpec);

    TPDeclSpec pD = pIdList;
    
    while (pD != NULL) {
        ASSERT(pD && pD->Usage == DecId);
        pD->Use.DecId.pTarget = pSpec;
        pD = pD->Use.DecId.pBrother;
    }
    return pIdList;
}
*/

TPDeclSpec DeclVarAddBrother(TPDeclSpec pA, TPDeclSpec pB) {                // Add a variable to the list of variables.
    ASSERT(pA && pA->Usage == DecId);
    ASSERT(pB && pB->Usage == DecId);

    TPDeclSpec pD = pA;
    while (pD->Use.DecId.pBrother != NULL) {
        pD = pD->Use.DecId.pBrother;
        ASSERT(pD && pD->Usage == DecId);
    }
    pD->Use.DecId.pBrother = pB;
    return pD;
}


TPDeclSpec
AppendDecl(TPDeclSpec a,TPDeclSpec b) {
    TPDeclSpec c = a;
    if (!c) return b;
    for (;;) {
        switch (c->Usage) {
            case    DecId:
                    if (c->Use.DecId.pBrother) {
                        // this adds a the same pTarget to each of a list of brothers.
                        AppendDecl(c->Use.DecId.pBrother, b);     // who calls and when. could it be simplified?          
                    }
                    if (c->Use.DecId.pTarget) {
                        c = c->Use.DecId.pTarget;
                        break;
                    }  else {
                        c->Use.DecId.pTarget = b;
                        return a;
                    }
                    break;
            case    DecSpec:
                    Error(FATAL, "AppendDecl: Trouble append to Spec\n");
                    return a;
            case    DecPtr:
                    if (c->Use.DecPtr.pTarget) {
                        c = c->Use.DecPtr.pTarget;
                        break;
                    }  else {
                        c->Use.DecPtr.pTarget = b;
                        return a;
                    }
                    break;
            case    DecArray:
                    if (c->Use.DecArray.pTarget) {
                        c = c->Use.DecArray.pTarget;
                        break;
                    }  else {
                        c->Use.DecArray.pTarget = b;
                        return a;
                    }
                    break;
            case    DecFunc:
                    if (c->Use.DecFunc.pReturnType) {
                        c = c->Use.DecFunc.pReturnType;
                        break;
                    }  else {
                        c->Use.DecFunc.pReturnType = b;
                        return a;
                    }
                    break;
            default:
                Error(FATAL, "AppendDecl: Unknown Use\n");
                    break;
        }
    }
 }

TPDeclSpec MakeBrother(TPDeclSpec a,TPDeclSpec b) {
    TPDeclSpec c;
    if (a->Usage != DecId || b->Usage != DecId) {
        Error(FATAL, "MakeBrother: Error1\n");
        return a;
    }
    for (c=a; c->Use.DecId.pBrother != NULL; c=c->Use.DecId.pBrother);
    c->Use.DecId.pBrother=b;
    return a;
 }



#ifdef _DEBUG
 
#define putch(x) putc((x),stdout) 
 
static void
DescClass(WORD q) {
    ConsolePrintf(CON_GREEN, "Class[");
    ConsolePrintf(CON_GREEN, (q & ClassAUTO)       ? "A":"_");
    ConsolePrintf(CON_GREEN, (q & ClassREGISTER)   ? "R":"_");
    ConsolePrintf(CON_GREEN, (q & ClassSTATIC)     ? "S":"_");
    ConsolePrintf(CON_GREEN, (q & ClassEXTERN)     ? "E":"_");
    ConsolePrintf(CON_GREEN, (q & ClassTYPEDEF)    ? "T":"_");
    ConsolePrintf(CON_GREEN, "]");
}

static void
DescType(WORD q) {
    ConsolePrintf(CON_GREEN, "type[");
    if(q & TypeUNSIGNED) ConsolePrintf(CON_GREEN, "unsigned ");
    if(q & TypeSIGNED)   ConsolePrintf(CON_GREEN, "signed ");
    if(q & TypeDOUBLE)   ConsolePrintf(CON_GREEN, "double ");
    if(q & TypeFLOAT)    ConsolePrintf(CON_GREEN, "float ");
    if(q & TypeLONG)     ConsolePrintf(CON_GREEN, "long ");
    if(q & TypeINT)      ConsolePrintf(CON_GREEN, "int ");
    if(q & TypeSHORT)    ConsolePrintf(CON_GREEN, "short ");
    if(q & TypeCHAR)     ConsolePrintf(CON_GREEN, "char ");
    if(q & TypeVOID)     ConsolePrintf(CON_GREEN, "void ");
    ConsolePrintf(CON_GREEN, "]");
}

static void
DescQual(WORD q) {
    ConsolePrintf(CON_GREEN, "Qual[");
    ConsolePrintf(CON_GREEN, (q & QualCONST)   ? "C":"_");
    ConsolePrintf(CON_GREEN, (q & QualVOLATILE)? "V":"_");
    ConsolePrintf(CON_GREEN, (q & QualNEAR)    ? "N":"_");
    ConsolePrintf(CON_GREEN, (q & QualFAR)     ? "F":"_");
    ConsolePrintf(CON_GREEN, "]");
}

void ParseDeclSpec(int iDepth, TPDeclSpec pDecl, BOOL fDoBrothers) {
    ConsoleIndent(iDepth);
    if (!pDecl) {
            printf("..Null..\n");
            return;
    } else {
        switch (pDecl->Usage) {
            case    DecId:          // Id
                    ConsolePrintf(CON_YELLOW_BRIGHT, "'%s'", pDecl->Use.DecId.pszName);
                    ConsolePrintf(CON_YELLOW, " clone=%d UsedFlags=0x%02x\n", pDecl->Use.DecId.wClone, pDecl->Use.DecId.UsedFlags);
                    ParseDeclSpec(iDepth+1, pDecl->Use.DecId.pTarget, FALSE);
                    if (pDecl->Use.DecId.pszInitializedStr) {
                        printf("\t\tI = \"%s\"\n", pDecl->Use.DecId.pszInitializedStr);
                    }
                    if (pDecl->Use.DecId.pInitializer) {
                            printf("\t\tI = "); 
                            ExprPrintInit(pDecl->Use.DecId.pInitializer); 
                            printf("\n");
                    }
                    //ParseDeclSpec(pDecl->Use.DecId.pTarget, fDoBrothers);
                    if (fDoBrothers && pDecl->Use.DecId.pBrother) {
                        ParseDeclSpec(iDepth, pDecl->Use.DecId.pBrother, fDoBrothers);
                    }
                    return;
            case    DecSpec:
                    if      ((pDecl->Use.DecSpec.Type) & TypeSTRUCT)  { PrintStructSet(iDepth+1, pDecl->Use.DecSpec.pPtr,FALSE); DescQual(pDecl->Use.DecSpec.Qual); }
                    else if ((pDecl->Use.DecSpec.Type) & TypeENUM)    { EnumSetPrint(iDepth+1, pDecl->Use.DecSpec.pPtr);         DescQual(pDecl->Use.DecSpec.Qual); }
                    else if ((pDecl->Use.DecSpec.Type) & TypeTYPEDEF) { printf("Typedef "); ParseDeclSpec(iDepth+1, pDecl->Use.DecSpec.pPtr,fDoBrothers); }
                    else                                              { DescClass(pDecl->Use.DecSpec.Class); DescType(pDecl->Use.DecSpec.Type); DescQual(pDecl->Use.DecSpec.Qual); }
                    printf("\n");
                    return;
            case    DecPtr:
                    printf("P");  DescQual(pDecl->Use.DecPtr.Qual); printf("-> "); 
                    ParseDeclSpec(iDepth + 1, pDecl->Use.DecPtr.pTarget, fDoBrothers);
                    return;
            case    DecArray:
                    printf("A[%ld]-> ", pDecl->Use.DecArray.Size);
                    ParseDeclSpec(iDepth + 1, pDecl->Use.DecArray.pTarget, fDoBrothers);
                    return;
            case    DecFunc:
                    printf("Function(\n");
                    ParseDeclSpec(iDepth + 1, pDecl->Use.DecFunc.pPList, TRUE);
                    ConsoleIndent(iDepth);
                    printf(")\n");
                    ConsoleIndent(iDepth);
                    printf("Ids(\n");
                    ParseDeclSpec(iDepth + 1, pDecl->Use.DecFunc.pIdList, TRUE);
                    ConsoleIndent(iDepth);
                    printf(")\n");
                    ConsoleIndent(iDepth);
                    printf("returning\n");
                    ParseDeclSpec(iDepth + 1, pDecl->Use.DecFunc.pReturnType, fDoBrothers);
                    StatementPrint(iDepth, pDecl->Use.DecFunc.pBody, TRUE);
                    return;
            default:
                Error(FATAL, "ParseDeclSpec: Unknown Use\n");
                    return;
        }
    }
}


#endif // _DEBUG


/* ***************************************************************** */
/*  Declarations  */
/* ************** */

static TPDeclSpec
DuplicateD(TPDeclSpec Ptr) {
    TPDeclSpec New;
    New = NewDeclSpec(Ptr->Usage);
    *New = *Ptr;
    return New;
 }

static TPDeclSpec
DuplicateDecl(TPDeclSpec Ptr) {
    TPDeclSpec Start,Latest;
    if (!Ptr) return NULL;
    Start = Latest = DuplicateD(Ptr);
    while (Latest) {
        switch (Latest->Usage) {
            case DecId:
                    Latest->Use.DecId.pTarget = DuplicateD(Latest->Use.DecId.pTarget);
                    Latest = Latest->Use.DecId.pTarget;
                    break;
            case DecSpec:
                    return Start;
                    break;
            case DecPtr:
                    Latest->Use.DecPtr.pTarget = DuplicateD(Latest->Use.DecPtr.pTarget);
                    Latest = Latest->Use.DecPtr.pTarget;
                    break;
            case DecArray:
                    Latest->Use.DecArray.pTarget = DuplicateD(Latest->Use.DecArray.pTarget);
                    Latest = Latest->Use.DecArray.pTarget;
                    break;
            case DecFunc:
                    Latest->Use.DecFunc.pReturnType = DuplicateD(Latest->Use.DecFunc.pReturnType);
                    Latest = Latest->Use.DecFunc.pReturnType;
                    break;
            default:
                Error(FATAL, "DuplicateDecl: Unknown Use [%02x]\n", Latest->Usage);
                return 0L;
        }
    }
    ASSERT(FALSE);
    return 0;
}


static BOOL
IsClassProperty(TPDeclSpec Ptr, WORD Property) {
    while (Ptr) {
        switch (Ptr->Usage) {
            case DecId:
                    Ptr = Ptr->Use.DecId.pTarget;
                    break;
            case DecSpec:
                    return (Ptr->Use.DecSpec.Class & Property);
                    break;
            case DecPtr:
                    Ptr = Ptr->Use.DecPtr.pTarget;
                    break;
            case DecArray:
                    Ptr = Ptr->Use.DecArray.pTarget;
                    break;
            case DecFunc:
                    Ptr = Ptr->Use.DecFunc.pReturnType;
                    break;
            default:
                Error(FATAL, "IsClassProperty: Unknown Use [%02x]\n", Ptr->Usage);
                return 0L;
        }
    }
    return FALSE;
 }

#define IsAuto(Ptr)     IsClassProperty(Ptr, ClassAUTO)
#define IsRegister(Ptr) IsClassProperty(Ptr, ClassREGISTER)
#define IsStatic(Ptr)   IsClassProperty(Ptr, ClassSTATIC)
#define IsExtern(Ptr)   IsClassProperty(Ptr, ClassEXTERN)
#define IsTypedef(Ptr)  IsClassProperty(Ptr, ClassTYPEDEF)

static void
StripClassProperty(TPDeclSpec Ptr, WORD Property) {
    while (Ptr) {
        switch (Ptr->Usage) {
            case DecId:
                    Ptr = Ptr->Use.DecId.pTarget;
                    break;
            case DecSpec:
                    Ptr->Use.DecSpec.Class &= ~Property;
                    return;
            case DecPtr:
                    Ptr = Ptr->Use.DecPtr.pTarget;
                    break;
            case DecArray:
                    Ptr = Ptr->Use.DecArray.pTarget;
                    break;
            case DecFunc:
                    Ptr = Ptr->Use.DecFunc.pReturnType;
                    break;
            default:
                Error(FATAL, "StripClassProperty: Unknown Use [%02x]\n", Ptr->Usage);
                return;
        }
    }
    return;
 }

#define StripAuto(Ptr)     StripClassProperty(Ptr, ClassAUTO)
#define StripRegister(Ptr) StripClassProperty(Ptr, ClassREGISTER)
#define StripStatic(Ptr)   StripClassProperty(Ptr, ClassSTATIC)
#define StripExtern(Ptr)   StripClassProperty(Ptr, ClassEXTERN)
#define StripTypedef(Ptr)  StripClassProperty(Ptr, ClassTYPEDEF)

static BOOL CompDeclStruct(TPDeclSpec a, TPDeclSpec b) {   // Compair the type to the base type eg functions, pointers, arrays of a base type.
    while (a && b) {
        if (a->Usage != b->Usage) {
            return FALSE;
        }
        switch (a->Usage) {
            case DecId:
                    a = a->Use.DecId.pTarget;
                    b = b->Use.DecId.pTarget;
                    break;
            case DecSpec:
                    return TRUE;
            case DecPtr:
                    a = a->Use.DecPtr.pTarget;
                    b = b->Use.DecPtr.pTarget;
                    break;
            case DecArray:
                    a = a->Use.DecArray.pTarget;
                    b = b->Use.DecArray.pTarget;
                    break;
            case DecFunc:
                    a = a->Use.DecFunc.pReturnType;
                    b = b->Use.DecFunc.pReturnType;
                    break;
            default:
                Error(FATAL, "CompDeclStruct: Unknown Use [%02x]\n", a->Usage);
                return FALSE;
        }
    }
    ASSERT(FALSE);
    return 0;
 }


BOOL
CompDecl(TPDeclSpec a, TPDeclSpec b) {
    for (;;) {
        if (a->Usage == DecId) {                                         // case DecId
           if (b->Usage != DecId)       return FALSE;
           else {                       a = a->Use.DecId.pTarget;
                                        b = b->Use.DecId.pTarget;
           }
        } else if (a->Usage == DecSpec) {                                // case DecSpec
           if (b->Usage != DecSpec)     return FALSE;
           else { if (a->Use.DecSpec.Type != b->Use.DecSpec.Type)                 return FALSE;
                  if (!(a->Use.DecSpec.Type & (TypeSTRUCT|TypeENUM|TypeTYPEDEF))) return TRUE;
                  if (a->Use.DecSpec.pPtr == b->Use.DecSpec.pPtr)                 return TRUE;
                  return FALSE;
           }
        } else if (a->Usage == DecPtr) {                                 // case DecPtr
           a = a->Use.DecPtr.pTarget;
           if (b->Usage == DecArray)    b = b->Use.DecArray.pTarget;
           else if (b->Usage == DecPtr) b = b->Use.DecPtr.pTarget;
           else                         return FALSE;
        } else if (a->Usage == DecArray) {                               // case DecArray
           a = a->Use.DecArray.pTarget;
           if (b->Usage == DecArray)    b = b->Use.DecArray.pTarget;
           else if (b->Usage == DecPtr) b = b->Use.DecPtr.pTarget;
           else                         return FALSE;
        } else if (a->Usage == DecFunc) {                                // case DecFunc
                                        a = a->Use.DecFunc.pReturnType;
                                        b = b->Use.DecFunc.pReturnType;
        } else {
            Error(FATAL, "CompDecl: Unknown Use [%02x]\n", a->Usage);
            return FALSE;
        }
    }
 }



static BOOL
TestParams(TPDeclSpec a, TPDeclSpec b) {
    ASSERT(a->Usage == DecFunc && b->Usage == DecFunc);
    TPDeclSpec p1 = a->Use.DecFunc.pPList;                   // a param 1
    TPDeclSpec p2 = b->Use.DecFunc.pPList;                   // b param 1
    if (p1 == NULL) {                                       // Empty ? ... fill it
            a->Use.DecFunc.pPList  = p2;
            return TRUE;
    }
    if (p2 == NULL) {
            b->Use.DecFunc.pPList  = p1;
            return TRUE;
    }
    while (p1 && p2) {
        ASSERT(p1->Usage == DecId && p2->Usage == DecId);
        if (!strcmp(p1->Use.DecId.pszName,"...")) {            // Ellipsis ? ... fill it
            *p1 = *p2;
            return TRUE;
        }
        if (!strcmp(p2->Use.DecId.pszName,"...")) {
            *p2 = *p1;
            return TRUE;
        }
        if (!CompDecl(p1, p2)) {                            // Different ?
            return FALSE;                                   // Scrap it !
        }
        //if (strlen(p1->Use.DecId.pszName) == 0) {
        //    p1->Use.DecId.pszName = _strdup(p2->Use.DecId.pszName);
        //}
        p1 = p1->Use.DecId.pBrother;
        p2 = p2->Use.DecId.pBrother;
    }
    return ((p1 == NULL) && (p2 == NULL));
 }



/* *************************************************** */

TPDeclSpec  GlobalTypes;
//TPDeclSpec  LocalTypes;
TPDeclSpec  GlobalObjects;
TPDeclSpec  ParameterObjects;
TPDeclSpec  LObjects;

static TPDeclSpec
FindDecl(TPDeclSpec List, LPSTR Name) {
for (;
(List != NULL && strcmp(List->Use.DecId.pszName, Name));
List = List->pChain);
return List;
 }

 TPDeclSpec
     FindType(LPSTR Name) {
     TPDeclSpec L = NULL;
     //L = FindDecl(LObjects, Name);
     //if (!L) L = FindDecl(ParameterObjects, Name);
     if (!L) L = FindDecl(GlobalTypes, Name);
     if (L)  StripTypedef(L);
     return DuplicateDecl(L);
 }

 TPDeclSpec
     FindGlobalObject(LPSTR Name) {
     return FindDecl(GlobalObjects, Name);
 }

 TPDeclSpec  FindParameterObject(LPSTR Name) {
     return FindDecl(ParameterObjects, Name);
 }

 TPDeclSpec  FindLocalObject(LPSTR Name) {
     return FindDecl(LObjects, Name);
 }


 TPDeclSpec AddToDefintionList(TPDeclSpec List, TPDeclSpec Element) {
     TPDeclSpec L;                                                                       // list pointer
     TPDeclSpec pKnown, pNew;                                                             // known= serach-point and new from element
     Element->pChain = NULL;
     if (List == NULL) return Element;
     for (L = List; L->pChain != NULL; L = L->pChain) {
         if (!strcmp(L->Use.DecId.pszName, Element->Use.DecId.pszName)) {
             break;
         }
     }
     if (!strcmp(L->Use.DecId.pszName, Element->Use.DecId.pszName)) {
         // redefinition.
         // Permit removal of extern flag
         // keep quite if identical and extern
         L->Use.DecId.wClone++;
         if (CompDeclStruct(L, Element)) {                                                    // do we have the same type  ? Could we use use CompDecl and skip the type/qualifier tests below?
             pKnown = FindTarget(L);
             pNew = FindTarget(Element);
             ASSERT((pKnown->Usage == DecSpec) && (pNew->Usage == DecSpec));
             if ((pKnown->Use.DecSpec.Type != pNew->Use.DecSpec.Type) ||                                                                                 // not the same type
                 (pKnown->Use.DecSpec.Qual != pNew->Use.DecSpec.Qual) ||                                                                                 // not the same qualifiers
                 (((pKnown->Use.DecSpec.Type & (TypeSTRUCT | TypeENUM | TypeTYPEDEF)) != 0) && (pKnown->Use.DecSpec.pPtr != pNew->Use.DecSpec.pPtr))) {  // complicated type and different
                 Error(WARNING1, "Ignoring the redefiniton of type of '%s'.", Element->Use.DecId.pszName);                                               //      error
                 return List;                                                                                                                            //      return the existing list
             }

             // assert names and types match
             ASSERT((L->Usage == DecId) && (Element->Usage == DecId));
             if (Element->Use.DecId.pTarget->Usage == DecFunc) {                                                 // functions need extra attection.
                 TPDeclSpec KnownFunc = L->Use.DecId.pTarget;                                                    //
                 TPDeclSpec NewFunc = Element->Use.DecId.pTarget;                                                //
                 if (!TestParams(KnownFunc, NewFunc)) {                                                          // Complain if the parameters change types.
                     Error(WARNING1, "Redefiniton of function '%s' parameters.", Element->Use.DecId.pszName);    //   
                     //return List;                                                                              // 
                 }
                 if (KnownFunc->Use.DecFunc.pBody && NewFunc->Use.DecFunc.pBody) {                               // old and new can't both have statement lists
                     Error(WARNING1, "Redefiniton of function '%s' body.", Element->Use.DecId.pszName);          //
                     return List;                                                                                //
                 }
                 if (NewFunc->Use.DecFunc.pBody != NULL) {                                                       // if New has a body then inherit what ever new's definition says (incl new types).
                     TDeclSpec Tmp;                                                                              // Swapping contents 
                     NewFunc->pChain = KnownFunc->pChain;                                                        // This means whoever points at the old stuff will now point to the new stuff.
                     Tmp = *KnownFunc;                                                                           // 
                     *KnownFunc = *NewFunc;                                                                      // 
                     *NewFunc = Tmp;                                                                             // 
                 }
             }
             if ((pKnown->Use.DecSpec.Class == ClassEXTERN) ||                                                   // If there is an extern 
                 (pNew->Use.DecSpec.Class == ClassEXTERN)) {                                                     //
                 pKnown->Use.DecSpec.Class &= pNew->Use.DecSpec.Class;                                       // new is only extern if both were
             }
             return List;
         }
         Error(WARNING0, "Ignoring the redefiniion of '%s'.", Element->Use.DecId.pszName);
     }
     else {
         L->pChain = Element;
     }
     return List;
 }


 TPDeclSpec RemoveFromDefintionList(TPDeclSpec List, TPDeclSpec Element) {
     TPDeclSpec *pL;                                                                       // list pointer

     for (pL = &List; *pL != NULL; pL = &(*pL)->pChain) {
         if (strcmp((*pL)->Use.DecId.pszName, Element->Use.DecId.pszName) == 0) {
            if ((*pL)->Use.DecId.wClone == 0) {
                *pL = (*pL)->pChain;
                return List;
            }
            else {
                (*pL)->Use.DecId.wClone--;
            }
        }
    }
    return List;
}



#ifdef _DEBUG
static void ListDefinitions(int iDepth, TPDeclSpec pList) {
    for (;pList; pList = pList->pChain) {
        ParseDeclSpec(0, pList, FALSE);
    }
 }

void
ListGlobalTypes(void) {
    printf("Global Types\n");
    ListDefinitions(0, GlobalTypes);
    printf("\n");
}

void
ListGlobalObjects(void) {
    printf("Global Objects\n");
    ListDefinitions(0, GlobalObjects);
    printf("\n");
}

void
ListParameterObjects(void) {
    printf("Parameter Objects\n");
    ListDefinitions(0, ParameterObjects);
    printf("\n");
}

void
ListLocalObjects(void) {
    printf("Local Objects\n");
    ListDefinitions(0, LObjects);
    printf("\n");
}

#endif // _DEBUG

static DWORD    CalcStructSize(TPStructSet Struct);
//static BOOL     IsATypeDef(TPDeclSpec Ptr);





void Declaration(TPDeclSpec pDecl) {
    TPDeclSpec Tmp;

    while (pDecl) {
        if (!pDecl) {
            Error(FATAL, "Declaration: Declare Nothing ?\n");
            return;
        }

        ASSERT(pDecl && pDecl->Usage == DecId);
//      if (pDecl->Usage != DecId) {
//          // printf("Unnamed elements cannot be declared !\n");
//          return;
//      }

        InitializerProcess(pDecl);

        // printf("%s\t", (Ptr->Use.DecId.Initializer) ? "Init":"");
        Tmp = pDecl->Use.DecId.pTarget;
        if (IsTypedef(Tmp)) {
            GlobalTypes = AddToDefintionList(GlobalTypes,pDecl);
        }
        else {
            CalcSizeOf(Tmp);
            GlobalObjects = AddToDefintionList(GlobalObjects, pDecl);
        }
        pDecl = pDecl->Use.DecId.pBrother;

    }
 }

void DeclareParameters(TPDeclSpec pDecl) {
    TPDeclSpec Tmp;

    while (pDecl) {
        if (!pDecl) {
            Error(FATAL, "DeclareParameters(): Declare Nothing ?\n");
            return;
        }

        ASSERT(pDecl && pDecl->Usage == DecId);

        InitializerProcess(pDecl);

        Tmp = pDecl->Use.DecId.pTarget;
        ASSERT(!IsTypedef(Tmp));

        CalcSizeOf(Tmp);
        ParameterObjects = AddToDefintionList(ParameterObjects, pDecl);

        pDecl = pDecl->Use.DecId.pBrother;

    }
}

void UndeclareParameters(TPDeclSpec pDecl) {
    //ListDefinitions(0, pDecl);
    while (pDecl) {
        ASSERT(pDecl && pDecl->Usage == DecId);
        ParameterObjects = RemoveFromDefintionList(ParameterObjects, pDecl);
        pDecl = pDecl->Use.DecId.pBrother;
    }
    //ListDefinitions(0, pDecl);
}


void DeclareLocal(TPDeclSpec pDecl) {
    TPDeclSpec Tmp;

    while (pDecl) {
        if (!pDecl) {
            Error(FATAL, "DeclareLocal(): Declare Nothing ?%d\n");
            return;
        }

        ASSERT(pDecl && pDecl->Usage == DecId);

        InitializerProcess(pDecl);

        Tmp = pDecl->Use.DecId.pTarget;
        ASSERT(!IsTypedef(Tmp));

        CalcSizeOf(Tmp);
        LObjects = AddToDefintionList(LObjects, pDecl);

        pDecl = pDecl->Use.DecId.pBrother;

    }
}


void UndeclareLocal(TPDeclSpec pDecl) {
    while (pDecl) {
        //ListDefinitions(LObjects);
        ASSERT(pDecl && pDecl->Usage == DecId);
        LObjects = RemoveFromDefintionList(LObjects, pDecl);
        pDecl = pDecl->Use.DecId.pBrother;
    }
    //ListDefinitions(LObjects);
}




static WORD
PtrDest(TPDeclSpec Target) {
    while (Target) {
        switch (Target->Usage) {
            case DecPtr:    return Target->Use.DecPtr.Qual;         // where is the pointer ?
            case DecFunc:   return QualCONST;                       // Functions must be in constant
            case DecSpec:   return Target->Use.DecSpec.Qual;        // Where is the base type ?
            case DecArray:  Target = Target->Use.DecArray.pTarget;
                            break;
            default:        Error(FATAL, "PtrDest: Trouble [%d]\n", Target->Usage);
                            return 0;
        }
    }
    Error(FATAL, "PtrDest: Trouble ?\n");
    ASSERT(FALSE);
    return 0;
 }

 
#define TT(P,T) (((P)->Use.DecSpec.Type & (T)) == (T))

DWORD
CalcSizeOf(TPDeclSpec Ptr) {
    if (!Ptr) return 0L;
    switch (Ptr->Usage) {
        case    DecId:          // Id
                Error(FATAL, "CalcSizeOf of DecId '%s' !!!\n",Ptr->Use.DecId.pszName);
                return 0L;
        case    DecPtr:
                switch (PtrDest(Ptr->Use.DecPtr.pTarget)) {
                    case QualCONST:         return SIZE_PTR_CONST;
                    case QualVOLATILE:      return SIZE_PTR_VOLATILE;
                    case QualNEAR:          return SIZE_PTR_NEAR;
                    case QualFAR:           return SIZE_PTR_FAR;
                    default:                return SIZE_PTR_DEFAULT;
                }
        case    DecArray:
                return Ptr->Use.DecArray.Size * CalcSizeOf(Ptr->Use.DecArray.pTarget);
        case    DecFunc:
                return SIZE_FUNC;
        case    DecSpec:
                if      ((Ptr->Use.DecSpec.Type) & TypeENUM)    return SIZE_ENUM;
                else if ((Ptr->Use.DecSpec.Type) & TypeSTRUCT)  return CalcStructSize(Ptr->Use.DecSpec.pPtr);
                else if ((Ptr->Use.DecSpec.Type) & TypeTYPEDEF) return CalcSizeOf(Ptr->Use.DecSpec.pPtr);
                else {
                    if TT(Ptr,(TypeLONG|TypeDOUBLE))    return SIZE_LONGDOUBLE;
                    if TT(Ptr,TypeDOUBLE)               return SIZE_DOUBLE;
                    if TT(Ptr,TypeFLOAT)                return SIZE_FLOAT;
                    if TT(Ptr,TypeLONG)                 return SIZE_LONG;
                    if TT(Ptr,TypeSHORT)                return SIZE_SHORT;
                    if TT(Ptr,TypeINT)                  return SIZE_INT;
                    if TT(Ptr,TypeCHAR)                 return SIZE_CHAR;
                    if TT(Ptr,TypeSIGNED)               return SIZE_INT;
                    if TT(Ptr,TypeUNSIGNED)             return SIZE_INT;
                    if TT(Ptr,TypeVOID)                 return SIZE_VOID;
                    Error(FATAL, "CalcSizeOf: DecSpec.Type = %02x\n",Ptr->Use.DecSpec.Type);
                    return 0L;
                }
        default:
                Error(FATAL, "CalcSizeOf: Unknown Use\n");
                return 0L;
    }
}


static DWORD
CalcStructSize(TPStructSet Struct) {
    TPDeclSpec Elements = Struct->pElements;
    DWORD Total = 0L;
    if (!Elements)
        Error(ERROR0, "Object contains undefined Struct/Union '%s'",Struct->szSetName);
    if (Struct->fUnion) {
        while (Elements) {
            if (Elements->Usage != DecId) {
                Error(FATAL, "CalcStructSize: U Problem !\n");
            }
            Total = __max(Total, CalcSizeOf(Elements->Use.DecId.pTarget));
            Elements = Elements->Use.DecId.pBrother;
        }
    } else {
        while (Elements) {
            if (Elements->Usage != DecId) {
                Error(FATAL, "CalcStructSize: S Problem !\n");
            }
            Total += CalcSizeOf(Elements->Use.DecId.pTarget);
            Elements = Elements->Use.DecId.pBrother;
        }
    }
    return Total;
 }

LONG
CalcStructElementOffset(TPStructSet Struct, LPSTR Field) {
    TPDeclSpec Elements = Struct->pElements;
    LONG Total = 0L;
    if (!Elements)
        Error(ERROR0, "Object contains undefined Struct/Union '%s'",Struct->szSetName);
    if (Struct->fUnion) {
        while (Elements) {
            if (Elements->Usage != DecId) {
                Error(FATAL, "CalcStructElementOffset: U Problem !\n");
            }
            if (!strcmp(Field, Elements->Use.DecId.pszName)) return 0;
            Elements = Elements->Use.DecId.pBrother;
        }
    } else {
        while (Elements) {
            if (Elements->Usage != DecId) {
                Error(FATAL, "CalcStructElementOffset: S Problem !\n");
            }
            if (!strcmp(Field, Elements->Use.DecId.pszName)) return Total;
            Total += CalcSizeOf(Elements->Use.DecId.pTarget);
            Elements = Elements->Use.DecId.pBrother;
        }
    }
    return -1;
 }

TPDeclSpec
CalcStructElementType(TPStructSet Struct, LPSTR Field) {
    TPDeclSpec Elements = Struct->pElements;
    LONG Total = 0L;
    if (!Elements) {
        Error(ERROR0, "Object contains undefined Struct/Union '%s'.", Struct->szSetName);
    }
    if (Struct->fUnion) {
        while (Elements) {
            if (Elements->Usage != DecId) {
                Error(FATAL, "CalcStructElementType: U Problem !\n");
            }
            if (!strcmp(Field, Elements->Use.DecId.pszName)) return Elements->Use.DecId.pTarget;
            Elements = Elements->Use.DecId.pBrother;
        }
    } else {
        while (Elements) {
            if (Elements->Usage != DecId) {
                Error(FATAL, "CalcStructElementType: S Problem !\n");
            }
            if (!strcmp(Field, Elements->Use.DecId.pszName)) return Elements->Use.DecId.pTarget;
            Elements = Elements->Use.DecId.pBrother;
        }
    }
    return NULL;
 }

                                                            // *****************************************
                                                            // Can the Type be represented in an integer
BOOL IsIntegralType(TPDeclSpec Type) {                      // *****************************************
    if (!Type) {
        Error(FATAL, "IsIntegralType: Null.\n");
        return FALSE;
    }
    switch (Type->Usage) {
        case DecPtr:
        case DecArray:
        case DecFunc:   return TRUE;
        case DecSpec:   return (!(Type->Use.DecSpec.Type &
                                 (TypeVOID|TypeFLOAT|TypeDOUBLE|
                               // TypeSTRUCT|TypeENUM|
                                 TypeTYPEDEF)));
        case DecId: 
        default:        Error(FATAL, "IsIntegralType: What Usage [%d].\n",Type->Usage);
                        return FALSE;
    }
}

                                                        // ***************************************
                                                        // Can the Type be represented in an Real
BOOL IsRealType(TPDeclSpec Type) {                      // ***************************************
    if (!Type) {
        Error(FATAL, "IsRealType: Null.\n");
        return FALSE;
    }
    switch (Type->Usage) {
        case DecPtr:
        case DecArray:
        case DecFunc:   return FALSE;
        case DecSpec:   return (Type->Use.DecSpec.Type &
                                (TypeFLOAT|TypeDOUBLE));
        case DecId: 
        default:        Error(FATAL, "IsRealType: What Usage [%d].\n",Type->Usage);
                        return FALSE;
    }
 }


BOOL        IsTypeQualifier(TPDeclSpec pTarget, int Qualifier) {
    ASSERT(pTarget);
    if (((pTarget->Usage == DecSpec) && ((pTarget->Use.DecSpec.Qual & Qualifier) == Qualifier)) ||
        ((pTarget->Usage == DecPtr) && ((pTarget->Use.DecPtr.Qual & Qualifier) == Qualifier))) {
        return TRUE;
    }
    if (pTarget->Usage == DecArray) {
        return (IsTypeQualifier(pTarget->Use.DecArray.pTarget, Qualifier));
    }
    return FALSE;
}



/* eof */




