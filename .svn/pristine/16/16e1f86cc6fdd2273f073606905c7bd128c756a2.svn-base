// # $URL$
// # $Revision$


#pragma message("Todo: Declaration function names to start with Decl?")
//#pragma message("Todo: Globals dump to use depth and indent correctly")
//#pragma message("Todo: Local and parameters:  allocate and remove as scope changes.")

#pragma message("Todo: Local and parameters:  read and write need immeadiate or direct indication (ld r0,a or ld r0,#a.")
// can this be inferred by the variable name having type 'array'.
// with variables add indicator for addr or contents.
// with '*' and '&' swap indicators.
//
//#pragma message("Todo: Local and parameters:  unused variable warnings.")
#pragma message("Todo: Local and parameters:  read before set warnings.")
//#pragma message("Todo: Local variables and parameters. how to find them when parsing expressions.")
//#pragma message("Todo: Local variables. generate expression code.")

#pragma message("Todo: No concept of alignmnent. All vars occupy their own size and no packing is generated.")   
// this is also true of parameters on the stack.
// Given we have an 8 bit target this is not considered to be a problem.

#pragma message("Todo: void Foo(void). Parameters display incorrectly.")   
#pragma message("Todo: Subtraction of arrays looks odd. Debug and comment the code.")   

#pragma message("ToDo: C-parsing expression optimisation could be skipped and left for the optimizer?")
#pragma message("ToDo: Array, arrow and dot could be translated to arithmetic?")
#pragma message("ToDo: Casting should be case node with sub clasification of case type.")



#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <process.h>
#include <Windows.h>

//#include <ext\types.h>
#include "Utilities\Console.h"

#include "lex.h"
#include "typectrl.h"
#include "Expr.h"
#include "Gen.h"
#include "Main.h"
#include "C_Yacced.tab.h"

/* ******************************************* */

// int foo(int p1, int p2) {
//     int a=1;
//     int c=1;
//     for (;;) {
//         int a=0;
//         int p1;
//         a += c + p2;
//     }
// }

/* ******************************************* */

YYSTYPE     yylval;
void        yyparse(void);
FILE        *hOut = NULL;               // target generation.

DWORD dwErrorCount   = 0;
DWORD dwWarningCount = 0;
int   iFinalColour   = 0;               // Colour of the error count summary.
    
void ErrorLocator0(int iColour) {
    WORD i;
    fprintf(stderr, "%6ld: %s\n",yylval.LineInfo.LineNo, CurrentLine);
    ConsoleSetColour(iColour);
    for (i=0; i<yylval.LineInfo.LinePos+7; i++) fprintf(stderr, " ");
    fprintf(stderr, "^\n");
    
}

void ErrorLocator1(int iColour) {
    WORD i;
    fprintf(stderr, "%6ld: %s\n",yylval.LineInfo.OldNo, PreviousLine);
    ConsoleSetColour(iColour);
    for (i=0; i<yylval.LineInfo.OldPos+7; i++) fprintf(stderr, " ");
    fprintf(stderr, "^\n");
}

void ErrorLocatorX(int iColour) {
    fprintf(stderr, "Somewhere on or before line %d: ", yylval.LineInfo.OldNo);
}


void Error(TErrorType e, const char *pbFormat, ...) {
char szOutString[256];
    va_list ArgList;
    int iColour;
    char *pszErrClass = "";

    switch (e) {
    case WARNING0:
    case WARNING1:
    case WARNINGX: dwWarningCount++;
                   iColour = CON_YELLOW; // +CON_BRIGHT;
                   iFinalColour = max(iFinalColour, 1);
                   pszErrClass = "Warning";
                   break;
    case ERROR0:
    case ERROR1:
    case ERRORX:   dwErrorCount++;
                   iColour = CON_RED; // +CON_BRIGHT;
                   iFinalColour = max(iFinalColour, 2);
                   pszErrClass = "Error";
                   break;
    case FATAL:
    default:       iColour = CON_MAGENTA + CON_BRIGHT;
                   iFinalColour = max(iFinalColour, 3);
                   pszErrClass = "Fatal";
                   break;
    }

    switch (e) {
    case WARNING0: 
    case ERROR0:   ErrorLocator0(iColour);          // current symbol
                   break;
    case WARNING1:  
    case ERROR1:   ErrorLocator1(iColour);          // previous symbol
                   break;

    case WARNINGX:                                  // long lost symbol
    case ERRORX:   ErrorLocatorX(iColour);
                   break;

    case FATAL:
    default:       if (hOut == NULL) {      // no source to display if we are generating output.
                       ErrorLocator0(iColour);
                    }
                   break;
    }

    va_start(ArgList, pbFormat);
    _vsnprintf(szOutString, sizeof(szOutString), pbFormat, ArgList);
    ConsolePrintf(iColour, "%s: %s\n", pszErrClass, szOutString);
    if (e == FATAL) {
#ifdef _DEBUG
        _getch();
#endif // _DEBUG
        exit(-1);
    }
}


/* **************************************************************** */

char Source[_MAX_PATH];
char Dest[_MAX_PATH];
char Drive[_MAX_DRIVE];
char Dir[_MAX_DIR];
char Ext[_MAX_EXT];
char File[_MAX_FNAME];

void
SortOutFileNames(PSTR Name) {
	_splitpath( Name,   Drive, Dir, File, Ext);
	_makepath(  Source, Drive, Dir, File, ((*Ext == '.') && Ext[1]) ? Ext : ".c" );
	_makepath(  Dest,   Drive, Dir, File, ".asm" );
}

void Tidyup(void) {
    if (hOut != NULL) {
        fclose(hOut);
    }
}

void
main(int Argc, char *Argv[]) {
    // testing();
    // exit(0);

    if (Argc > 1) SortOutFileNames(Argv[1]);
    else          SortOutFileNames("code");
    
    if (!StartInput(Source)) {
            fprintf(stderr, "Failed opening source file '%s'\n", Source);
            exit(-1);
    }

    yyparse();
    EndInput();
     
    switch (iFinalColour) {
    case 0: iFinalColour = CON_GREEN + CON_BRIGHT; break;
    case 1: iFinalColour = CON_YELLOW + CON_BRIGHT; break;
    case 2: iFinalColour = CON_RED + CON_BRIGHT; break;
    }
    ConsolePrintf(iFinalColour, "%ld Errors, %ld Warnings.\n\n", dwErrorCount, dwWarningCount);

#ifdef _DEBUG

    if (dwErrorCount == 0) {
        EnumSetPrintList(0);
        PrintStructSets(0);
        ListGlobalTypes();
        ListGlobalObjects();
        ListParameterObjects();
        ListLocalObjects();
        //_getch();

        hOut = fopen(Dest, "wt");
        atexit(Tidyup);
        GenConst(hOut, GlobalObjects);
        GenData(hOut, GlobalObjects);
        GenBss(hOut, GlobalObjects);
        fclose(hOut);
        hOut = NULL;
    }
    ConsolePrintf(CON_WHITE, "Press key to exit\n");
    _getch();

#endif // _DEBUG
    if (dwErrorCount) {
        exit(-1);
    }
    else if (dwWarningCount) {
        exit(1);
    }
    else {
        exit(0);
    }
 }

/* eof */

