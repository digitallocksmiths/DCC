// # $URL$
// # $Revision$

#pragma message(" Logical operations are generate values.")
// Skipping code is better.


#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <setjmp.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <limits.h>
#include <float.h>
#include <Windows.h>

//#include <ext\types.h>
#include "Utilities\Console.h"

#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "gen.h"
#include "main.h"
#include "C_Yacced.tab.h"
#include "GenStatements.h"


static FILE *hGlbOut;

static int GenExpr(int iReg, TPExprNode pExpr);     // forward;


#ifdef _DEBUG

char *Uops[] = { "-u",  "+u",  "~u",    "u++",  "++u", "u--", "--u", "sizeof","addr", "ptr", "!u" };

char *Bops[] = { "+b",  "-b",  "*b",    "/b",   "%b", "&b",  "|b",  "^b",    "==b",  "!=b", "<b",  "<=b", ">b",    ">=b",  "&&b", "||b", ">>b", "<<b" };


void PrintNode(TPExprNode pN) {
    switch (pN->Usage) {
        case uConst:    printf("%lx ",  pN->Use.Const.lInteger);
                        break;
        case uVar:      printf("<%s> ",  pN->Use.Var.pszIdentifier);
                        break;
        case uUnary:    printf("(op ");
                        PrintNode(pN->Use.Unary.pOperand);
                        printf(")");
                        break;
        default:    Error(WARNING0, "Other ");
                    break;
    }
}

void ExprPrintInit(TPExprNode n) {
    while (n) {
        if (n->Usage != uInit) {
            Error(FATAL, "PrintInit: What !\n");
        }
        if (n->Use.Init.pAssignment) {
            PrintNode(n->Use.Init.pAssignment);
        }
        if (n->Use.Init.pChildren) {
            printf("{ ");
            ExprPrintInit(n->Use.Init.pChildren);
            printf("} ");
        }
        n=n->pSibling;
    }
}


void PrintType(int iDepth, TPExprNode n) {
    ASSERT(n->pType && ((n->pType->Usage == DecSpec) || (n->pType->Usage == DecPtr) || (n->pType->Usage == DecArray)));
    ParseDeclSpec(0, n->pType, FALSE);
 }

char *pszCasts[] = {
    "s8 to s16",
    "s8 to s32",
    "s16 to s32",
    "u8 to u16",
    "u8 to u32",
    "u16 to u32",
    "32 to 16",
    "32 to 8",
    "32 to BOOL",
    "16 to 8",
    "16 to BOOL"
};



void GenExpressionPrettyPrint(int iDepth, TPExprNode n) {
    if (!n) {
        printf("..Null\n");
        return;
    }
    
    switch (n->Usage) {
        case    uConst:     ConsoleIndent(iDepth);
                            ConsolePrintf(CON_MAGENTA_BRIGHT, "0x%x ",    n->Use.Const.lInteger);
                            PrintType(iDepth, n);
                            break;
        case    uVar:       ConsoleIndent(iDepth);
                            ConsolePrintf(CON_YELLOW_BRIGHT, "[%s",  n->Use.Var.pszIdentifier);
                            if (n->Use.Var.iFrameOffset != GLOBAL_VAR) ConsolePrintf(CON_YELLOW_BRIGHT, ":%d] ", n->Use.Var.iFrameOffset);       // variable offset
                            else                                       ConsolePrintf(CON_YELLOW_BRIGHT, "] ");                                   // variable is global
                            PrintType(iDepth, n);
                            break;
        case    uUnary:     ConsoleIndent(iDepth);
                            printf("%s ", Uops[n->Use.Unary.Op]);
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Unary.pOperand);
                            break;
        case    uBinary:    GenExpressionPrettyPrint(iDepth + 1, n->Use.Binary.pLeft);
                            ConsoleIndent(iDepth);
                            printf("%s ", Bops[n->Use.Unary.Op]);
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Binary.pRight);
                            break;
        case    uTernary:   ConsoleIndent(iDepth);
                            printf("Tern ");
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Ternary.First);
                            ConsoleIndent(iDepth);
                            printf("Then\n");
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Ternary.Second);
                            ConsoleIndent(iDepth);
                            printf("Else\n");
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Ternary.Third);
                            break;
        case    uDot:       GenExpressionPrettyPrint(iDepth + 1, n->Use.Dot.pRecord);
                            ConsoleIndent(iDepth);
                            printf("Dot ");
                            PrintType(iDepth, n);
                            ConsoleIndent(iDepth);
                            printf("[%s:%d]\n", n->Use.Dot.pszField, n->Use.Dot.iOffset);
                            break;
        case    uArrow:     GenExpressionPrettyPrint(iDepth + 1, n->Use.Arrow.pRecord);
                            ConsoleIndent(iDepth);
                            printf("Arrow ");
                            PrintType(iDepth, n);
                            ConsoleIndent(iDepth);
                            printf("[%s:%d]\n",n->Use.Arrow.pszField, n->Use.Arrow.iOffset);
                            break;
        case    uArray:     GenExpressionPrettyPrint(iDepth + 1, n->Use.Array.pVector);
                            ConsoleIndent(iDepth);
                            printf("Array ");
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Array.pIndex);
                            break;
        case    uFunc:      GenExpressionPrettyPrint(iDepth + 1, n->Use.pFunc.pFunc);
                            ConsoleIndent(iDepth);
                            printf("Function ");
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.pFunc.pParams);
                            break;
        case    uCast:      ConsoleIndent(iDepth);
                            printf("Cast %s", pszCasts[n->Use.Cast.Op]);
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Cast.pTarget);
                            break;
        case    uAssign:    ConsoleIndent(iDepth);
                            printf("Assign ");
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Assign.pLval);
                            ConsoleIndent(iDepth);
                            printf("<==\n");
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Assign.pRval);
                            break;
        default:            Error(FATAL, "ParseExpr: What [%d]\n", n->Usage);
                            break;
    }
}
#endif // _DEBUG

// ############################################################################################
static LPSTR OperandRegImmediate(int iR1, unsigned char bVal) {
    static char caRegVal[16];
    sprintf_s(caRegVal, sizeof(caRegVal), "r%d, 0x%02x", iR1, bVal);
    return caRegVal;
}

static LPSTR OperandRegVar(int iR1, LPSTR pszVar) {
    static char caRegStr[256];
    if ((iR1 & 0x01) == 0) {
        sprintf_s(caRegStr, sizeof(caRegStr), "r%d, lo8(%s)", iR1, pszVar);
    }
    else {
        sprintf_s(caRegStr, sizeof(caRegStr), "r%d, hi8(%s)", iR1, pszVar);
    }
    return caRegStr;
}

static LPSTR OperandRegStr(int iR1, LPSTR pszStr) {
    static char caRegVal[16];
    sprintf_s(caRegVal, sizeof(caRegVal), "r%d, %s", iR1, pszStr);
    return caRegVal;
}

static LPSTR OperandStrReg(LPSTR pszStr, int iR1) {
    static char caRegVal[16];
    sprintf_s(caRegVal, sizeof(caRegVal), "%s, r%d", pszStr, iR1);
    return caRegVal;
}

static LPSTR OperandRegDisp(int iR1, LPSTR pszStr, int iDisp) {
    static char caRegVal[16];
    if (iDisp < 0) {
        sprintf_s(caRegVal, sizeof(caRegVal), "r%d, %s%d", iR1, pszStr, iDisp);
    }
    else {
        sprintf_s(caRegVal, sizeof(caRegVal), "r%d, %s+%d", iR1, pszStr, iDisp);
    }
    return caRegVal;
}

static LPSTR OperandDispReg(LPSTR pszStr, int iDisp, int iR1) {
    static char caValReg[16];
    if (iDisp < 0) {
        sprintf_s(caValReg, sizeof(caValReg), "%s%d, r%d", pszStr, iDisp, iR1);
    }
    else {
        sprintf_s(caValReg, sizeof(caValReg), "%s+%d, r%d", pszStr, iDisp, iR1);
    }
    return caValReg;
}

static LPSTR OperandReg(int iR) {
    static char caRegPair[16];
    sprintf_s(caRegPair, sizeof(caRegPair), "r%d", iR);
    return caRegPair;
}

static LPSTR OperandRegReg(int iR1, int iR2) {
    static char caRegReg[16];
    sprintf_s(caRegReg, sizeof(caRegReg), "r%d, r%d", iR1, iR2);
    return caRegReg;
}

static LPSTR CommentNumber(int iCycles, LPSTR pszT, long lValue) {
    static char caComment[256];
    sprintf_s(caComment, sizeof(caComment), "%3d: %s%ld", iCycles, pszT, lValue);
    return caComment;
}

static LPSTR CommentString(int iCycles, LPSTR pszT, LPSTR pszM) {
    static char caComment[256];
    sprintf_s(caComment, sizeof(caComment), "%3d: %s%s", iCycles, pszT, pszM);
    return caComment;
}

 
void GenAsm(LPSTR pszLabel, LPSTR pszOpcode, LPSTR pszOperand, LPSTR pszComment) {
    GenAsmOut(hGlbOut, pszLabel, pszOpcode, pszOperand, pszComment, TRUE, FALSE);           // always to the same file and always needs NL and it's non global.
}


int AVR_LoadImmediate8(int iReg, unsigned char bValue) {
    GenAsm("", "ldi",  OperandRegImmediate(26, bValue), CommentNumber(1, "const ", bValue));
    GenAsm("", "mov",  OperandRegReg(iReg, 26),         "  1:");
    return iReg + 1;
}
int  AVR_LoadImmediate16(int iReg, unsigned short nValue) {
    GenAsm("", "ldi",  OperandRegImmediate(26, (nValue & 0xFF)),        CommentNumber(1, "const ", nValue));
    GenAsm("", "ldi",  OperandRegImmediate(27, ((nValue >> 8) & 0xFF)), "  1:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 26), "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 26),   "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+1, 27), "  1:");
    }
    return iReg + 2;
}
int  AVR_LoadImmediate32(int iReg, unsigned long lValue) {
    GenAsm("", "ldi",  OperandRegImmediate(26, (lValue & 0xFF)),         CommentNumber(1, "const ", lValue));
    GenAsm("", "ldi",  OperandRegImmediate(27, ((lValue >> 8) & 0xFF)),  "  1:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 26),     "  1:");
    }
    else {
        GenAsm("", "mov",  OperandRegReg(iReg, 26),     "  1:");
        GenAsm("", "mov",  OperandRegReg(iReg + 1, 27), "  1:");
    }
    GenAsm("", "ldi", OperandRegImmediate(26, ((lValue >> 16) & 0xFF)), "  1:");
    GenAsm("", "ldi", OperandRegImmediate(27, ((lValue >> 24) & 0xFF)), "  1:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg + 2, 26), "  1:");
    }
    else {
        GenAsm("", "mov",  OperandRegReg(iReg + 2, 26), "  1:");
        GenAsm("", "mov",  OperandRegReg(iReg + 3, 27), "  1:");
    }
    return iReg + 4;
}

int AVR_LoadRom8(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar), "  1:");
    GenAsm("", "lpm", OperandRegStr(iReg, "Z"),  "  3:");
    return iReg + 1;
}
int  AVR_LoadRom16(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar),     CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),     "  1:");
    GenAsm("", "lpm", OperandRegStr(iReg,     "Z+"), "  3:");
    GenAsm("", "lpm", OperandRegStr(iReg + 1, "Z"),  "  3:");
    return iReg + 2;
}
int  AVR_LoadRom32(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar),     CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),     "  1:");
    GenAsm("", "lpm", OperandRegStr(iReg,     "Z+"), "  3:");
    GenAsm("", "lpm", OperandRegStr(iReg + 1, "Z+"), "  3:");
    GenAsm("", "lpm", OperandRegStr(iReg + 2, "Z+"), "  3:");
    GenAsm("", "lpm", OperandRegStr(iReg + 3, "Z"),  "  3:");
    return iReg + 4;
}

int AVR_LoadRam8(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar), "  1:");
    GenAsm("", "ld",  OperandRegStr(iReg, "Z"),  "  1:");
    return iReg + 1;
}
int AVR_LoadRam8PostInc(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),     "  1: post inc");
    GenAsm("", "ld",  OperandRegStr(iReg, "Z"),      "  1:");
    GenAsm("", "mov", OperandRegReg(24, iReg),       "  1:");
    GenAsm("", "inc", OperandReg(24),                "  1:");
    GenAsm("", "st",  OperandStrReg("Z", 24),        "  1:");
    return iReg + 1;
}
int AVR_LoadRam8PreInc(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar), "  1: pre inc");
    GenAsm("", "ld",  OperandRegStr(iReg, "Z"),  "  1:");
    GenAsm("", "inc", OperandReg(iReg),          "  1:");
    GenAsm("", "ld",  OperandStrReg("Z", iReg),  "  1:");
    return iReg + 1;
}
int AVR_LoadRam8PostDec(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),     "  1: post dec");
    GenAsm("", "ld",  OperandRegStr(iReg, "Z"),      "  1:");
    GenAsm("", "mov", OperandRegReg(24, iReg),       "  1:");
    GenAsm("", "dec", OperandReg(24),                "  1:");
    GenAsm("", "ld",  OperandStrReg("Z", 24),        "  1:");
    return iReg + 1;
}
int AVR_LoadRam8PreDec(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar), "  1: pre dec");
    GenAsm("", "ld",  OperandRegStr(iReg, "Z"),  "  1:");
    GenAsm("", "dec", OperandReg(iReg),          "  1:");
    GenAsm("", "ld",  OperandStrReg("Z", iReg),  "  1:");
    return iReg + 1;
}

int  AVR_LoadRam16(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar),        CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),        "  1:");
    GenAsm("", "ld",  OperandRegStr(iReg, "Z"),         "  1:");
    GenAsm("", "ldd", OperandRegDisp(iReg + 1, "Z", 1), "  2:");
    return iReg + 2;
}
int  AVR_LoadRam16PostInc(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),        "  1: post inc");
    GenAsm("", "ld", OperandRegStr(24, "Z"),            "  1:");
    GenAsm("", "ldd", OperandRegDisp(25, "Z", 1),       "  2:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 24),     "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 24),      "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+1, 25),    "  1:");
    }
    GenAsm("", "adiw", OperandRegImmediate(24, 1),    "  2:");
    GenAsm("", "st", OperandStrReg("Z", 24),          "  1:");
    GenAsm("", "std", OperandDispReg("Z", 1, 25),     "  2:");
    return iReg + 2;
}
int  AVR_LoadRam16PreInc(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),        "  1: pre inc");
    GenAsm("", "ld", OperandRegStr(24, "Z"),            "  1:");
    GenAsm("", "ldd", OperandRegDisp(25, "Z", 1),       "  2:");
    GenAsm("", "adiw", OperandRegImmediate(24, 1),      "  2:");
    GenAsm("", "st", OperandStrReg("Z", 24),            "  1:");
    GenAsm("", "std", OperandDispReg("Z", 1, 25),       "  2:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 24),     "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 24),      "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+1, 25),    "  1:");
    }
    return iReg + 2;
}
int  AVR_LoadRam16PostDec(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),         "  1: post dec");
    GenAsm("", "ld", OperandRegStr(24, "Z"),             "  1:");
    GenAsm("", "ldd", OperandRegDisp(25, "Z", 1),        "  2:");
    if ((iReg & 1) == 0) {                               
        GenAsm("", "movw", OperandRegReg(iReg, 24),      "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 24),       "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+1, 25),     "  1:");
    }
    GenAsm("", "sbiw", OperandRegImmediate(24, 1),       "  2:");
    GenAsm("", "st",   OperandStrReg("Z", 24),           "  1:");
    GenAsm("", "std",  OperandDispReg("Z", 1, 25),       "  2:");
    return iReg + 2;
}
int  AVR_LoadRam16PreDec(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi",  OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi",  OperandRegVar(31, pszVar),       "  1: pre dec");
    GenAsm("", "ld",   OperandRegStr(24, "Z"),          "  1:");
    GenAsm("", "ldd",  OperandRegDisp(25 + 1, "Z", 1),  "  2:");
    GenAsm("", "sbiw", OperandRegImmediate(24, 1),      "  2:");
    GenAsm("", "st",  OperandStrReg("Z", 24),           "  1:");
    GenAsm("", "std", OperandDispReg("Z", 1,25),        "  2:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 24),     "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 24),      "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+1, 25),    "  1:");
    }
    return iReg + 2;
}

int  AVR_LoadRam32(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar),        CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),        "  1:");
    GenAsm("", "ld",  OperandRegStr(iReg, "Z"),         "  1:");
    GenAsm("", "ldd", OperandRegDisp(iReg + 1, "Z", 1), "  2:");
    GenAsm("", "ldd", OperandRegDisp(iReg + 2, "Z", 2), "  2:");
    GenAsm("", "ldd", OperandRegDisp(iReg + 3, "Z", 3), "  2:");
    return iReg + 4;
}
int  AVR_LoadRam32PostInc(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),       "  1: post inc");
    GenAsm("", "ld",  OperandRegStr(22,  "Z"),         "  1:");
    GenAsm("", "ldd", OperandRegDisp(23, "Z", 1),      "  2:");
    GenAsm("", "ldd", OperandRegDisp(24, "Z", 2),      "  2:");
    GenAsm("", "ldd", OperandRegDisp(25, "Z", 3),      "  2:");
    if ((iReg & 1) == 0) {                             
        GenAsm("", "movw", OperandRegReg(iReg, 22),    "  1:");
        GenAsm("", "movw", OperandRegReg(iReg+2, 24),  "  1:");
    }                                                  
    else {                                             
        GenAsm("", "mov", OperandRegReg(iReg,   22),   "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+1, 23),   "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+2, 24),   "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+3, 25),   "  1:");
    }                                                  
    GenAsm("", "subi", OperandRegImmediate(22, 0xff),  "  1:");
    GenAsm("", "sbci", OperandRegImmediate(23, 0xff),  "  1:");
    GenAsm("", "sbci", OperandRegImmediate(24, 0xff),  "  1:");
    GenAsm("", "sbci", OperandRegImmediate(25, 0xff),  "  1:");
    GenAsm("", "st",   OperandStrReg("Z", 22),         "  1:");
    GenAsm("", "std",  OperandDispReg("Z", 1, 23),     "  2:");
    GenAsm("", "std",  OperandDispReg("Z", 2, 24),     "  2:");
    GenAsm("", "std",  OperandDispReg("Z", 3, 25),     "  2:");
    return iReg + 4;
}
int  AVR_LoadRam32PreInc(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi",  OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi",  OperandRegVar(31, pszVar),       "  1: pre inc");
    GenAsm("", "ld",   OperandRegStr(22, "Z"),          "  1:");
    GenAsm("", "ldd",  OperandRegDisp(23, "Z", 1),      "  2:");
    GenAsm("", "ldd",  OperandRegDisp(24, "Z", 2),      "  2:");
    GenAsm("", "ldd",  OperandRegDisp(25, "Z", 3),      "  2:");
    GenAsm("", "subi", OperandRegImmediate(22, 0xff),   "  1:");
    GenAsm("", "sbci", OperandRegImmediate(23, 0xff),   "  1:");
    GenAsm("", "sbci", OperandRegImmediate(24, 0xff),   "  1:");
    GenAsm("", "sbci", OperandRegImmediate(25, 0xff),   "  1:");
    GenAsm("", "st",   OperandStrReg("Z", 22),          "  1:");
    GenAsm("", "std",  OperandDispReg("Z", 1, 23),      "  2:");
    GenAsm("", "std",  OperandDispReg("Z", 2, 24),      "  2:");
    GenAsm("", "std",  OperandDispReg("Z", 3, 25),      "  2:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 22),     "  1:");
        GenAsm("", "movw", OperandRegReg(iReg + 2, 24), "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 22),      "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 1, 23),  "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 2, 24),  "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 3, 25),  "  1:");
    }
    return iReg + 4;
}
int  AVR_LoadRam32PostDec(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),      "  1: post dec");
    GenAsm("", "ld",  OperandRegStr(22,  "Z"),        "  1:");
    GenAsm("", "ldd", OperandRegDisp(23, "Z", 1),     "  2:");
    GenAsm("", "ldd", OperandRegDisp(24, "Z", 2),     "  2:");
    GenAsm("", "ldd", OperandRegDisp(25, "Z", 3),     "  2:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 22),   "  1:");
        GenAsm("", "movw", OperandRegReg(iReg+2, 24), "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg,   22),  "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+1, 23),  "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+2, 24),  "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+3, 25),  "  1:");
    }
    GenAsm("", "subi", OperandRegImmediate(22, 0x01), "  1:");
    GenAsm("", "sbci", OperandRegImmediate(23, 0x00), "  1:");
    GenAsm("", "sbci", OperandRegImmediate(24, 0x00), "  1:");
    GenAsm("", "sbci", OperandRegImmediate(25, 0x00), "  1:");
    GenAsm("", "st", OperandStrReg("Z", 22),          "  1:");
    GenAsm("", "std", OperandDispReg("Z", 1, 23),     "  2:");
    GenAsm("", "std", OperandDispReg("Z", 2, 24),     "  2:");
    GenAsm("", "std", OperandDispReg("Z", 3, 25),     "  2:");
    return iReg + 4;
}
int  AVR_LoadRam32PreDec(int iReg, LPSTR pszVar) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),      "  1: pre dec");
    GenAsm("", "ld",  OperandRegStr(22,  "Z"),        "  1:");
    GenAsm("", "ldd", OperandRegDisp(23, "Z", 1),     "  2:");
    GenAsm("", "ldd", OperandRegDisp(24, "Z", 2),     "  2:");
    GenAsm("", "ldd", OperandRegDisp(25, "Z", 3),     "  2:");
    GenAsm("", "subi", OperandRegImmediate(22, 0x01), "  1:");
    GenAsm("", "sbci", OperandRegImmediate(23, 0x00), "  1:");
    GenAsm("", "sbci", OperandRegImmediate(24, 0x00), "  1:");
    GenAsm("", "sbci", OperandRegImmediate(25, 0x00), "  1:");
    GenAsm("", "st", OperandStrReg("Z", 22),          "  1:");
    GenAsm("", "std", OperandDispReg("Z", 1, 23),     "  2:");
    GenAsm("", "std", OperandDispReg("Z", 2, 24),     "  2:");
    GenAsm("", "std", OperandDispReg("Z", 3, 25),     "  2:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 22),   "  1:");
        GenAsm("", "movw", OperandRegReg(iReg+2, 24), "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg,   22),  "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+1, 23),  "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+2, 24),  "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+3, 25),  "  1:");
    }
    return iReg + 4;
}





int AVR_StoreRam8(LPSTR pszVar, int iReg) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar),        CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),        "  1:");
    GenAsm("", "st",  OperandStrReg("Z", iReg),         "  1:");
    return iReg + 1;
    ;
}
int  AVR_StoreRam16(LPSTR pszVar, int iReg) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar),        CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),        "  1:");
    GenAsm("", "st",  OperandStrReg("Z", iReg),         "  1:");
    GenAsm("", "std", OperandDispReg("Z", 1, iReg + 1), "  2:");
    return iReg + 2;
}
int  AVR_StoreRam32(LPSTR pszVar, int iReg) {
    GenAsm("", "ldi", OperandRegVar(30, pszVar),        CommentString(1, "Z = ", pszVar));
    GenAsm("", "ldi", OperandRegVar(31, pszVar),        "  1:");
    GenAsm("", "st",  OperandStrReg("Z", iReg),         "  1:");
    GenAsm("", "std", OperandDispReg("Z", 1, iReg + 1), "  2:");
    GenAsm("", "std", OperandDispReg("Z", 2, iReg + 2), "  2:");
    GenAsm("", "std", OperandDispReg("Z", 3, iReg + 3), "  2:");
    return iReg + 2;
}



int AVR_LoadFrame8(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(iReg, "Y", iGlbLocalSize + iOffset), CommentString(2, "", pszVar));
    return iReg + 1;
}
int AVR_LoadFrame8PostInc(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(24, "Y", iGlbLocalSize + iOffset), CommentString(2, "", pszVar));
    GenAsm("", "mov", OperandRegReg(iReg, 24),                          "  1: post inc");
    GenAsm("", "inc", OperandReg(24),                                   "  1:");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset, 24), "  2:");
    return iReg + 1;
}
int AVR_LoadFrame8PostDec(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(24, "Y", iGlbLocalSize + iOffset),     CommentString(2, "", pszVar));
    GenAsm("", "mov", OperandRegReg(iReg, 24),                              "  1: post dec");
    GenAsm("", "dec", OperandReg(24),                                       "  1:");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset, 24),     "  2:");
    return iReg + 1;
}
int AVR_LoadFrame8PreInc(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(iReg, "Y", iGlbLocalSize + iOffset), CommentString(2, "", pszVar));
    GenAsm("", "inc", OperandReg(iReg),                                   "  1: pre inc");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset, 24),   "  2:");
    return iReg + 1;
}
int AVR_LoadFrame8PreDec(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(iReg, "Y", iGlbLocalSize + iOffset), CommentString(2, "", pszVar));
    GenAsm("", "dec", OperandReg(iReg),                                   "  1: pre dec");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset, 24),   "  2:");
    return iReg + 1;
}

int  AVR_LoadFrame16(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(iReg,      "Y", iGlbLocalSize + iOffset),   CommentString(2, "", pszVar));
    GenAsm("", "ldd", OperandRegDisp(iReg + 1 , "Y", iGlbLocalSize + iOffset+1), "  2:");
    return iReg + 2;
}
int  AVR_LoadFrame16PostInc(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(24, "Y", iGlbLocalSize + iOffset),      CommentString(2, "", pszVar));
    GenAsm("", "ldd", OperandRegDisp(25, "Y", iGlbLocalSize + iOffset + 1),  "  2: post inc");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 24),  "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 24),   "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+1, 25), "  1:");
    }
    GenAsm("", "adiw", OperandRegImmediate(24, 1),                           "  1:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset,     24), "  2:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset + 1, 25), "  2:");
    return iReg + 2;
}
int  AVR_LoadFrame16PostDec(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(24, "Y", iGlbLocalSize + iOffset),      CommentString(2, "", pszVar));
    GenAsm("", "ldd", OperandRegDisp(25, "Y", iGlbLocalSize + iOffset + 1),  "  2: post dec");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 24),  "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 24),   "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+1, 25), "  1:");
    }
    GenAsm("", "sbiw", OperandRegImmediate(24, 1),                           "  1:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset,     24), "  2:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset + 1, 25), "  2:");
    return iReg + 2;
}
int  AVR_LoadFrame16PreInc(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(24, "Y", iGlbLocalSize + iOffset),      CommentString(2, "", pszVar));
    GenAsm("", "ldd", OperandRegDisp(25, "Y", iGlbLocalSize + iOffset + 1),  "  2: pre inc");
    GenAsm("", "adiw", OperandRegImmediate(24, 1),                           "  1:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset,     24), "  2:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset + 1, 25), "  2:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 24),  "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 24),   "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+1, 25), "  1:");
    }
    return iReg + 2;
}
int  AVR_LoadFrame16PreDec(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(24, "Y", iGlbLocalSize + iOffset),      CommentString(2, "", pszVar));
    GenAsm("", "ldd", OperandRegDisp(25, "Y", iGlbLocalSize + iOffset + 1),  "  2: pre dec");
    GenAsm("", "sbiw", OperandRegImmediate(24, 1),                           "  1:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset,     24), "  2:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset + 1, 25), "  2:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 24),  "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 24),   "  1:");
        GenAsm("", "mov", OperandRegReg(iReg+1, 25), "  1:");
    }
    return iReg + 2;
}


int  AVR_LoadFrame32(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(iReg, "Y", iGlbLocalSize + iOffset), CommentString(2, "", pszVar));
    GenAsm("", "ldd", OperandRegDisp(iReg + 1, "Y", iGlbLocalSize + iOffset + 1), "  2:");
    GenAsm("", "ldd", OperandRegDisp(iReg + 2, "Y", iGlbLocalSize + iOffset + 2), "  2:");
    GenAsm("", "ldd", OperandRegDisp(iReg + 3, "Y", iGlbLocalSize + iOffset + 3), "  2:");
    return iReg + 4;
}
int  AVR_LoadFrame32PostInc(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(22, "Y", iGlbLocalSize + iOffset),     CommentString(2, "", pszVar));
    GenAsm("", "ldd", OperandRegDisp(23, "Y", iGlbLocalSize + iOffset + 1), "  2: post inc");
    GenAsm("", "ldd", OperandRegDisp(24, "Y", iGlbLocalSize + iOffset + 2), "  2:");
    GenAsm("", "ldd", OperandRegDisp(25, "Y", iGlbLocalSize + iOffset + 3), "  2:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 22),   "  1:");
        GenAsm("", "movw", OperandRegReg(iReg+2, 24), "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 22),     "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 1, 23), "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 2, 24), "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 3, 25), "  1:");
    }
    GenAsm("", "subi", OperandRegImmediate(22, 0xff),                        "  1:");
    GenAsm("", "sbci", OperandRegImmediate(23, 0xff),                        "  1:");
    GenAsm("", "sbci", OperandRegImmediate(24, 0xff),                        "  1:");
    GenAsm("", "sbci", OperandRegImmediate(25, 0xff),                        "  1:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset,     22), "  2:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset + 1, 23), "  2:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset + 2, 24), "  2:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset + 3, 25), "  2:");
    return iReg + 4;
}
int  AVR_LoadFrame32PostDec(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(22, "Y", iGlbLocalSize + iOffset),     CommentString(2, "", pszVar));
    GenAsm("", "ldd", OperandRegDisp(23, "Y", iGlbLocalSize + iOffset + 1), "  2: post dec");
    GenAsm("", "ldd", OperandRegDisp(24, "Y", iGlbLocalSize + iOffset + 2), "  2:");
    GenAsm("", "ldd", OperandRegDisp(25, "Y", iGlbLocalSize + iOffset + 3), "  2:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 22),   "  1:");
        GenAsm("", "movw", OperandRegReg(iReg+2, 24), "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 22),     "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 1, 23), "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 2, 24), "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 3, 25), "  1:");
    }
    GenAsm("", "subi", OperandRegImmediate(22, 1),                           "  1:");
    GenAsm("", "sbci", OperandRegImmediate(23, 0),                           "  1:");
    GenAsm("", "sbci", OperandRegImmediate(24, 0),                           "  1:");
    GenAsm("", "sbci", OperandRegImmediate(25, 0),                           "  1:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset,     22), "  2:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset + 1, 23), "  2:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset + 2, 24), "  2:");
    GenAsm("", "std",  OperandDispReg("Y", iGlbLocalSize + iOffset + 3, 25), "  2:");
    return iReg + 4;
}
int  AVR_LoadFrame32PreInc(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(22, "Y", iGlbLocalSize + iOffset), CommentString(2, "", pszVar));
    GenAsm("", "ldd", OperandRegDisp(23, "Y", iGlbLocalSize + iOffset + 1), "  2: pre inc");
    GenAsm("", "ldd", OperandRegDisp(24, "Y", iGlbLocalSize + iOffset + 2), "  2:");
    GenAsm("", "ldd", OperandRegDisp(25, "Y", iGlbLocalSize + iOffset + 3), "  2:");
    GenAsm("", "subi", OperandRegImmediate(22, 0xff), "  1:");
    GenAsm("", "sbci", OperandRegImmediate(23, 0xff), "  1:");
    GenAsm("", "sbci", OperandRegImmediate(24, 0xff), "  1:");
    GenAsm("", "sbci", OperandRegImmediate(25, 0xff), "  1:");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset, 22),     "  2:");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset + 1, 23), "  2:");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset + 2, 24), "  2:");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset + 3, 25), "  2:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 22),     "  1:");
        GenAsm("", "movw", OperandRegReg(iReg + 2, 24), "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 22),     "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 1, 23), "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 2, 24), "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 3, 25), "  1:");
    }
    return iReg + 4;
}
int  AVR_LoadFrame32PreDec(int iReg, int iOffset, LPSTR pszVar) {
    GenAsm("", "ldd", OperandRegDisp(22, "Y", iGlbLocalSize + iOffset), CommentString(2, "", pszVar));
    GenAsm("", "ldd", OperandRegDisp(23, "Y", iGlbLocalSize + iOffset + 1), "  2: pre dec");
    GenAsm("", "ldd", OperandRegDisp(24, "Y", iGlbLocalSize + iOffset + 2), "  2:");
    GenAsm("", "ldd", OperandRegDisp(25, "Y", iGlbLocalSize + iOffset + 3), "  2:");
    GenAsm("", "subi", OperandRegImmediate(22, 0x01), "  1:");
    GenAsm("", "sbci", OperandRegImmediate(23, 0x00), "  1:");
    GenAsm("", "sbci", OperandRegImmediate(24, 0x00), "  1:");
    GenAsm("", "sbci", OperandRegImmediate(25, 0x00), "  1:");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset, 22),     "  2:");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset + 1, 23), "  2:");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset + 2, 24), "  2:");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset + 3, 25), "  2:");
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(iReg, 22),     "  1:");
        GenAsm("", "movw", OperandRegReg(iReg + 2, 24), "  1:");
    }
    else {
        GenAsm("", "mov", OperandRegReg(iReg, 22),     "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 1, 23), "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 2, 24), "  1:");
        GenAsm("", "mov", OperandRegReg(iReg + 3, 25), "  1:");
    }
    return iReg + 4;
}

int AVR_StoreFrame8(int iOffset, int iReg, LPSTR pszVar) {
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset, iReg), CommentString(2, "", pszVar));
    return iReg + 1;
}
int  AVR_StoreFrame16(int iOffset, int iReg, LPSTR pszVar) {
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset,   iReg),   CommentString(2, "", pszVar));
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset+1, iReg+1), "  2:");
    return iReg + 2;
}
int  AVR_StoreFrame32(int iOffset, int iReg, LPSTR pszVar) {
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset,   iReg),   CommentString(2, "", pszVar));
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset+1, iReg+1), "  2:");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset+2, iReg+2), "  2:");
    GenAsm("", "std", OperandDispReg("Y", iGlbLocalSize + iOffset+3, iReg+3), "  2:");
    return iReg + 4;
}

// ############################################################################################

int GenAdd(int iReg, int iSize) {
    switch (iSize) {
    case 1: 
        GenAsm("", "add", OperandRegReg(iReg - 2, iReg - 1), "  1: Add8");
        break;
    case 2:
        GenAsm("", "add", OperandRegReg(iReg - 4, iReg - 2), "  1: Add16");
        GenAsm("", "adc", OperandRegReg(iReg - 3, iReg - 1), "  1:");
        break;
    case 4:
        GenAsm("", "add", OperandRegReg(iReg - 8, iReg - 4), "  1: Add32");
        GenAsm("", "adc", OperandRegReg(iReg - 7, iReg - 3), "  1:");
        GenAsm("", "adc", OperandRegReg(iReg - 6, iReg - 2), "  1:");
        GenAsm("", "adc", OperandRegReg(iReg - 5, iReg - 1), "  1:");
        break;
    default:
        Error(FATAL, "GenAdd: size not supported (%d)\n", iSize);
    }
    return iReg - iSize;
}

int GenSub(int iReg, int iSize) {
    switch (iSize) {
    case 1:
        GenAsm("", "sub", OperandRegReg(iReg - 2, iReg - 1), "  1: Sub8");
        break;
    case 2:
        GenAsm("", "sub", OperandRegReg(iReg - 4, iReg - 2), "  1: Sub16");
        GenAsm("", "sbc", OperandRegReg(iReg - 3, iReg - 1), "  1:");
        break;
    case 4:
        GenAsm("", "sub", OperandRegReg(iReg - 8, iReg - 4), "  1: Sub32");
        GenAsm("", "sbc", OperandRegReg(iReg - 7, iReg - 3), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 6, iReg - 2), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 5, iReg - 1), "  1:");
        break;
    default:
        Error(FATAL, "GenSub: size not supported (%d)\n", iSize);
    }
    return iReg - iSize;
}

int GenMul(int iReg, int iSize) {
    LPSTR   szMulLoop = GenLabel("_MulMult_");
    LPSTR   szMulDone = GenLabel("_MulDone_");

    switch (iSize) {
    case 1:
        GenAsm("",        "clr",  OperandReg(0),                  "  1: Mul 8");
        GenAsm(szMulLoop, "sbrc", OperandRegImmediate(iReg-2, 0), "1/3:");
        GenAsm("",        "add",  OperandRegReg(0, iReg-1),       "  1:");
        GenAsm("",        "lsl",  OperandReg(iReg - 1),           "  1:");
        GenAsm("",        "breq", szMulDone,                      "1/2:");
        GenAsm("",        "lsr",  OperandReg(iReg - 2),           "  1:");
        GenAsm("",        "brne", szMulLoop,                      "1/2:");
        GenAsm(szMulDone, "mov",  OperandRegReg(iReg - 2, 0),     "  1:");
        break;
    case 2:
        if ((iReg & 1) == 1) {
            GenAsm("", "movw", OperandRegReg(24, iReg - 4), "  1: Mul 16");
            GenAsm("", "movw", OperandRegReg(26, iReg - 2), "  1:");
            GenAsm("", "rcall","SysMul16",                  " +3:");
            GenAsm("", "movw", OperandRegReg(iReg - 4, 0),  "  1:");
        }
        else {
            GenAsm("", "mov",  OperandRegReg(24, iReg - 4), "  1: Mul 16");
            GenAsm("", "mov",  OperandRegReg(25, iReg - 3), "  1:");
            GenAsm("", "mov",  OperandRegReg(26, iReg - 2), "  1:");
            GenAsm("", "mov",  OperandRegReg(27, iReg - 1), "  1:");
            GenAsm("", "rcall","SysMul16",                  " +3:");
            GenAsm("", "mov",  OperandRegReg(iReg - 4, 0),  "  1:");
            GenAsm("", "mov",  OperandRegReg(iReg - 3, 1),  "  1:");
        }
        break;
    case 4:
        if ((iReg & 1) == 1) {
            GenAsm("", "movw", OperandRegReg(20, iReg - 8), "  1: Mul 32");
            GenAsm("", "movw", OperandRegReg(22, iReg - 6), "  1:");
            GenAsm("", "movw", OperandRegReg(24, iReg - 4), "  1:");
            GenAsm("", "movw", OperandRegReg(26, iReg - 2), "  1:");
            GenAsm("", "rcall", "SysMul32",                 " +3:");
            GenAsm("", "movw", OperandRegReg(iReg - 8, 0),  "  1:");
            GenAsm("", "movw", OperandRegReg(iReg - 6, 2),  "  1:");
        }
        else {
            GenAsm("", "mov", OperandRegReg(20, iReg - 8), "  1: Mul 32");
            GenAsm("", "mov", OperandRegReg(21, iReg - 7), "  1:");
            GenAsm("", "mov", OperandRegReg(22, iReg - 6), "  1:");
            GenAsm("", "mov", OperandRegReg(23, iReg - 5), "  1:");
            GenAsm("", "mov", OperandRegReg(24, iReg - 4), "  1:");
            GenAsm("", "mov", OperandRegReg(25, iReg - 3), "  1:");
            GenAsm("", "mov", OperandRegReg(26, iReg - 2), "  1:");
            GenAsm("", "mov", OperandRegReg(27, iReg - 1), "  1:");
            GenAsm("", "rcall", "SysMul32",                " +3:");
            GenAsm("", "mov", OperandRegReg(iReg - 8, 0),  "  1:");
            GenAsm("", "mov", OperandRegReg(iReg - 7, 1),  "  1:");
            GenAsm("", "mov", OperandRegReg(iReg - 6, 2),  "  1:");
            GenAsm("", "mov", OperandRegReg(iReg - 5, 3),  "  1:");
        }
        break;
    default:
        Error(FATAL, "GenSub: size not supported (%d)\n", iSize);
    }
        
    return iReg - iSize;
}


int GenDiv(int iReg, int iSize) {
    LPSTR   szDivLoop = GenLabel("_DivLoop_");
    LPSTR   szDivEntr = GenLabel("_DivEntr_");

    switch (iSize) {
    case 1:
        GenAsm("",        "clr",  OperandReg(25),            "  1: Div 8");   // unsigned
        GenAsm("",        "ldi",  OperandRegImmediate(23,9), "  1:");
        GenAsm("",        "rjmp", szDivEntr,                 "  2:");
        GenAsm(szDivLoop, "rol",  OperandReg(25),            "  1:");
        GenAsm("",        "cp",   OperandRegReg(25, iReg-1), "  1:");
        GenAsm("",        "brcs", szDivEntr,                 "1/3:");
        GenAsm("",        "sub",  OperandRegReg(25, iReg-1), "  1:");
        GenAsm(szDivEntr, "rol",  OperandReg(iReg-2),        "  1:");
        GenAsm("",        "dec",  OperandReg(23),            "  1:");
        GenAsm("",        "brne", szDivLoop,                 "  1:");
        GenAsm("",        "com",  OperandReg(iReg-2),        "  1:");
        break;
    case 2:
        if ((iReg & 1) == 1) {
            GenAsm("", "movw",  OperandRegReg(24, iReg - 4), "  1: Div 16");
            GenAsm("", "movw",  OperandRegReg(26, iReg - 2), "  1:");
            GenAsm("", "rcall", "SysDiv16",                  " +3:");
            GenAsm("", "movw",  OperandRegReg(iReg - 4, 24), "  1:");
        }
        else {
            GenAsm("", "mov",   OperandRegReg(24, iReg - 4), "  1: Div 16");
            GenAsm("", "mov",   OperandRegReg(25, iReg - 3), "  1:");
            GenAsm("", "mov",   OperandRegReg(26, iReg - 2), "  1:");
            GenAsm("", "mov",   OperandRegReg(27, iReg - 1), "  1:");
            GenAsm("", "rcall", "SysDiv16",                  " +3:");
            GenAsm("", "mov",   OperandRegReg(iReg - 4, 24), "  1:");
            GenAsm("", "mov",   OperandRegReg(iReg - 3, 25), "  1:");
        }
        break;
    case 4:
        if ((iReg & 1) == 1) {
            GenAsm("", "movw", OperandRegReg(20, iReg - 8), "  1: Div 32");
            GenAsm("", "movw", OperandRegReg(22, iReg - 6), "  1:");
            GenAsm("", "movw", OperandRegReg(24, iReg - 4), "  1:");
            GenAsm("", "movw", OperandRegReg(26, iReg - 2), "  1:");
            GenAsm("", "rcall", "SysDiv32",                 " +3:");
            GenAsm("", "movw", OperandRegReg(iReg - 8, 24), "  1:");
            GenAsm("", "movw", OperandRegReg(iReg - 6, 26), "  1:");
        }
        else {
            GenAsm("", "mov", OperandRegReg(20, iReg - 8), "  1: Div 32");
            GenAsm("", "mov", OperandRegReg(21, iReg - 7), "  1:");
            GenAsm("", "mov", OperandRegReg(22, iReg - 6), "  1:");
            GenAsm("", "mov", OperandRegReg(23, iReg - 5), "  1:");
            GenAsm("", "mov", OperandRegReg(24, iReg - 4), "  1:");
            GenAsm("", "mov", OperandRegReg(25, iReg - 3), "  1:");
            GenAsm("", "mov", OperandRegReg(26, iReg - 2), "  1:");
            GenAsm("", "mov", OperandRegReg(27, iReg - 1), "  1:");
            GenAsm("", "rcall", "SysDiv32",                " +3:");
            GenAsm("", "mov", OperandRegReg(iReg - 8, 24), "  1:");
            GenAsm("", "mov", OperandRegReg(iReg - 7, 25), "  1:");
            GenAsm("", "mov", OperandRegReg(iReg - 6, 26), "  1:");
            GenAsm("", "mov", OperandRegReg(iReg - 5, 27), "  1:");
        }
        break;
    default:
        Error(FATAL, "GenDiv: size not supported (%d)\n", iSize);
    }

    return iReg - iSize;
}

int GenMod(int iReg, int iSize) {
    LPSTR   szModLoop = GenLabel("_ModLoop_");
    LPSTR   szModEntr = GenLabel("_ModEntr_");

    switch (iSize) {
    case 1:
        GenAsm("",        "clr",  OperandReg(25),              "  1: Mod8");
        GenAsm("",        "ldi",  OperandRegImmediate(23, 9),  "  1:");
        GenAsm("",        "rjmp", szModEntr,                   "  2:");
        GenAsm(szModLoop, "rol",  OperandReg(25),              "  1:");
        GenAsm("",        "cp",   OperandRegReg(25, iReg - 1), "  1:");
        GenAsm("",        "brcs", szModEntr,                   "1/3:");
        GenAsm("",        "sub",  OperandRegReg(25, iReg - 1), "  1:");
        GenAsm(szModEntr, "rol",  OperandReg(iReg - 2),        "  1:");
        GenAsm("",        "dec",  OperandReg(23),              "  1:");
        GenAsm("",        "brne", szModLoop,                   "  1:");
        GenAsm("",        "mov",  OperandRegReg(iReg - 2, 0),  "  1:");
        break;
    case 2:
        if ((iReg & 1) == 1) {
            GenAsm("", "movw",  OperandRegReg(24, iReg - 4), "  1: Mod16");
            GenAsm("", "movw",  OperandRegReg(26, iReg - 2), "  1:");
            GenAsm("", "rcall", "SysDiv16",                  " +3:");
            GenAsm("", "movw",  OperandRegReg(iReg - 4, 0),  "  1:");
        }
        else {
            GenAsm("", "mov",   OperandRegReg(24, iReg - 4), "  1: Mod16");
            GenAsm("", "mov",   OperandRegReg(25, iReg - 3), "  1:");
            GenAsm("", "mov",   OperandRegReg(26, iReg - 2), "  1:");
            GenAsm("", "mov",   OperandRegReg(27, iReg - 1), "  1:");
            GenAsm("", "rcall", "SysDiv16",                  " +3:");
            GenAsm("", "mov",   OperandRegReg(iReg - 4, 0),  "  1:");
            GenAsm("", "mov",   OperandRegReg(iReg - 3, 1),  "  1:");
        }
        break;
    case 4:
        if ((iReg & 1) == 1) {
            GenAsm("", "movw",  OperandRegReg(20, iReg - 8), "  1: Mod32");
            GenAsm("", "movw",  OperandRegReg(22, iReg - 6), "  1:");
            GenAsm("", "movw",  OperandRegReg(24, iReg - 4), "  1:");
            GenAsm("", "movw",  OperandRegReg(26, iReg - 2), "  1:");
            GenAsm("", "rcall", "SysDiv32",                  " +3:");
            GenAsm("", "movw",  OperandRegReg(iReg - 8, 0),  "  1:");
            GenAsm("", "movw",  OperandRegReg(iReg - 6, 2),  "  1:");
        }
        else {
            GenAsm("", "mov",   OperandRegReg(20, iReg - 8), "  1: Mod32");
            GenAsm("", "mov",   OperandRegReg(21, iReg - 7), "  1:");
            GenAsm("", "mov",   OperandRegReg(22, iReg - 6), "  1:");
            GenAsm("", "mov",   OperandRegReg(23, iReg - 5), "  1:");
            GenAsm("", "mov",   OperandRegReg(24, iReg - 4), "  1:");
            GenAsm("", "mov",   OperandRegReg(25, iReg - 3), "  1:");
            GenAsm("", "mov",   OperandRegReg(26, iReg - 2), "  1:");
            GenAsm("", "mov",   OperandRegReg(27, iReg - 1), "  1:");
            GenAsm("", "rcall", "SysDiv32",                  " +3:");
            GenAsm("", "mov",   OperandRegReg(iReg - 8, 0),  "  1:");
            GenAsm("", "mov",   OperandRegReg(iReg - 7, 1),  "  1:");
            GenAsm("", "mov",   OperandRegReg(iReg - 6, 2),  "  1:");
            GenAsm("", "mov",   OperandRegReg(iReg - 5, 3),  "  1:");
        }
        break;
    default:
        Error(FATAL, "GenMod: size not supported (%d)\n", iSize);
    }

    return iReg - iSize;
}

int GenAnd(int iReg, int iSize) {
    switch (iSize) {
    case 1:
        GenAsm("", "and", OperandRegReg(iReg - 2, iReg - 1), "  1: And8");
        break;
    case 2:
        GenAsm("", "and", OperandRegReg(iReg - 4, iReg - 2), "  1: And16");
        GenAsm("", "and", OperandRegReg(iReg - 3, iReg - 1), "  1:");
        break;
    case 4:
        GenAsm("", "and", OperandRegReg(iReg - 8, iReg - 4), "  1: And32");
        GenAsm("", "and", OperandRegReg(iReg - 7, iReg - 3), "  1:");
        GenAsm("", "and", OperandRegReg(iReg - 6, iReg - 2), "  1:");
        GenAsm("", "and", OperandRegReg(iReg - 5, iReg - 1), "  1:");
        break;
    default:
        Error(FATAL, "GenAnd: size not supported (%d)\n", iSize);
    }
    return iReg - iSize;
}

int GenXor(int iReg, int iSize) {
    switch (iSize) {
    case 1:
        GenAsm("", "eor", OperandRegReg(iReg - 2, iReg - 1), "  1: Xor8");
        break;
    case 2:
        GenAsm("", "eor", OperandRegReg(iReg - 4, iReg - 2), "  1: Xor16");
        GenAsm("", "eor", OperandRegReg(iReg - 3, iReg - 1), "  1:");
        break;
    case 4:
        GenAsm("", "eor", OperandRegReg(iReg - 8, iReg - 4), "  1: Xor32");
        GenAsm("", "eor", OperandRegReg(iReg - 7, iReg - 3), "  1:");
        GenAsm("", "eor", OperandRegReg(iReg - 6, iReg - 2), "  1:");
        GenAsm("", "eor", OperandRegReg(iReg - 5, iReg - 1), "  1:");
        break;
    default:
        Error(FATAL, "GenXor: size not supported (%d)\n", iSize);
    }
    return iReg - iSize;
}

int GenOr(int iReg, int iSize) {
    switch (iSize) {
    case 1:
        GenAsm("", "Or", OperandRegReg(iReg - 2, iReg - 1), "  1: Or8");
        break;
    case 2:
        GenAsm("", "Or", OperandRegReg(iReg - 4, iReg - 2), "  1: Or16");
        GenAsm("", "Or", OperandRegReg(iReg - 3, iReg - 1), "  1:");
        break;
    case 4:
        GenAsm("", "Or", OperandRegReg(iReg - 8, iReg - 4), "  1: Or32");
        GenAsm("", "Or", OperandRegReg(iReg - 7, iReg - 3), "  1:");
        GenAsm("", "Or", OperandRegReg(iReg - 6, iReg - 2), "  1:");
        GenAsm("", "Or", OperandRegReg(iReg - 5, iReg - 1), "  1:");
        break;
    default:
        Error(FATAL, "GenOr: size not supported (%d)\n", iSize);
    }
    return iReg - iSize;
}

int GenShiftL(int iReg, int iSize) {
    LPSTR   szRotDone = GenLabel("_LSLdone_");
    LPSTR   szRepeat = GenLabel("_LSLagain_");
    GenAsm("", "Tst",  OperandReg(iReg - 1),         "  1: Shift Left");
    GenAsm("", "breq", szRotDone,                    "2/3:");
    switch (iSize) {
    case 1:
        GenAsm(szRepeat, "lsl", OperandReg(iReg - 2), "  1: << 8");
        break;
    case 2:
        GenAsm(szRepeat, "lsl", OperandReg(iReg - 3), "  1: << 16");
        GenAsm("",       "rol", OperandReg(iReg - 2), "  1:");
        break;
    case 4:
        GenAsm(szRepeat, "lsl", OperandReg(iReg - 5), "  1: << 32");
        GenAsm("",       "rol", OperandReg(iReg - 4), "  1:");
        GenAsm("",       "rol", OperandReg(iReg - 3), "  1:");
        GenAsm("",       "rol", OperandReg(iReg - 2), "  1:");
        break;
    default:
        Error(FATAL, "GenShiftL: size not supported (%d)\n", iSize);
    }
    GenAsm("", "dec", OperandReg(iReg - 1), "  1:");
    GenAsm("", "brne", szRepeat, "2/3:");
    GenAsm(szRotDone, "", "", "---: Shift left done.");
    return iReg - 1;
}

int GenShiftR(int iReg, int iSize, BOOL fSigned) {
    LPSTR   szRotDone = GenLabel("_RSLdone_");
    LPSTR   szRepeat = GenLabel("_RSLagain_");
    GenAsm("", "Tst", OperandReg(iReg - 1), "  1: Shift Right");
    GenAsm("", "breq", szRotDone, "2/3:");
    switch (iSize) {
    case 1:
        if (fSigned) GenAsm(szRepeat, "asr", OperandReg(iReg - 2), "  1: >> 8 (signed)");
        else         GenAsm(szRepeat, "lsr", OperandReg(iReg - 2), "  1: >> 8 (unsigned)");
        break;
    case 2:
        if (fSigned) GenAsm(szRepeat, "asr", OperandReg(iReg - 2), "  1: >> 16 (signed)");
        else         GenAsm(szRepeat, "lsr", OperandReg(iReg - 2), "  1: >> 16 (unsigned)");
        GenAsm("", "ror", OperandReg(iReg - 3), "  1:");
        break;
    case 4:
        if (fSigned) GenAsm(szRepeat, "asr", OperandReg(iReg - 2), "  1: >> 32 (signed)");
        else         GenAsm(szRepeat, "lsr", OperandReg(iReg - 2), "  1: >> 32 (unsigned)");
        GenAsm("", "ror", OperandReg(iReg - 3), "  1:");
        GenAsm("", "ror", OperandReg(iReg - 4), "  1:");
        GenAsm("", "ror", OperandReg(iReg - 5), "  1:");
        break;
    default:
        Error(FATAL, "GenShiftR: size not supported (%d)\n", iSize);
    }
    GenAsm("", "dec", OperandReg(iReg - 1), "  1:");
    GenAsm("", "brne", szRepeat, "2/3:");
    GenAsm(szRotDone, "", "", "---: Shift Right done.");
    return iReg - 1;
}

// ##########################################################################
// #  Function: GenCompEQ
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenCompEQ(int iReg, int iSize) {
    LPSTR   szEqOut = GenLabel("_EqDone_");
    switch (iSize) {
    case 1: 
        GenAsm("", "sub", OperandRegReg(iReg - 2, iReg - 1), "  1: Compare EQ8");   
        break;
    case 2: 
        GenAsm("", "sub", OperandRegReg(iReg - 4, iReg - 2), "  1: Compare EQ16");
        GenAsm("", "sbc", OperandRegReg(iReg - 3, iReg - 1), "  1:");
        break;
    case 4:
        GenAsm("", "sub", OperandRegReg(iReg - 8, iReg - 4), "  1: Compare EQ32");
        GenAsm("", "sbc", OperandRegReg(iReg - 7, iReg - 3), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 6, iReg - 2), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 5, iReg - 1), "  1:");
        break;
    default:
        Error(FATAL, "GenCompEQ: size not supported (%d)\n", iSize);
    }
    iReg -= (2 * iSize);
    GenAsm("",      "breq", szEqOut,          "  1:");
    GenAsm("",      "ser",  OperandReg(iReg), "  1:");
    GenAsm(szEqOut, "inc",  OperandReg(iReg), "  1:");
    return iReg+1;
}

// ##########################################################################
// #  Function: GenCompNE
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenCompNE(int iReg, int iSize) {
    LPSTR   szNeOut = GenLabel("_NeDone_");
    switch (iSize) {
    case 1:
        GenAsm("", "sub", OperandRegReg(iReg - 2, iReg - 1), "  1: Compare NE8");
        break;
    case 2:
        GenAsm("", "sub", OperandRegReg(iReg - 4, iReg - 2), "  1: Compare NE16");
        GenAsm("", "sbc", OperandRegReg(iReg - 3, iReg - 1), "  1:");
        break;
    case 4:
        GenAsm("", "sub", OperandRegReg(iReg - 8, iReg - 4), "  1: Compare NE32");
        GenAsm("", "sbc", OperandRegReg(iReg - 7, iReg - 3), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 6, iReg - 2), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 5, iReg - 1), "  1:");
        break;
    default:
        Error(FATAL, "GenCompNe: size not supported (%d)\n", iSize);
    }
    iReg -= (2 * iSize);
    GenAsm("",      "breq", szNeOut,          "  1:");
    GenAsm("",      "clr",  OperandReg(iReg), "  1:");
    GenAsm("",      "inc",  OperandReg(iReg), "  1:");
    GenAsm(szNeOut, "",     "",               "   :");
    return iReg+1;
}

// ##########################################################################
// #  Function: GenCompLT
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenCompLT(int iReg, int iSize, BOOL fSigned) {
    LPSTR   szTrue  = GenLabel("_LtTrue_");
    LPSTR   szOut   = GenLabel("_LtOut_");
    switch (iSize) {
    case 1:
        GenAsm("", "sub", OperandRegReg(iReg - 2, iReg - 1), "  1: Compare LT8");
        break;
    case 2:
        GenAsm("", "sub", OperandRegReg(iReg - 4, iReg - 2), "  1: Compare LT16");
        GenAsm("", "sbc", OperandRegReg(iReg - 3, iReg - 1), "  1:");
        break;
    case 4:
        GenAsm("", "sub", OperandRegReg(iReg - 8, iReg - 4), "  1: Compare LT32");
        GenAsm("", "sbc", OperandRegReg(iReg - 7, iReg - 3), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 6, iReg - 2), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 5, iReg - 1), "  1:");
        break;
    default:
        Error(FATAL, "GenCompLT: size not supported (%d)\n", iSize);
    }
    iReg -= (2 * iSize);
    if (fSigned) {
        GenAsm("", "brlt", szTrue, "1/2:  signed");
    }
    else {
        GenAsm("", "brlo", szTrue, "1/2:  unsigned");
    }
    GenAsm("",     "clr",  OperandReg(iReg), "  1:");
    GenAsm("",     "rjmp", szOut,            "  1:");
    GenAsm(szTrue, "clr",  OperandReg(iReg), "  1:");
    GenAsm("",     "inc",  OperandReg(iReg), "  1:");
    GenAsm(szOut,  "",     "",               "   :");
    return iReg+1;
}

// ##########################################################################
// #  Function: GenCompLE
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenCompLE(int iReg, int iSize, BOOL fSigned) {
    LPSTR   szTrue = GenLabel("_LeTrue_");
    LPSTR   szOut = GenLabel("_LeOut_");
    switch (iSize) {
    case 1:
        GenAsm("", "sub", OperandRegReg(iReg - 1, iReg - 2), "  1: Compare LE8");
        break;
    case 2:
        GenAsm("", "sub", OperandRegReg(iReg - 2, iReg - 4), "  1: Compare LE16");
        GenAsm("", "sbc", OperandRegReg(iReg - 1, iReg - 3), "  1:");
        break;
    case 4:
        GenAsm("", "sub", OperandRegReg(iReg - 4, iReg - 8), "  1: Compare LE32");
        GenAsm("", "sbc", OperandRegReg(iReg - 3, iReg - 7), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 2, iReg - 6), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 1, iReg - 5), "  1:");
        break;
    default:
        Error(FATAL, "GenCompLE: size not supported (%d)\n", iSize);
    }
    iReg -= (2 * iSize);
    if (fSigned) {
        GenAsm("", "brge", szTrue, "1/2:  signed");
    }
    else {
        GenAsm("", "brsh", szTrue, "1/2:  unsigned");
    }
    GenAsm("", "clr", OperandReg(iReg), "  1:");
    GenAsm("", "rjmp", szOut, "  1:");
    GenAsm(szTrue, "clr", OperandReg(iReg), "  1:");
    GenAsm("", "inc", OperandReg(iReg), "  1:");
    GenAsm(szOut, "", "", "   :");
    return iReg+1;
}

// ##########################################################################
// #  Function: GenCompGT
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenCompGT(int iReg, int iSize, BOOL fSigned) {
    LPSTR   szTrue = GenLabel("_GtTrue_");
    LPSTR   szOut = GenLabel("_GtOut_");
    switch (iSize) {
    case 1:
        GenAsm("", "sub", OperandRegReg(iReg - 1, iReg - 2), "  1: Compare GT8");
        break;
    case 2:
        GenAsm("", "sub", OperandRegReg(iReg - 2, iReg - 4), "  1: Compare GT16");
        GenAsm("", "sbc", OperandRegReg(iReg - 1, iReg - 3), "  1:");
        break;
    case 4:
        GenAsm("", "sub", OperandRegReg(iReg - 4, iReg - 8), "  1: Compare GT32");
        GenAsm("", "sbc", OperandRegReg(iReg - 3, iReg - 7), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 2, iReg - 6), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 1, iReg - 5), "  1:");
        break;
    default:
        Error(FATAL, "GenCompGT: size not supported (%d)\n", iSize);
    }
    iReg -= (2 * iSize);
    if (fSigned) {
        GenAsm("", "brlt", szTrue, "1/2:  signed");
    }
    else {
        GenAsm("", "brlo", szTrue, "1/2:  unsigned");
    }
    GenAsm("", "clr", OperandReg(iReg), "  1:");
    GenAsm("", "rjmp", szOut, "  1:");
    GenAsm(szTrue, "clr", OperandReg(iReg), "  1:");
    GenAsm("", "inc", OperandReg(iReg), "  1:");
    GenAsm(szOut, "", "", "   :");
    return iReg+1;
}

// ##########################################################################
// #  Function: GenCompGE
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenCompGE(int iReg, int iSize, BOOL fSigned) {
    LPSTR   szTrue = GenLabel("_GeTrue_");
    LPSTR   szOut = GenLabel("_GeOut_");
    switch (iSize) {
    case 1:
        GenAsm("", "sub", OperandRegReg(iReg - 2, iReg - 1), "  1: Compare GE8");
        break;
    case 2:
        GenAsm("", "sub", OperandRegReg(iReg - 4, iReg - 2), "  1: Compare GE16");
        GenAsm("", "sbc", OperandRegReg(iReg - 3, iReg - 1), "  1:");
        break;
    case 4:
        GenAsm("", "sub", OperandRegReg(iReg - 8, iReg - 4), "  1: Compare GE32");
        GenAsm("", "sbc", OperandRegReg(iReg - 7, iReg - 3), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 6, iReg - 2), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 5, iReg - 1), "  1:");
        break;
    default:
        Error(FATAL, "GenCompGE: size not supported (%d)\n", iSize);
    }
    iReg -= (2 * iSize);
    if (fSigned) {
        GenAsm("", "brge", szTrue, "1/2:  signed");
    }
    else {
        GenAsm("", "brsh", szTrue, "1/2:  unsigned");
    }
    GenAsm("", "clr", OperandReg(iReg), "  1:");
    GenAsm("", "rjmp", szOut, "  1:");
    GenAsm(szTrue, "clr", OperandReg(iReg), "  1:");
    GenAsm("", "inc", OperandReg(iReg), "  1:");
    GenAsm(szOut, "", "", "   :");
    return iReg+1;
}

// ##########################################################################
// #  Function: GenCompLogicalAnd
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenCompLogicalAnd(int iReg, TPExprNode pExpr) {
    LPSTR   szFalse = GenLabel("_LAndOut_");
    iReg = GenExpr(iReg, pExpr->Use.Binary.pLeft);                                            // Left
    GenAsm("", "tst", OperandReg(iReg - 1), "  1: Logical And");              // was it FALSE
    GenAsm("", "breq", szFalse, "  1:");
    iReg = GenExpr(iReg, pExpr->Use.Binary.pRight);                                           // Right.
    GenAsm(szFalse, "", "", "   :");                                           // exit
    return iReg;
}

// ##########################################################################
// #  Function: GenCompLogicalOr
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenCompLogicalOr(int iReg, TPExprNode pExpr) {
    LPSTR   szTrue = GenLabel("_LOrOut_");
    iReg = GenExpr(iReg, pExpr->Use.Binary.pLeft);                                            // Left
    GenAsm("", "tst",  OperandReg(iReg - 1), "  1: Logical Or");              // was it TRUE
    GenAsm("", "brne", szTrue, "  1:");
    iReg = GenExpr(iReg, pExpr->Use.Binary.pRight);                                           // Right.
    GenAsm(szTrue, "", "", "   :");                                          // exit
    return iReg;
}


// ##########################################################################
// #  Function: GenExprConst
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenExprConst(int iReg, TPExprNode pExpr) {
    switch (CalcSizeOf(pExpr->pType)) {
    case 1:     return AVR_LoadImmediate8(iReg, (unsigned char)pExpr->Use.Const.lInteger);
    case 2:     return AVR_LoadImmediate16(iReg, (unsigned short)pExpr->Use.Const.lInteger);
    case 4:     return AVR_LoadImmediate32(iReg, (unsigned long)pExpr->Use.Const.lInteger);
    default:    Error(FATAL, "GenExprConst: Size?\n");
        return 0;
    }
}

// ##########################################################################
// #  Function: GenExprVar
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenExprVar(int iReg, TPExprNode pExpr) {
    if (pExpr->Use.Var.iFrameOffset == GLOBAL_VAR) {
        if ((pExpr->pType->Use.DecSpec.Qual & QualCONST) == QualCONST) {
            switch (CalcSizeOf(pExpr->pType)) {
            case 1:     return AVR_LoadRom8( iReg, pExpr->Use.Var.pszIdentifier);
            case 2:     return AVR_LoadRom16(iReg, pExpr->Use.Var.pszIdentifier);
            case 4:     return AVR_LoadRom32(iReg, pExpr->Use.Var.pszIdentifier);
            default:    Error(FATAL, "GenExprVar Rom: Size?\n");
                return 0;
            }
        }
        else {
            switch (CalcSizeOf(pExpr->pType)) {
            case 1:     return AVR_LoadRam8( iReg, pExpr->Use.Var.pszIdentifier);
            case 2:     return AVR_LoadRam16(iReg, pExpr->Use.Var.pszIdentifier);
            case 4:     return AVR_LoadRam32(iReg, pExpr->Use.Var.pszIdentifier);
            default:    Error(FATAL, "GenExprVar Ram: Size?\n");
                return 0;
            }
        }

    }
    else {
        switch (CalcSizeOf(pExpr->pType)) {
        case 1:     return AVR_LoadFrame8( iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
        case 2:     return AVR_LoadFrame16(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
        case 4:     return AVR_LoadFrame32(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
        default:    Error(FATAL, "GenExprVar frame: Size?\n");
            return 0;
        }
    }
}


// ##########################################################################
// #  Function: GenExprCast
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int SignExtend(int iReg, int iExtra) {
    char szComment[32];
    sprintf_s(szComment, sizeof(szComment), "  1: Signed extend by %d bytes", iExtra);
    GenAsm("", "mov", OperandRegReg(0, iReg - 1),  szComment);
    GenAsm("", "lsl", OperandReg(0),       "  1:");
    GenAsm("", "clr", OperandReg(0),       "  1: ");
    GenAsm("", "sbc", OperandRegReg(0, 0), "  1:");
    while (iExtra--) {
        GenAsm("", "mov", OperandRegReg(iReg++, 0), "  1:");
    }
    return iReg;
}

int UnsignExtend(int iReg, int iExtra) {
    char szComment[32];
    sprintf_s(szComment, sizeof(szComment), "  1: Unsigned extend by %d bytes", iExtra--);
    GenAsm("", "clr", OperandReg(iReg++), szComment);
    while (iExtra--) {
        GenAsm("", "clr", OperandReg(iReg++), "  1:");
    }
    return iReg;
}

static int LongToFlag(int iReg) {
    GenAsm("", "or", OperandRegReg(iReg - 4, iReg - 1), "  1: Cast Long to Flag");
    GenAsm("", "or", OperandRegReg(iReg - 4, iReg - 2), "  1:");
    GenAsm("", "or", OperandRegReg(iReg - 4, iReg - 1), "  1:");
    return iReg - 3;
}

static int ShortToFlag(int iReg) {
    GenAsm("", "or", OperandRegReg(iReg - 2, iReg - 1), "  1: Cast Short to Flag");
    return iReg - 1;
}

// ##########################################################################
// #  Function: GenExprCast
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenExprCast(int iReg, TPExprNode pExpr) {
    ASSERT(pExpr->Usage == uCast);
    iReg = GenExpr(iReg, pExpr->Use.Cast.pTarget);                        // Calculate whatever it is we are casting.
    switch (pExpr->Use.Cast.Op) {
    case Cast_c2s: return SignExtend(iReg,   (SIZE_SHORT - SIZE_CHAR));   //   signed  8 to 16
    case Cast_c2l: return SignExtend(iReg,   (SIZE_LONG - SIZE_CHAR));    //   signed  8 to 32
    case Cast_s2l: return SignExtend(iReg,   (SIZE_LONG - SIZE_SHORT));   //   signed 16 to 32
    case Cast_b2s: return UnsignExtend(iReg, (SIZE_SHORT - SIZE_CHAR));   // unsigned  8 to 16
    case Cast_b2l: return UnsignExtend(iReg, (SIZE_LONG - SIZE_CHAR));    // unsigned  8 to 32
    case Cast_u2l: return UnsignExtend(iReg, (SIZE_LONG - SIZE_SHORT));   // unsigned 16 to 32
    case Cast_l2s: return iReg - (SIZE_LONG  - SIZE_SHORT);               //          32 to 16
    case Cast_l2b: return iReg - (SIZE_LONG  - SIZE_CHAR);                //          32 to  8
    case Cast_l2f: return LongToFlag(iReg);                                //          32 to size of flag
    case Cast_s2b: return iReg - (SIZE_SHORT - SIZE_CHAR);                //          16 to  8
    case Cast_s2f: return ShortToFlag(iReg);                               //          16 to size of flag
    default:
        Error(FATAL, "GenExprCast: Unknown cast (%d)\n", pExpr->Use.Cast.Op);
        return iReg;
    }
}


// ##########################################################################
// #  Function: UnaryMinus
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static int UnaryMinus(int iReg, TPExprNode pExpr) {
    int iSize = CalcSizeOf(pExpr->pType);
    iReg = GenExpr(iReg, pExpr);                                           // Calc decendant.
    switch (iSize) {
    case 1:
        GenAsm("", "neg", OperandReg(iReg - 1),       "  1: Negate8    r = -r");
        break;
    case 2:
        GenAsm("", "clr", OperandReg(0),              "  1: Negate16    r = -r");
        GenAsm("", "sub", OperandRegReg(iReg - 2, 0), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 1, 0), "  1:");
        break;
    case 4:                 
        GenAsm("", "clr", OperandReg(0),              "  1: Negate32    r = -r");
        GenAsm("", "sub", OperandRegReg(iReg - 4, 0), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 3, 0), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 2, 0), "  1:");
        GenAsm("", "sbc", OperandRegReg(iReg - 1, 0), "  1:");
        break;
    default:
        Error(FATAL, "UnaryMinus: size not supported (%d)\n", iSize);
    }
    return iReg;
}

// ##########################################################################
// #  Function: UnaryPlus
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static int UnaryPlus(int iReg, TPExprNode pExpr) {
    int iSize = CalcSizeOf(pExpr->pType);
    iReg = GenExpr(iReg, pExpr);                                           // Calc decendant.
    return iReg;
}

// ##########################################################################
// #  Function: UnaryNeg
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static int UnaryNeg(int iReg, TPExprNode pExpr) {
    int iSize = CalcSizeOf(pExpr->pType);
    iReg = GenExpr(iReg, pExpr);                                           // Calc decendant.
    switch (iSize) {
    case 1:
        GenAsm("", "com", OperandReg(iReg - 1), "  1: Compliment8    r = ~r");
        break;
    case 2:
        GenAsm("", "com", OperandReg(iReg - 2), "  1: Compliment16   r = ~r");
        GenAsm("", "com", OperandReg(iReg - 1), "  1:");
        break;
    case 4:
        GenAsm("", "com", OperandReg(iReg - 4), "  1: Compliment32   r = ~r");
        GenAsm("", "com", OperandReg(iReg - 3), "  1:");
        GenAsm("", "com", OperandReg(iReg - 2), "  1:");
        GenAsm("", "com", OperandReg(iReg - 1), "  1:");
        break;
    default:
        Error(FATAL, "UnaryNeg: size not supported (%d)\n", iSize);
    }
    return iReg;
}

// ##########################################################################
// #  Function: UnaryNot
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static int UnaryNot(int iReg, TPExprNode pExpr) {
    LPSTR   szNotOut = GenLabel("_NotOut_");

    int iSize = CalcSizeOf(pExpr->pType);
    ASSERT(iSize == SIZE_BOOL);
    iReg = GenExpr(iReg, pExpr);                                           // Calc decendant.
    GenAsm("",       "tst",  OperandReg(iReg - 1), "  1: Invert Flag   r = !r");
    GenAsm("",       "breq", szNotOut,             "  1: ");
    GenAsm("",       "ser",  OperandReg(iReg - 1), "  1: ");
    GenAsm(szNotOut, "inc",  OperandReg(iReg - 1), "  1: ");
    return iReg;
}


// ##########################################################################
// #  Function: UnaryPtr
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static int UnaryPtr(int iReg, TPExprNode pExpr) {
    int iSize = CalcSizeOf(pExpr->pType);
    ASSERT(iSize == SIZE_PTR_DEFAULT);
    iReg = GenExpr(iReg, pExpr);                                           // Calc decendant.

    ASSERT(pExpr->pType->Usage == DecPtr);
    TPDeclSpec pTarget = pExpr->pType->Use.DecPtr.pTarget;
    if ((iReg & 1) == 0) {
        GenAsm("", "movw", OperandRegReg(30, iReg - 2),  "  1: de-ref pointer");     // even move
    }
    else {
        GenAsm("", "mov", OperandRegReg(30, iReg - 2),   "  1: de-ref pointer");     // odd move
        GenAsm("", "mov", OperandRegReg(31, iReg - 1),   "  1:");
    }
    if (IsTypeQualifierConst(pTarget)) {
        switch (CalcSizeOf(pTarget)) {
        case 1:
            GenAsm("", "lpm", OperandRegStr(iReg - 2, "Z"),  "  3: source is in ROM");
            return iReg - SIZE_PTR_DEFAULT + 1;
        case 2:
            GenAsm("", "lpm", OperandRegStr(iReg - 2, "Z+"), "  3: source is in ROM");
            GenAsm("", "lpm", OperandRegStr(iReg - 1, "Z+"), "  3:");
            return iReg - SIZE_PTR_DEFAULT + 2;
        case 4:
            GenAsm("", "lpm", OperandRegStr(iReg - 2, "Z+"), "  3: source is in ROM");
            GenAsm("", "lpm", OperandRegStr(iReg - 1, "Z+"), "  3:");
            GenAsm("", "lpm", OperandRegStr(iReg,     "Z+"), "  3:");
            GenAsm("", "lpm", OperandRegStr(iReg + 1, "Z+"), "  3:");
            return iReg - SIZE_PTR_DEFAULT + 4;
        default:
            Error(FATAL, "UnaryPtr to unknown sized object");
            return iReg;
        }
    }
    else {
        switch (CalcSizeOf(pTarget)) {
        case 1:
            GenAsm("", "ld", OperandRegStr(iReg-2, "Z"),   "  1: source is in RAM");
            return iReg - SIZE_PTR_DEFAULT + 1;
        case 2:
            GenAsm("", "ld",  OperandRegStr(iReg-2, "Z"),   "  1: source is in RAM");
            GenAsm("", "ldd", OperandRegStr(iReg-1, "Z+1"), "  2:");
            return iReg - SIZE_PTR_DEFAULT + 2;
        case 4:
            GenAsm("", "ld",  OperandRegStr(iReg-2, "Z"),   "  1: source is in RAM");
            GenAsm("", "ldd", OperandRegStr(iReg-1, "Z+1"), "  2:");
            GenAsm("", "ldd", OperandRegStr(iReg,   "Z+2"), "  2:");
            GenAsm("", "ldd", OperandRegStr(iReg+1, "Z+3"), "  2:");
            return iReg - SIZE_PTR_DEFAULT + 4;
        default:
            Error(FATAL, "UnaryPtr to unknown sized object");
            return iReg;
        }
    }
}


// ##########################################################################
// #  Function: UnaryPostInc
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static int UnaryPostInc(int iReg, TPExprNode pExpr) {
    if (pExpr->Usage == uVar) {
        if (pExpr->Use.Var.iFrameOffset == GLOBAL_VAR) {
            if ((pExpr->pType->Use.DecSpec.Qual & QualCONST) == QualCONST) {
                Error(WARNINGX, "UnaryPostInc. We can't post incerment a variable in ROM!");
                GenAsm(";", "!!!", "Post increment something in ROM", "   : No code generated. It wouldn't work!");
                return iReg;
            }
            else {
                switch (CalcSizeOf(pExpr->pType)) {
                case 1:     return AVR_LoadRam8PostInc(iReg, pExpr->Use.Var.pszIdentifier);
                case 2:     return AVR_LoadRam16PostInc(iReg, pExpr->Use.Var.pszIdentifier);
                case 4:     return AVR_LoadRam32PostInc(iReg, pExpr->Use.Var.pszIdentifier);
                default:    Error(FATAL, "UnaryPostInc Ram: Size?\n");
                    return 0;
                }
            }

        }
        else {
            switch (CalcSizeOf(pExpr->pType)) {
            case 1:     return AVR_LoadFrame8PostInc(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
            case 2:     return AVR_LoadFrame16PostInc(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
            case 4:     return AVR_LoadFrame32PostInc(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
            default:    Error(FATAL, "UnaryPostInc frame: Size?\n");
                return 0;
            }
        }
    }
    else {
        Error(FATAL, "UnaryPostInc. This one's a bit tricky. I give up.");
        return iReg;
    }
}

// ##########################################################################
// #  Function: UnaryPreInc
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static int UnaryPreInc(int iReg, TPExprNode pExpr) {
    if (pExpr->Usage == uVar) {
        if (pExpr->Use.Var.iFrameOffset == GLOBAL_VAR) {
            if ((pExpr->pType->Use.DecSpec.Qual & QualCONST) == QualCONST) {
                Error(WARNINGX, "UnaryPreInc. We can't post incerment a variable in ROM!");
                GenAsm(";", "!!!", "Pre increment something in ROM", "   : No code generated. It wouldn't work!");
                return iReg;
            }
            else {
                switch (CalcSizeOf(pExpr->pType)) {
                case 1:     return AVR_LoadRam8PreInc(iReg, pExpr->Use.Var.pszIdentifier);
                case 2:     return AVR_LoadRam16PreInc(iReg, pExpr->Use.Var.pszIdentifier);
                case 4:     return AVR_LoadRam32PreInc(iReg, pExpr->Use.Var.pszIdentifier);
                default:    Error(FATAL, "UnaryPreInc Ram: Size?\n");
                    return 0;
                }
            }

        }
        else {
            switch (CalcSizeOf(pExpr->pType)) {
            case 1:     return AVR_LoadFrame8PreInc(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
            case 2:     return AVR_LoadFrame16PreInc(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
            case 4:     return AVR_LoadFrame32PreInc(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
            default:    Error(FATAL, "UnaryPreInc frame: Size?\n");
                return 0;
            }
        }
    }
    else {
        Error(FATAL, "UnaryPreInc. This one's a bit tricky. I give up.");
        return iReg;
    }
}

// ##########################################################################
// #  Function: UnaryPostDec
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static int UnaryPostDec(int iReg, TPExprNode pExpr) {
    if (pExpr->Usage == uVar) {
        if (pExpr->Use.Var.iFrameOffset == GLOBAL_VAR) {
            if ((pExpr->pType->Use.DecSpec.Qual & QualCONST) == QualCONST) {
                Error(WARNINGX, "UnaryPostDec. We can't post incerment a variable in ROM!");
                GenAsm(";", "!!!", "Post decrement something in ROM", "   : No code generated. It wouldn't work!");
                return iReg;
            }
            else {
                switch (CalcSizeOf(pExpr->pType)) {
                case 1:     return AVR_LoadRam8PostDec(iReg, pExpr->Use.Var.pszIdentifier);
                case 2:     return AVR_LoadRam16PostDec(iReg, pExpr->Use.Var.pszIdentifier);
                case 4:     return AVR_LoadRam32PostDec(iReg, pExpr->Use.Var.pszIdentifier);
                default:    Error(FATAL, "UnaryPostDec Ram: Size?\n");
                    return 0;
                }
            }

        }
        else {
            switch (CalcSizeOf(pExpr->pType)) {
            case 1:     return AVR_LoadFrame8PostDec(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
            case 2:     return AVR_LoadFrame16PostDec(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
            case 4:     return AVR_LoadFrame32PostDec(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
            default:    Error(FATAL, "UnaryPostDec frame: Size?\n");
                return 0;
            }
        }
    }
    else {
        Error(FATAL, "UnaryPostDec. This one's a bit tricky. I give up.");
        return iReg;
    }
}

// ##########################################################################
// #  Function: UnaryPreDec
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static int UnaryPreDec(int iReg, TPExprNode pExpr) {
    if (pExpr->Usage == uVar) {
        if (pExpr->Use.Var.iFrameOffset == GLOBAL_VAR) {
            if ((pExpr->pType->Use.DecSpec.Qual & QualCONST) == QualCONST) {
                Error(WARNINGX, "UnaryPostDec. We can't post incerment a variable in ROM!");
                GenAsm(";", "!!!", "Pre decrement something in ROM", "   : No code generated. It wouldn't work!");
                return iReg;
            }
            else {
                switch (CalcSizeOf(pExpr->pType)) {
                case 1:     return AVR_LoadRam8PreDec(iReg, pExpr->Use.Var.pszIdentifier);
                case 2:     return AVR_LoadRam16PreDec(iReg, pExpr->Use.Var.pszIdentifier);
                case 4:     return AVR_LoadRam32PreDec(iReg, pExpr->Use.Var.pszIdentifier);
                default:    Error(FATAL, "UnaryPreDec Ram: Size?\n");
                    return 0;
                }
            }

        }
        else {
            switch (CalcSizeOf(pExpr->pType)) {
            case 1:     return AVR_LoadFrame8PreDec(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
            case 2:     return AVR_LoadFrame16PreDec(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
            case 4:     return AVR_LoadFrame32PreDec(iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
            default:    Error(FATAL, "UnaryPreDec frame: Size?\n");
                return 0;
            }
        }
    }
    else {
        Error(FATAL, "UnaryPreDec. This one's a bit tricky. I give up.");
        return iReg;
    }
}



// ##########################################################################
// #  Function: GenExprUnary
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static int UnaryAddr(int iReg, TPExprNode pExpr) {
    if (pExpr->Usage == uVar) {                                                             // Simple case is addr of a variable name.
        if (pExpr->Use.Var.iFrameOffset == GLOBAL_VAR) {                                    //      Global.
            GenAsm("", "ldi", OperandRegVar(30, pExpr->Use.Var.pszIdentifier), CommentString(1, "Z = ", pExpr->Use.Var.pszIdentifier));
            GenAsm("", "ldi", OperandRegVar(31, pExpr->Use.Var.pszIdentifier), "  1:");
        }
        else {                                                                              //      Frame var.
            GenAsm("", "movw", OperandRegReg(30, 28),                          CommentString(1, "Z = ", pExpr->Use.Var.pszIdentifier));
            GenAsm("", "adiw", OperandRegImmediate(30, pExpr->Use.Var.iFrameOffset), "");
        }
        if ((iReg & 1) == 0) {
            GenAsm("", "movw", OperandRegReg(iReg, 30),  "  1:");
        }
        else {
            GenAsm("", "mov", OperandRegReg(iReg, 30),   "  1:");
            GenAsm("", "mov", OperandRegReg(iReg+1, 31), "  1:");
        }
        return iReg + 2;
    }
    else {
        Error(FATAL, "UnaryAddr complicated use not implemented");
        return iReg;
    }
}


// ##########################################################################
// #  Function: GenExprUnary
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenExprUnary(int iReg, TPExprNode pExpr) {
    ASSERT(pExpr->Usage == uUnary);
    TPExprNode pN = pExpr->Use.Unary.pOperand;
    int iSize = CalcSizeOf(pN->pType);

    switch (pExpr->Use.Unary.Op) {                                                                      // Do the arithmetic. 
    case unMinus:   return UnaryMinus(iReg, pN);
    case unPlus:    return UnaryPlus(iReg, pN);
    case unNeg:     return UnaryNeg(iReg, pN);
    case unPostInc: return UnaryPostInc(iReg, pN);
    case unPreInc:  return UnaryPreInc(iReg, pN);
    case unPostDec: return UnaryPostDec(iReg, pN);
    case unPreDec:  return UnaryPreDec(iReg, pN);
    //case unSizeOf:  return UnarySizeOf(iReg, pN); // not used. optimized away into a constant.
    case unAddr:    return UnaryAddr(iReg, pN);
    case unPtr:     return UnaryPtr(iReg, pN);
    case unNot:     return UnaryNot(iReg, pN);

    default:                                                                                            //
        Error(FATAL, "GenExprUnary: Unrecognized Op Unary %d\n", pExpr->Use.Unary.Op);                  //
        return iReg;                                                                                    //
    }                                                                                                   //
}



// ##########################################################################
// #  Function: GenExprBinary
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenExprBinary(int iReg, TPExprNode pExpr) {
    ASSERT(pExpr->Usage == uBinary);

    TPExprNode pLeft = pExpr->Use.Binary.pLeft;
    TPExprNode pRight = pExpr->Use.Binary.pRight;
#pragma message("    GenExprBinary: var = const is a common special case.")
    int iLeftSize  = CalcSizeOf(pLeft->pType);
    int iRightSize = CalcSizeOf(pRight->pType);

    ASSERT((iLeftSize == iRightSize) || ((pExpr->Use.Binary.Op == AsSL) || (pExpr->Use.Binary.Op == AsSR)));    // Confirm sizes match. 

    if (pExpr->Use.Binary.Op == binLAnd) {
        ASSERT(iLeftSize == SIZE_BOOL);
        return GenCompLogicalAnd(iReg, pExpr);
    }
    if (pExpr->Use.Binary.Op == binLOr) {
        ASSERT(iLeftSize == SIZE_BOOL);
        return GenCompLogicalOr(iReg, pExpr);
    }

    iReg = GenExpr(iReg, pLeft);                                                                          // Left.
    iReg = GenExpr(iReg, pRight);                                                                         // Right.
    
    switch (pExpr->Use.Binary.Op) {                                                                             // Do the arithmetic. 
        case binAdd:  return GenAdd(iReg, iLeftSize); break;                                              //        
        case binSub:  return GenSub(iReg, iLeftSize); break;                                              //
        case binMul:  return GenMul(iReg, iLeftSize); break;                                              //
        case binDiv:  return GenDiv(iReg, iLeftSize); break;                                              //
        case binMod:  return GenMod(iReg, iLeftSize); break;                                              //
        case binAnd:  return GenAnd(iReg, iLeftSize); break;                                              //
        case binOr:   return GenOr( iReg, iLeftSize); break;                                              //
        case binXor:  return GenXor(iReg, iLeftSize); break;                                              //

        case binCEQ:  return GenCompEQ(iReg, iLeftSize); break;                                           //
        case binCNE:  return GenCompNE(iReg, iLeftSize); break;                                           //
        case binCLT:  return GenCompLT(iReg, iLeftSize, TypeIsSigned(pLeft->pType)); break;               //
        case binCLE:  return GenCompLE(iReg, iLeftSize, TypeIsSigned(pLeft->pType)); break;               //
        case binCGT:  return GenCompGT(iReg, iLeftSize, TypeIsSigned(pLeft->pType)); break;               //
        case binCGE:  return GenCompGE(iReg, iLeftSize, TypeIsSigned(pLeft->pType)); break;               //
        //case binLAnd: return GenCompLogicalAnd(hOut, iReg, iLeftSize); break;                                   //
        //case binLOr:  return GenCompLogicalOr(hOut, iReg, iLeftSize); break;                                    //

        case binShr:  return GenShiftR(iReg, iLeftSize, TypeIsSigned(pLeft->pType)); break;               //
        case binShl:  return GenShiftL(iReg, iLeftSize); break;                                           //
        default:                                                                                                //
            Error(FATAL, "GenExprBinary: Un recognized Op Binary %d\n", pExpr->Use.Binary.Op);                  //
            return iReg - iLeftSize;                                                                            //
    }                                                                                                           //
}

// ##########################################################################
// #  Function: GenExprAssign
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenExprAssign(int iReg, TPExprNode pExpr) {
    TPExprNode pLval = pExpr->Use.Assign.pLval;
    TPExprNode pRval = pExpr->Use.Assign.pRval;
#pragma message("    GenExprAssign: var = const is a common special case.")
    int iTargetSize = CalcSizeOf(pLval->pType);
    int iSourceSize = CalcSizeOf(pRval->pType);

    ASSERT((iTargetSize == iSourceSize) || ((pExpr->Use.Assign.Op == AsSL) || (pExpr->Use.Assign.Op == AsSR)));                 // confirm sizes match. 

    if (pExpr->Use.Assign.Op != AsNop) {                                                                                        // Op Assign
        iReg = GenExpr(iReg, pLval);                                                                                            //      Read/Calculate the LVAL
        iReg = GenExpr(iReg, pRval);                                                                                            //      Calculate the RVAL
                                                                                                                                //
        switch (pExpr->Use.Assign.Op) {                                                                                         //      Do the arithmetic. 
        case AsAdd:  iReg = GenAdd(iReg, iTargetSize); break;                                                                   //        
        case AsSub:  iReg = GenSub(iReg, iTargetSize); break;                                                                   //
        case AsMul:  iReg = GenMul(iReg, iTargetSize); break;                                                                   //
        case AsDiv:  iReg = GenDiv(iReg, iTargetSize); break;                                                                   //
        case AsMod:  iReg = GenMod(iReg, iTargetSize); break;                                                                   //
        case AsBAnd: iReg = GenAnd(iReg, iTargetSize); break;                                                                   //
        case AsBOr:  iReg = GenOr(iReg,  iTargetSize); break;                                                                   //
        case AsBXor: iReg = GenXor(iReg, iTargetSize); break;                                                                   //
        case AsSR:   iReg = GenShiftR(iReg, iTargetSize, TypeIsSigned(pLval->pType)); break;                                    //
        case AsSL:   iReg = GenShiftL(iReg, iTargetSize); break;                                                                //
        default:                                                                                                                //
            Error(FATAL, "Un recognized Op Assign");                                                                            //
            return iReg - iSourceSize;                                                                                          //
        }                                                                                                                       //
    }                                                                                                                           //
    else {                                                                                                                      // Simple Assign 
        iReg = GenExpr(iReg, pRval);                                                                                            //      Just do Calculate the RVAL. 
    }                                                                                                                           //

    // TOS = the new value to store
    if (IsTypeQualifierConst(pExpr->pType)) {                                                                                   // Trouble if we want to assign to a constant!
        GenAsm(";", "!!!", "write to ROM", "   : Code ommited here. The prescription is silly");                                //
        return iReg - iTargetSize;                                                                                              //
    }                                                                                                                           //

    if (pLval->Usage == uVar) {                                                                                                 // Store into a variable ?
        if (pLval->Use.Var.iFrameOffset == GLOBAL_VAR) {                                                                        //      Golbal ?                                
            switch (CalcSizeOf(pLval->pType)) {                                                                                 //
            case 1:     return AVR_StoreRam8(pLval->Use.Var.pszIdentifier, iReg- iTargetSize);                                  //
            case 2:     return AVR_StoreRam16(pLval->Use.Var.pszIdentifier, iReg - iTargetSize);                                //
            case 4:     return AVR_StoreRam32(pLval->Use.Var.pszIdentifier, iReg - iTargetSize);                                //
            default:    Error(FATAL, "GenExprAssign Ram: Size?\n");                                                             //                
                return 0;                                                                                                       //
            }                                                                                                                   //
        }                                                                                                                       //
        else {                                                                                                                  //      Frame ?
            switch (CalcSizeOf(pExpr->pType)) {                                                                                 //
            case 1:     return AVR_StoreFrame8(pLval->Use.Var.iFrameOffset, iReg - iTargetSize, pLval->Use.Var.pszIdentifier);  //
            case 2:     return AVR_StoreFrame16(pLval->Use.Var.iFrameOffset, iReg - iTargetSize, pLval->Use.Var.pszIdentifier); //
            case 4:     return AVR_StoreFrame32(pLval->Use.Var.iFrameOffset, iReg - iTargetSize, pLval->Use.Var.pszIdentifier); //
            default:    Error(FATAL, "GenExprAssign frame: Size?\n");                                                           //
                return 0;                                                                                                       //
            }
        }
    }
    else if (pLval->Usage == uUnary && pLval->Use.Unary.Op == unPtr) {
        iReg = GenExpr(iReg, pLval->Use.Unary.pOperand);                                // Calc decendant of the ptr. Expect an address as the result

        if ((iReg & 1) == 0) {
            GenAsm("", "movw", OperandRegReg(30, iReg - 2), "  1: pointer to store");     // even move
        }
        else {
            GenAsm("", "mov", OperandRegReg(30, iReg - 2), "  1: pointer to store");      // odd move
            GenAsm("", "mov", OperandRegReg(31, iReg - 1), "  1:");
        }
        switch (iTargetSize) {
        case 1:
            GenAsm("", "st", OperandStrReg("Z", iReg - 3), "  1:");
            return iReg - SIZE_PTR_DEFAULT - 1;
        case 2:
            GenAsm("", "st", OperandStrReg("Z", iReg - 4), "  1:");
            GenAsm("", "std", OperandStrReg("Z+1", iReg - 3), "  2:");
            return iReg - SIZE_PTR_DEFAULT - 2;
        case 4:
            GenAsm("", "st", OperandStrReg("Z", iReg - 6), "  1:");
            GenAsm("", "std", OperandStrReg("Z+1", iReg - 5), "  2:");
            GenAsm("", "std", OperandStrReg("Z+2", iReg - 4), "  2:");
            GenAsm("", "std", OperandStrReg("Z+3", iReg - 3), "  2:");
            return iReg - SIZE_PTR_DEFAULT - 4;
        default:
            Error(FATAL, "UnaryPtr to unknown sized object");
            return iReg;
        }
        //return iReg + iTargetSize;
    }
    else {
        Error(FATAL, "GenExprAssign: Assign to tricky destination.");
        return iReg;
    }
}

// ##########################################################################
// #  Function: GenExpr
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static int GenExpr(int iReg, TPExprNode pExpr) {
    if (!pExpr) {
        printf("..Null\n");
        Error(FATAL, "GenExpr() - NULL\n");
        return 0;
    }

    int iSize = CalcSizeOf(pExpr->pType);
    if ((iSize != 1) && (iSize != 2) && (iSize != 4)) {
        Error(FATAL, "GenExpr: Size?\n");
    }

    switch (pExpr->Usage) {
    case    uConst:   return GenExprConst(iReg, pExpr);
    case    uVar:     return GenExprVar(iReg, pExpr);
    case    uUnary:   return GenExprUnary(iReg, pExpr);
    case    uBinary:  return GenExprBinary(iReg, pExpr);
    case    uTernary:
        Error(FATAL, "GenExpr() - uTernary needs implementing\n");
        break;
    case    uDot:
        Error(FATAL, "GenExpr() - uDot needs implementing\n");
        break;
    case    uArrow:
        Error(FATAL, "GenExpr() - uArrow needs implementing\n");
        break;
    case    uArray:
        Error(FATAL, "GenExpr() - uArray needs implementing\n");
        break;
    case    uFunc:
        Error(FATAL, "GenExpr() - uFunc needs implementing\n");
        break;
    case    uCast:
        return GenExprCast(iReg, pExpr);
        break;
    case    uAssign:
        return GenExprAssign(iReg, pExpr);
        break;
    default:
        Error(FATAL, "GenExpr() - [%d]\n", pExpr->Usage);
        break;
    }
    return 0;

}

// ##########################################################################
// #  Function: GenExpression
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void    GenExpression(FILE *hFileOut, TPExprNode pExpr) {

    hGlbOut = hFileOut;

    ConsolePrintf(CON_YELLOW_BRIGHT, "Expression generation.\n");
    GenExpressionPrettyPrint(0, pExpr);
    ConsolePrintf(CON_YELLOW_BRIGHT, "\n");

    GenExpr(EXP_REG_BASE, pExpr);

}

/* eof */

