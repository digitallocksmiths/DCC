
#define _CRT_SECURE_NO_WARNINGS

//#include <conio.h>
#include <stdio.h>
//#include <ctype.h>
//#include <signal.h>
//#include <setjmp.h>
//#include <stdlib.h>
//#include <memory.h>
//#include <string.h>
#include <assert.h>
#include <Windows.h>

//#include "C_Yacced.tab.h"
#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "Gen.h"
#include "main.h"


#define GEN_PREFIX "L"
static WORD GenCount = 0;

LPSTR GenLabel(LPSTR PreFix) {
	LPSTR Label = New(strlen(GEN_PREFIX)+strlen(PreFix)+6+1);
	sprintf(Label, GEN_PREFIX "%s%06ld", PreFix, GenCount++);
	return Label;
 }


static void Pad(int n) {
    while (n>0) {
        printf(" ");
        n--;
    }
}


static void GenAsmOut(LPSTR pszLabel, LPSTR pszOpcode, LPSTR pszOperand, LPSTR pszComment, BOOL fNL) {
    int n;
    if ((pszLabel != NULL) && (*pszLabel != '\0')) { n = printf("%s:", pszLabel); }
    else { n = 0; }
    Pad(LABEL_WIDTH - n);

    if ((pszOpcode != NULL) && (*pszOpcode != '\0')) { n = printf("%s", pszOpcode); }
    else { n = 0; }
    Pad(OPCODE_WIDTH - n);

    if ((pszOperand != NULL) && (*pszOperand != '\0')) { n = printf("%s", pszOperand); }
    else { n = 0; }
    Pad(OPERAND_WIDTH - n);

    if (pszComment != NULL) {
        n = printf("; %s", pszComment);
        if (fNL) {
            printf("\n");
        }
    }
    else {
        printf("\n");
    }

}

static LPSTR sign_unsign(WORD T) {
    if ((T & TypeUNSIGNED) == TypeUNSIGNED) return "unsigned ";
    if ((T & TypeSIGNED) == TypeSIGNED)   return "signed ";
    return "";
}

BOOL GenIsData(WORD nUse) {
    switch (nUse) {
    case DecSpec:
    case DecPtr:
    case DecArray:  return TRUE;
    case DecId:
    case DecFunc:   return FALSE;
    default:
        assert(FALSE);
    }
    return FALSE;
}

#define TT(D,T) (((D) & (T)) == (T))


static void GenObjectComment(TPDeclSpec pDecl) {
    while (pDecl) {
        switch (pDecl->Usage) {
        case    DecId:          // Id
        case    DecFunc:        // Function 
            printf("GenBssObjectComment():  Unexpected Useage '%d'\n", pDecl->Usage);
            return;

        case    DecArray:
            printf("Array[%ld] of ", pDecl->Use.DecArray.Size);
            pDecl = pDecl->Use.DecArray.pTarget;
            break;

        case    DecPtr:
            switch (pDecl->Use.DecPtr.Qual) {
            case QualCONST:    printf("pointer to constant\n");  break;
            case QualVOLATILE: printf("pointer to volatile\n");  break;
            case QualNEAR:     printf("pointer to near\n");      break;
            case QualFAR:      printf("pointer to far\n");       break;
            default:           printf("pointer (generic)\n");   break;
            }
            return;

        case    DecSpec:
            if ((pDecl->Use.DecSpec.Type) & TypeSTRUCT) {
                LpStructSet p = pDecl->Use.DecSpec.pPtr;
                if (p->fUnion) printf("union '%s'\n", p->szSetName);
                else           printf("structure '%s'\n", p->szSetName);
                return;
            }
            else if ((pDecl->Use.DecSpec.Type) & TypeENUM) {
                TPEnumSet e = pDecl->Use.DecSpec.pPtr;
                printf("enum '%s'\n", e->pszSetName);
                return;
            }
            else if ((pDecl->Use.DecSpec.Type) & TypeTYPEDEF) {
                printf("typedef not yet supported\n");
                //ParseDeclSpec(pDecl->Use.DecSpec.Ptr, fDoBrothers); 
                return;
            }
            else {
                if   TT(pDecl->Use.DecSpec.Type, (TypeLONG | TypeDOUBLE))printf("long double");
                else if TT(pDecl->Use.DecSpec.Type, TypeDOUBLE)          printf("double");
                else if TT(pDecl->Use.DecSpec.Type, TypeFLOAT)           printf("float");
                else if TT(pDecl->Use.DecSpec.Type, TypeLONG)            printf("%slong", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeSHORT)           printf("%sshort ", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeINT)             printf("%sint", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeCHAR)            printf("%schar", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeSIGNED)          printf("signed");
                else if TT(pDecl->Use.DecSpec.Type, TypeUNSIGNED)        printf("unsigned");
                else if TT(pDecl->Use.DecSpec.Type, TypeVOID)            printf("void");
                else                                                     printf("unknown type 0x%04x", pDecl->Use.DecSpec.Type);

                //              DescClass(pDecl->Use.DecSpec.Class); 
                //              DescQual(pDecl->Use.DecSpec.Qual); 
                printf("\n");
            }
            return;

        default:
            printf("GenBssObjectComment(): Unknown Useage '%d'\n", pDecl->Usage);
            return;
        }
    }
}

// ##########################################################################################
// Data segment generator


static BOOL SetupConstInitializer(TPDeclSpec T, LPSTR pszOpcode, LPSTR pszOperand, LPSTR pszComment, __int64 nVal, LPSTR pszName) {

    assert(T->Usage == DecSpec || T->Usage == DecPtr);

    switch (CalcSizeOf(T)) {

    case 1: sprintf(pszOpcode, ASM_DIRECTIVE_BYTE);                                                                                     // size = byte
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED) sprintf(pszOperand, "%hhu", (unsigned char)(nVal & 0xFF));            //          unsigned
        else                                                      sprintf(pszOperand, "%hhd", (signed char)(nVal & 0xFF));              //          signed
        if (pszComment != NULL) {                                                                                                       // ? comment wanted?
            if (isprint((unsigned char)(nVal & 0xFF))) {                                                                                //
                sprintf(pszComment, "      '%c' 0x%02x -> %s", (char)nVal, (unsigned char)(nVal & 0xFF), pszName);                      //          with prontable charater
            }                                                                                                                           //                
            else {                                                                                                                      //
                sprintf(pszComment, "          0x%02x -> %s", (unsigned char)(nVal & 0xFF), pszName);                                   //          without printable character
            }                                                                                                                           //
        }                                                                                                                               //
        return TRUE;                                                                                                                    //  return happy

    case 2: sprintf(pszOpcode, ASM_DIRECTIVE_SHORT); ;                                                                                   // size = short
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED)  sprintf(pszOperand, "%hu", (unsigned short)(nVal & 0xFFFF));         //          unsigned
        else                                                       sprintf(pszOperand, "%hd", (signed short)(nVal & 0xFFFF));           //          signed
        if (pszComment != NULL) {                                                                                                       // ? comment wanted?
            sprintf(pszComment, "        0x%04x -> %s", (unsigned short)(nVal & 0xFFFF), pszName);                                       //
        }                                                                                                                               //
        return TRUE;                                                                                                                    //  return happy

    case 4: sprintf(pszOpcode, ASM_DIRECTIVE_LONG); ;                                                                                   // size = long
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED)  sprintf(pszOperand, "%u", (unsigned int)nVal);    //          unsigned
        else                                                       sprintf(pszOperand, "%d", (signed int)nVal);      //          signed
        if (pszComment != NULL) {                                                                                                       // ? comment wanted?
            sprintf(pszComment, "    0x%08x -> %s", (unsigned int)(nVal & 0xFFFFFFFFL), pszName);                                      //
        }                                                                                                                               //
        return TRUE;                                                                                                                    //  return happy

    default: sprintf(pszOpcode, "; unknown size");                                                                                      // size unknown.
        sprintf(pszOperand, "%I64u", nVal);                                                                                             // 
        if (pszComment != NULL) {                                                                                                       // 
            sprintf(pszComment, "    0x%016I64x -> %s", nVal, pszName);                                                                 // 
        }                                                                                                                               // 
        return FALSE;                                                                                                                   //  return not happy 
    }
}


static BOOL SetupVarInitializer(TPDeclSpec T, LPSTR pszOpcode, LPSTR pszOperand, LPSTR pszComment, LPSTR pszVar, LPSTR pszName) {       // when the operand is a string (no need to calculate it or look it up)

    assert(T->Usage == DecSpec || T->Usage == DecPtr);

    sprintf(pszOperand, "%s", pszVar);
    if (pszComment != NULL) {
            sprintf(pszComment, "               -> %s",  pszName);
    }

    switch (CalcSizeOf(T)) {
    case 1: sprintf(pszOpcode, ASM_DIRECTIVE_BYTE);
        break;
    case 2: sprintf(pszOpcode, ASM_DIRECTIVE_SHORT);
        break;
    case 4: sprintf(pszOpcode, ASM_DIRECTIVE_LONG);
        break;
    default: sprintf(pszOpcode, "; unknown size");
        return FALSE;
    }

    return TRUE;

}

static DWORD InitializerCount(TPExprNode pInit) {           // get the length of the initializer list.
    DWORD n = 0;
    while (pInit != 0) {
        n++;
        pInit = pInit->Use.Init.pSibling;
    }
    return n;
}

// ######################################################################################################################
static void GenDataObject(LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit);     // forward declaration for recursion in struct definitions.


                                                                                    
// ##########################################################################
// #  Function: GenDataObjectString
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void GenDataObjectString(TPDeclSpec pTarget, LPSTR pszInit, LPSTR pszName) {         // Arrays Initialized by Strings
    char szOpcode[32];
    char szOperand[32];
    char szComment[256];
    char szName[256];
    DWORD dwPadding;

    DWORD dwIndex = 0;
    assert(pTarget->Usage == DecArray);
//#pragma message("************** GenDataObjectString() where is the defined array size taken from?")



    int iNameLen = strlen(pszName);
    sprintf_s(szName, sizeof(szName), "%s[%ld]", pszName, dwIndex);

    DWORD dwArraySize = pTarget->Use.DecArray.Size;
    DWORD dwLen = strlen(pszInit)+1;                       // number of initializers
    if (dwArraySize == 0) {
        dwArraySize = dwLen;
        pTarget->Use.DecArray.Size = dwArraySize;
    }

    if (dwArraySize < dwLen) {
        //WarningGen("To many initializers", pszName);
        dwLen = dwArraySize;
    }
    dwPadding = dwArraySize - dwLen;
    
    while (dwLen--) {
        sprintf_s(&szName[iNameLen], sizeof(szName)- iNameLen, "[%ld]", dwIndex++);
        SetupConstInitializer(pTarget->Use.DecArray.pTarget, szOpcode, szOperand, szComment, *pszInit, szName);
        GenAsmOut(NULL, szOpcode, szOperand, szComment, TRUE);
        if (dwIndex == 1) {
            memset(szName, '-', iNameLen);
        }
        pszInit++;
    }

    //sprintf_s(szComment, sizeof(szComment), "               -> packed to %lu elements", dwSize);
    memset(szName, ' ', iNameLen);
    while (dwPadding--) {
        sprintf_s(&szName[iNameLen], sizeof(szName) - iNameLen, "[%ld]", dwIndex++);
        SetupConstInitializer(pTarget->Use.DecArray.pTarget, szOpcode, szOperand, szComment, 0, szName);
        GenAsmOut(NULL, szOpcode, szOperand, szComment, TRUE);
    }
}


// ##########################################################################
// #  Function: GenDataObjectPointer
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void GenDataObjectPointer(LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {                                                           // Initialized pointers

    char szOpcode[32];
    char szOperand[32];
    char szComment[64];

    szOpcode[0] = 0;
    szOperand[0] = 0;
    szComment[0] = 0;

    if (pInit != NULL) {
        assert(pInit->Usage == uInit);
        TPExprNode Val = pInit->Use.Init.pAssignment;

        if (pInit->Use.Init.pChildren != NULL) {                            // start of bracketed set when singleton is expected
            //WarningGen("Unexpected structure in initializer data for variable/field ", pszName);
            if (!SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, 0, pszName)) {
                ErrorGen("GenDataObjectPointer(): Unrecognized size of variable ", NULL);
                assert(0);
            }
        }

        if (Val->Usage == uConst) {                                                                     // Cost = OK
            unsigned __int64    nVal;
            nVal = Val->Use.Const.lInteger;
            if (!SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, nVal, pszName)) {
                ErrorGen("GenDataObjectPointer(): Unrecognized size of variable ", NULL);
                assert(FALSE);
            }
            GenAsmOut(NULL, szOpcode, szOperand, szComment, TRUE);
            return;
        }
        if ((Val->Usage == uVar) &&                                                                    // var, only if it is an array = OK.
            (Val->pType->Usage == DecArray)) {
            if (!SetupVarInitializer(pTarget, szOpcode, szOperand, szComment, Val->Use.Var.pszIdentifier, pszName)) {
                ErrorGen("GenDataObjectPointer(): Unrecognized size of variable ", NULL);
                assert(FALSE);
            }
            GenAsmOut(NULL, szOpcode, szOperand, szComment, TRUE);
            return;
        }
        if ((Val && Val->Usage == uUnary) &&                                                            // addr of var = OK
            (Val->Use.Unary.Op == Addr)) {
            TPExprNode E = Val->Use.Unary.pOperand;
            assert(E->Usage == uVar);
            if (!SetupVarInitializer(pTarget, szOpcode, szOperand, szComment, E->Use.Var.pszIdentifier, pszName)) {
                ErrorGen("GenDataObjectPointer(): Unrecognized size of variable ", NULL);
                assert(FALSE);
            }
            GenAsmOut(NULL, szOpcode, szOperand, szComment, TRUE);
            return;

        }
        ErrorGen("GenDataObjectPointer(): Non constant pointer value in initialization of ", NULL);
        assert(FALSE);
        
    }
    else {
        if (!SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, 0, pszName)) {
            ErrorGen("GenDataObjectPointer(): Unrecognized size of variable ", pszName);
            assert(FALSE);
        }

    }

    GenAsmOut(NULL, szOpcode, szOperand, szComment, TRUE);

}

// ##########################################################################
// #  Function: GenDataObjectArray
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void GenDataObjectArray(LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {                      // *** Initialized Arrays ***
    char szName[256];

    assert(pInit == NULL || pInit->Usage == uInit);
    assert(pTarget->Usage == DecArray);                                                             // we have an array for sure.

    DWORD      dwSize = pTarget->Use.DecArray.Size;
    DWORD      dwInit;
    TPDeclSpec pElement = pTarget->Use.DecArray.pTarget;
    assert(pElement != NULL);

                                                                                                    // Specical behavior when init is from a string  *** It's Complicated ! ***
    if ((pElement->Usage == DecSpec) &&                                                             // If its and array of simple types (not an array of arrays) && 
        ((pElement->Use.DecSpec.Type & TypeSTRUCT) == 0) &&                                         //    its not a structure  &&
        (pInit != NULL && pInit->Use.Init.pAssignment)) {                                           //    we also have initialization via assignment
        TPExprNode  pA = pInit->Use.Init.pAssignment;                                               //      
        if (pA->Usage == uVar) {                                                                    //      If we have an asignment from a variable
            TPDeclSpec V = FindGlobalObject(pA->Use.Var.pszIdentifier);                             //          we can find it ...
            if (V != NULL) {                                                                        //
                if (V->Usage == DecId && V->Use.DecId.pszInitializedStr != 0) {                     //          is this  variable initialized by a string.
                    assert(pTarget->Usage == DecArray);                                             //              so far so good.
                    //if (dwSize == 0) {                                                            //              if our array has no given size then
                    //    dwSize = strlen(V->Use.DecId.pszInitializedStr) + 1;                      //                  it's the string length (incl zero terminator)
                    //    pTarget->Use.DecArray.Size = dwSize;                                      //
                    //}                                                                             //
                    GenDataObjectString(pTarget, V->Use.DecId.pszInitializedStr, pszName);          //              create the initialized data from the string data.          
                    return;
                }
            }
        }
    }

    if (pInit != NULL && pInit->Use.Init.pChildren) {                                               // would expect bracketed list of initializers (but may be missing)
        pInit = pInit->Use.Init.pChildren;
    }
    dwInit = InitializerCount(pInit);                                                               // initializer count
    if (dwSize == 0) {                                                                              // if the declared count is zero
        dwSize = dwInit;                                                                            //      we use the initializers to fix up the count.
        pTarget->Use.DecArray.Size = dwSize;                                                        //
    }
    //else if (dwSize < dwInit) {                                                                     // if more initializers than we want 
    //    WarningGen("GenDataObjectArray(): Too many initializors for ", pszName);                    //      have a good moan at the user.
    //}                                                                                               //

    int iNameLen = strlen(pszName);
    sprintf_s(szName, sizeof(szName), "%s", pszName);
    for (DWORD dwIndex = 0; dwIndex < dwSize; dwIndex++) {                                          // for all the elements we want
        sprintf_s(&szName[iNameLen], sizeof(szName)-iNameLen, "[%ld]", dwIndex);                    //      text stuff to make variable name+index
        if (dwIndex == 1) {                                                                         //
            memset(szName, '-', iNameLen);                                                          //
        }                                                                                           //
                                                                                                    //
        assert(pInit == NULL || pInit->Usage == uInit);                                             //
                                                                                                    //
        GenDataObject(szName, pElement, pInit);                                                     //      recurse to define each array element            
                                                                                                    //
        //pElement = pElement->Use.DecId.pBrother;                                                  //
        if (pInit != NULL) {                                                                        //      
            pInit = pInit->Use.Init.pSibling;                                                       //      consume one initialization parameter per array element.
        }                                                                                           //
    }
}


// ##########################################################################
// #  Function: GenDataObjectUnion
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectUnion(LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {
    char szName[256];

    assert(pInit == NULL || pInit->Usage == uInit);
    assert(pTarget->Usage == DecSpec);

    LpStructSet S = pTarget->Use.DecSpec.pPtr;
    TPDeclSpec pElement = S->pElements;

    if (pInit != NULL && pInit->Use.Init.pChildren) {
        pInit = pInit->Use.Init.pChildren;
    }

    DWORD dwUnionSize = CalcSizeOf(pTarget);
    DWORD dwFirstFieldSize = 0L;

    if (pElement != NULL) {
        assert(pElement->Usage == DecId);
        dwFirstFieldSize = CalcSizeOf(pElement->Use.DecId.pTarget);
        sprintf_s(szName, sizeof(szName), "%s.%s", pszName, pElement->Use.DecId.pszName);
        GenDataObject(szName, pElement->Use.DecId.pTarget, pInit);
    }
    
    if (dwUnionSize > dwFirstFieldSize) {                                                       // if the field we generated is smaller than the union
        char szComment[256];
        DWORD dwPacking = dwUnionSize - dwFirstFieldSize;
        sprintf_s(szComment, sizeof(szComment), "               -> %s packed to size %lu", pszName, dwUnionSize);
        while (dwPacking--) {
            GenAsmOut(NULL, ASM_DIRECTIVE_BYTE, "0", szComment, TRUE);
            szComment[0] = 0;
        }
    }
}

// ##########################################################################
// #  Function: GenDataObjectStructure
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectStructure(LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {           // Structure generation.
    char szName[256];
    
    assert(pInit == NULL || pInit->Usage == uInit);
    assert(pTarget->Usage == DecSpec);

    LpStructSet S = pTarget->Use.DecSpec.pPtr;
    TPDeclSpec pElement = S->pElements;
    
    if (pInit != NULL && pInit->Use.Init.pChildren) {
        pInit = pInit->Use.Init.pChildren;
    }

    while (pElement != NULL) {
        assert(pElement->Usage == DecId);
        sprintf_s(szName, sizeof(szName), "%s.%s", pszName, pElement->Use.DecId.pszName);
        GenDataObject(szName, pElement->Use.DecId.pTarget, pInit);
        pElement = pElement->Use.DecId.pBrother;
        if (pInit != NULL) {
            pInit = pInit->Use.Init.pSibling;
        }
    }

}

// ##########################################################################
// #  Function: GenDataObjectEnum
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectEnum(LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {                        // Enum value
    char szOpcode[32];
    char szOperand[32];
    char szComment[32];

#pragma message("    **** GenDataObjectEnum(): improvement. Comment could be the enum symbol name?")
    assert(pInit->Usage == uInit);
    TPExprNode Val = pInit->Use.Init.pAssignment;

    int        nVal;
    if (Val->Usage != uConst) {
        WarningGen("GenDataObjectEnum():  Non constant interger in Enum initialization of ", NULL);
        nVal = 0;
    }
    else {
        nVal = Val->Use.Const.lInteger;
    }

    SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, nVal, pszName);
    GenAsmOut(NULL, szOpcode, szOperand, szComment, TRUE);
}

// ##########################################################################
// #  Function: GenDataObjectTypedef
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectTypedef(LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {
    ErrorGen("GenDataObjectTypedef(): Unimplemented", NULL);
    printf("Typedef\n");
}

// ##########################################################################
// #  Function: GenDataObjectBasetype
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectBasetype(LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {
    
    char szOpcode[32];
    char szOperand[32];
    char szComment[256];
    unsigned __int64   nVal = 0L;

    if (pInit != NULL) {
        assert(pInit->Usage == uInit);
       
        if (pInit->Use.Init.pChildren != NULL) {                            // start of braketed set whee singleton is expected
            // WarningGen("Unexpected structure in initializer data for variable/field ", pszName);
            nVal = 0;
        }
        else {
            TPExprNode pVal = pInit->Use.Init.pAssignment;
            assert(pVal != NULL);
            if (pVal->Usage != uConst) {
                WarningGen("GenDataObjectBasetype(): Non constant integer in initialization.", NULL);
                nVal = 0;
            }
            else {
                nVal = pVal->Use.Const.lInteger;
            }
        }
    }
    if (!SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, nVal, pszName)) {
        ErrorGen("GenDataObjectBasetype(): Unrecognized size of variable ", NULL);
    }

    GenAsmOut(NULL, szOpcode, szOperand, szComment, TRUE);
}


// ##########################################################################
// #  Function: GenDataObject
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void GenDataObject(LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {
    
    assert(pInit == NULL || pInit->Usage == uInit);

    switch (pTarget->Usage) {
        case    DecId:          // Id
        case    DecFunc:        // Function 
            printf("GenDataObject():  Unexpected Useage '%d'\n", pTarget->Usage);
            return;

        case    DecArray:
            GenDataObjectArray(pszName, pTarget, pInit);
            return;

        case    DecPtr:
            GenDataObjectPointer(pszName, pTarget, pInit);
            return;

        case    DecSpec:
            // consider using BOOL IsIntegralType()????
            if ((pTarget->Use.DecSpec.Type) & TypeSTRUCT) {
                LpStructSet p = pTarget->Use.DecSpec.pPtr;
                if (p->fUnion) GenDataObjectUnion(pszName, pTarget, pInit);
                else           GenDataObjectStructure(pszName, pTarget, pInit);
                return;
            }
            else if ((pTarget->Use.DecSpec.Type) & TypeENUM) {
                TPEnumSet e = pTarget->Use.DecSpec.pPtr;
                GenDataObjectEnum(pszName, pTarget, pInit);
                return;
            }
            else if ((pTarget->Use.DecSpec.Type) & TypeTYPEDEF) {
                GenDataObjectTypedef(pszName, pTarget, pInit);
                return;
            }
            else {
                GenDataObjectBasetype(pszName, pTarget, pInit);
                return;
            }
            return;

        default:
            printf("GenDataObject(): Unknown Useage '%d'\n", pTarget->Usage);
            return;
        }

}


// ##########################################################################
// #  Function: GenData
// #        *public* <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void    GenConst(TPDeclSpec pDecl) {
    //char szOperand[32];
    TPDeclSpec pDeclList;

    GenAsmOut(NULL, ASM_DIRECTIVE_SEGMENT_BEGIN, "CONST", "=== Start of CONST segment ===", TRUE);

    for (pDeclList = pDecl; pDeclList; pDeclList = pDeclList->pChain) {                                 // auto generated string initializers
        if ((pDeclList->Usage == DecId) &&                                                              // Must be DecId
            GenIsData(pDeclList->Use.DecId.pTarget->Usage) &&                                           // Id's use must be storage rather than definition or code.
            (pDeclList->Use.DecId.pszInitializedStr)) {                                                 // If sz pointer used here it's an auto-gen string.

            TPDeclSpec pTarget = pDeclList->Use.DecId.pTarget;
            assert(pTarget->Usage == DecArray);
#pragma message ("************ filter out initializers used to initiialize arrays and keep ones used as pointer destinations.")
            GenAsmOut(pDeclList->Use.DecId.pszName, NULL, NULL, "", FALSE);
            GenObjectComment(pTarget);
            GenDataObjectString(pTarget, pDeclList->Use.DecId.pszInitializedStr, "");
        }
    }

    for (pDeclList = pDecl; pDeclList; pDeclList = pDeclList->pChain) {
        if ((pDeclList->Usage == DecId) &&
            GenIsData(pDeclList->Use.DecId.pTarget->Usage) &&
            (pDeclList->Use.DecId.pInitializer)) {

            TPDeclSpec pTarget = pDeclList->Use.DecId.pTarget;
            assert(pTarget);
            if (IsTypeQualifierConst(pTarget)) {
                GenAsmOut(pDeclList->Use.DecId.pszName, NULL, NULL, "", FALSE);
                GenObjectComment(pTarget);
                GenDataObject(pDeclList->Use.DecId.pszName, pTarget, pDeclList->Use.DecId.pInitializer);
            }
        }
    }

    GenAsmOut(NULL, ASM_DIRECTIVE_SEGMENT_END, NULL, "=== End of CONST segment ===\n", TRUE);

}


// ##########################################################################
// #  Function: GenData
// #        *public* <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenData(TPDeclSpec pDecl) {
    //char szOperand[32];
    TPDeclSpec pDeclList;

    GenAsmOut(NULL, ASM_DIRECTIVE_SEGMENT_BEGIN, "DATA", "=== Start of DATA segment ===", TRUE);

    for (pDeclList = pDecl; pDeclList; pDeclList = pDeclList->pChain) {
        if ((pDeclList->Usage == DecId) &&
            GenIsData(pDeclList->Use.DecId.pTarget->Usage) &&
            (pDeclList->Use.DecId.pInitializer)) {

            TPDeclSpec pTarget = pDeclList->Use.DecId.pTarget;

            assert(pTarget);
            if (!IsTypeQualifierConst(pTarget)) {
                GenAsmOut(pDeclList->Use.DecId.pszName, NULL, NULL, "", FALSE);
                GenObjectComment(pTarget);
                GenDataObject(pDeclList->Use.DecId.pszName, pTarget, pDeclList->Use.DecId.pInitializer);
            }
        }
    }

    GenAsmOut(NULL, ASM_DIRECTIVE_SEGMENT_END, NULL, "=== End of DATA segment ===\n", TRUE);

}

// ##########################################################################################
// Bss segment generator


// ##########################################################################
// #  Function: GenBss
// #        *public* <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenBss(TPDeclSpec pDecl) {
    char szOperand[32];

    GenAsmOut(NULL, ASM_DIRECTIVE_SEGMENT_BEGIN, "BSS", "=== Start of BSS segment ===", TRUE);

    for (; pDecl; pDecl = pDecl->pChain) {
        if ((pDecl->Usage == DecId) &&
            GenIsData(pDecl->Use.DecId.pTarget->Usage) &&
            !(pDecl->Use.DecId.pszInitializedStr || pDecl->Use.DecId.pInitializer)) {
            sprintf(szOperand, "%4d", CalcSizeOf(pDecl->Use.DecId.pTarget));
            GenAsmOut(pDecl->Use.DecId.pszName, ASM_DIRECTIVE_SPACE, szOperand, "", FALSE);
            GenObjectComment(pDecl->Use.DecId.pTarget);
        }
    }

    GenAsmOut(NULL, ASM_DIRECTIVE_SEGMENT_END, NULL, "=== End of BSS segment ===\n", TRUE);
}

/* eof */
