
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <setjmp.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <limits.h>
#include <float.h>
#include <Windows.h>

//#include <ext\types.h>
#include "Utilities\Console.h"

#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "gen.h"
#include "main.h"
#include "C_Yacced.tab.h"

/*
// ############################################################
#define GEN_PREFIX "L"
static DWORD GenCount = 0;

LPSTR
GenLabel(LPSTR PreFix) {
    LPSTR Label = New(strlen(GEN_PREFIX)+strlen(PreFix)+6+1);
    sprintf(Label, GEN_PREFIX "%s%06ld", PreFix, GenCount++);
    return Label;
 }
*/

/* ******************************************************* */
/*  General Expression Housekeeping  */
/* ********************************* */

static TPExprNode
NewExprNode(ExprUsage Use) {
    TPExprNode NewEl;
    NewEl = New(sizeof(TExprNode));
    NewEl->Usage    = Use;
    NewEl->pType    = NULL;
    NewEl->pSibling = NULL;
    return NewEl;
 }

TPExprNode
ExprMakeConstC(LONG Value) {
    TPExprNode New;
    New = NewExprNode(uConst);
    New->pType = NewSpecType(TypeCHAR,NULL);
    New->Use.Const.lInteger = Value;
    return New;
 }

TPExprNode
ExprMakeConstI(LONG Value) {
    TPExprNode New;
    New = NewExprNode(uConst);
    if      ((SCHAR_MIN <= Value) && (Value <= SCHAR_MAX)) New->pType = NewSpecType(TypeSIGNED|  TypeCHAR, NULL);
    else if ((0 <= Value)         && (Value <= UCHAR_MAX)) New->pType = NewSpecType(TypeUNSIGNED|TypeCHAR, NULL);
    else if ((SHRT_MIN <= Value)  && (Value <= SHRT_MAX))  New->pType = NewSpecType(TypeSIGNED|  TypeSHORT,NULL);
    else if ((0 <= Value)         && (Value <= USHRT_MAX)) New->pType = NewSpecType(TypeUNSIGNED|TypeSHORT,NULL);
    else if ((LONG_MIN <= Value)  && (Value <= LONG_MAX))  New->pType = NewSpecType(TypeSIGNED|  TypeLONG, NULL);
    else                                                   New->pType = NewSpecType(TypeUNSIGNED|TypeLONG, NULL);
    New->Use.Const.lInteger = Value;
    return New;
 }

TPExprNode
ExprMakeConstF(DOUBLE Value) {
    Error(WARNING0, "Floating point numbers are not supported.");
    return ExprMakeConstI((LONG)Value);
 }

TPExprNode
ExprMakeConstS(LPSTR Str) {
    LPSTR Lab = GenLabel("Str");
    TPDeclSpec p;
    p = NewIdentifier(Lab);
    p = NewArray(p,NULL);
    p->Use.DecId.pTarget->Use.DecArray.Size = strlen(Str)+1;
    p = AddInitializerStr(p,Str);
    p = AppendDecl(p,NewSpecType(TypeCHAR,NULL));
    Declaration(p);
    return ExprMakeVar(Lab);
 }

TPExprNode ExprMakeVar(LPSTR Variable) {                                        // new node to read a variable
    TPExprNode New;
    TPDeclSpec V;
    New = NewExprNode(uVar);                                                    // new variable node
    V   = FindLocalObject(Variable);                                            // is it a local?
    if (!V) {                                                                   // if not then is it a global ?
        V = FindParameterObject(Variable);                                         //
    }                                                                           //
    if (!V) {                                                                   // if not then is it a global ?
        V = FindGlobalObject(Variable);                                         //
    }                                                                           //
    if (!V) {                                                                   // if not then it's an unidentified variable
        Error(ERROR0, "Unknown Variable '%s'.",Variable);
        New->pType = NewSpecType(TypeINT,NULL);
    } else {
        New->pType = V->Use.DecId.pTarget;                                      // type is defined here.
    }
    New->Use.Var.pszIdentifier = Variable;                                      // the name is recorded here. 
    return New;
 }

/* *************************************************** */

#define IsStruct(n)    (((n)->Usage == DecSpec) &&  ((n)->Use.DecSpec.Type & TypeSTRUCT))
#define IsSimple(n)    (((n)->Usage == DecSpec) && !((n)->Use.DecSpec.Type & TypeSTRUCT))
#define IsPointer(n)    ((n)->Usage == DecPtr)
#define IsArray(n)      ((n)->Usage == DecArray)
#define IsFunc(n)       ((n)->Usage == DecFunc)
#define IsReference(n)  (IsPointer(n) || IsArray(n))
#define IsPtrStruct(n)  (IsPointer(n) && IsStruct((n)->Use.DecPtr.pTarget))

/* *************************************************** */
      
TDeclSpec    Std_Ubyte   = { DecSpec, NULL, { 0, TypeUNSIGNED|TypeCHAR, 0, NULL } } ;
TDeclSpec    Std_Sbyte   = { DecSpec, NULL, { 0, TypeSIGNED|TypeCHAR,   0, NULL } } ;
TDeclSpec    Std_Uword   = { DecSpec, NULL, { 0, TypeUNSIGNED|TypeSHORT,0, NULL } } ;
TDeclSpec    Std_Sword   = { DecSpec, NULL, { 0, TypeSIGNED|TypeSHORT,  0, NULL } } ;
TDeclSpec    Std_Ulong   = { DecSpec, NULL, { 0, TypeUNSIGNED|TypeLONG, 0, NULL } } ;
TDeclSpec    Std_Slong   = { DecSpec, NULL, { 0, TypeSIGNED|TypeLONG,   0, NULL } } ;

TPDeclSpec  LpStd_Ubyte = &Std_Ubyte;
TPDeclSpec  LpStd_Sbyte = &Std_Sbyte;
TPDeclSpec  LpStd_Uword = &Std_Uword;
TPDeclSpec  LpStd_Sword = &Std_Sword;
TPDeclSpec  LpStd_Ulong = &Std_Ulong;
TPDeclSpec  LpStd_Slong = &Std_Slong;




//static LpExprNode
//Cast(LpExprNode Left, LpDeclSpec Newtype) {
//#pragma message("Cast:  insert convert operand size code.")
//    return Left;
//}

///* ************************************************************ */
///*  pointer and node return the smallest integral pointer type  */
///* ************************************************************ */
//
//static LpDeclSpec
//CastToValidPointer(LpDeclSpec Ptr) {
//    if      (CalcSizeOf(Ptr) <= SIZE_CHAR)  return NewSpecType(TypeUNSIGNED|TypeCHAR,NULL);
//    else if (CalcSizeOf(Ptr) <= SIZE_SHORT) return NewSpecType(TypeUNSIGNED|TypeSHORT,NULL);
//    else                                    return NewSpecType(TypeUNSIGNED|TypeLONG,NULL);
//}

///* ************************************************************ */
///*  Make a binary node and insert the required castings         */
///* ************************************************************ */
//
//static LpExprNode
//FixCastings(LpExprNode New, LpExprNode Left, LpExprNode Right) {
//    if (!CompDecl(New->Type,Left->Type))  Left = MakeCastNode(New->Type, Left);
//    if (!CompDecl(New->Type,Right->Type)) Right= MakeCastNode(New->Type, Right);
//    New->Use.Binary.Left  = Left;
//    New->Use.Binary.Right = Right;
//    return New;
// }

/* ************************************************** */
/*  Unary  */
/* ******* */

static TPExprNode
NewUnary(WORD Op,  TPExprNode Node) {
    TPExprNode New;
    New = NewExprNode(uUnary);
    New->Use.Unary.Op = Op;             // operation  
    New->Use.Unary.pOperand = Node;      // target of operation
    New->pType = Node->pType;             // assume no change in type.
    return New;
 }
 
static TPExprNode
UMinus(TPExprNode Node) {
    TPExprNode New;
    if (!IsSimple(Node->pType)) {
        Error(WARNING0, "Unary arithmetic is only posible on simple types.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Node->Use.Const.lInteger = -(Node->Use.Const.lInteger);
        return Node;
    } else {
        New = NewUnary(Minus, Node);
        return  New;
    }
 }
 
static TPExprNode
UPlus(TPExprNode Node) {
    if (!IsSimple(Node->pType)) {
        Error(WARNING0, "Unary arithmetic is only posible on simple types.");
        return Node;
    }
    return Node;
 }
 
static TPExprNode
UNeg(TPExprNode Node) {
    TPExprNode New;
    if (!IsSimple(Node->pType)) {
        Error(WARNING0, "Unary arithmetic is only posible on simple types.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Node->Use.Const.lInteger = ~(Node->Use.Const.lInteger);
        return Node;
    } else {
        New = NewUnary(Neg, Node);
        return  New;
    }
 }
 
static TPExprNode
UNot(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Error(WARNING0, "Unary logic is not possible on struct/union.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Node->Use.Const.lInteger = !(Node->Use.Const.lInteger);
        return Node;
    } else {
        New = NewUnary(Not, Node);
        New->pType = LpStd_Ubyte;
        return  New;
    }
 }
 
static TPExprNode
UPostInc(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Error(WARNING0, "Cannot perform '++'/'--' on a structure.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error(ERROR0, "'++' or '--' on a Constant is bit dumb.");
        return Node;
    } else {
        New = NewUnary(PostInc, Node);
        return  New;
    }
 }
 
static TPExprNode
UPreInc(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Error(WARNING0, "Cannot perform '++'/'--' on a structure.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error(ERROR0, "'++' or '--' on a Constant is bit dumb.");
        return Node;
    } else {
        New = NewUnary(PreInc, Node);
        return  New;
    }
 }
 
static TPExprNode
UPostDec(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Error(WARNING0, "Cannot perform '++'/'--' on a structure.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error(ERROR0, "'++' or '--' on a Constant is bit dumb.");
        return Node;
    } else {
        New = NewUnary(PostDec, Node);
        return  New;
    }
 }
 
static TPExprNode
UPreDec(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Error(WARNING0, "Cannot perform '++'/'--' on a structure.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error(ERROR0, "'++' or '--' on a Constant is bit dumb.");
        return Node;
    } else {
        New = NewUnary(PreDec, Node);
        return  New;
    }
 }
 
static TPExprNode
USizeof(TPExprNode Node) {
    return ExprMakeConstI(CalcSizeOf(Node->pType));
 }
 
static TPExprNode
UAddr(TPExprNode Node) {
    TPExprNode New;
    if (Node->Usage == uConst)  {
        Error(ERROR0, "Address of constant is meaningless.");
        return Node;
    } else {
        New = NewUnary(Addr, Node);
        New->pType = NewPointer(NULL,Node->pType);
        return  New;
    }
 }

                          
static TPExprNode
UPtr(TPExprNode Node) {
    TPExprNode New;
    if (Node->pType->Usage == DecPtr) {
        New = NewUnary(Ptr, Node);
        New->pType = Node->pType->Use.DecPtr.pTarget;
        return  New;
    } else if (Node->pType->Usage == DecArray) {
        New = NewUnary(Ptr, Node);
        New->pType = Node->pType->Use.DecArray.pTarget;
        return  New;
    } else {
        Error(ERROR0, "De-Reference of a Non pointer type.");
        return Node;
    }
 }


TPExprNode
ExprMakeUnaryNode(TIdExprUnOp Op,  TPExprNode Node) {
    switch (Op) {
        case    Minus:      return UMinus(Node);
        case    Plus:       return UPlus(Node);
        case    Neg:        return UNeg(Node);
        case    Not:        return UNot(Node);
        case    PostInc:    return UPostInc(Node);
        case    PreInc:     return UPreInc(Node);
        case    PostDec:    return UPostDec(Node);
        case    PreDec:     return UPreDec(Node);
        case    SizeOf:     return USizeof(Node);
        case    Addr:       return UAddr(Node);
        case    Ptr:        return UPtr(Node);
        default:            Error(FATAL, "MakeUnaryNode(): UnKnown Unary Operator %d\n", Op);
                            return Node;
    }
 }

/* ************************************************** */
/*  Binary  */
/* ******** */

static TPDeclSpec
ResultingType(TPDeclSpec Left, TPDeclSpec Right) {
#pragma message("ResultingType: calculate result of combination.")
    return Left;
}


static TPExprNode
NewBinary(WORD Op,  TPExprNode Left, TPExprNode Right) {
    TPExprNode New;
    New = NewExprNode(uBinary);
    New->Use.Binary.Op    = Op;                         // operation  
    New->Use.Binary.pLeft  = Left;                       // target of operation
    New->Use.Binary.pRight = Right;                      // target of operation
    New->pType = ResultingType(Left->pType,Right->pType);  // assume no change in type.
    return New;
 }

static TPExprNode Badd (TPExprNode Left, TPExprNode Right);
static TPExprNode Bsub (TPExprNode Left, TPExprNode Right);
static TPExprNode Bmul (TPExprNode Left, TPExprNode Right);
static TPExprNode Bdiv (TPExprNode Left, TPExprNode Right);
static TPExprNode Bmod (TPExprNode Left, TPExprNode Right);
static TPExprNode Bband(TPExprNode Left, TPExprNode Right);
static TPExprNode Bbor (TPExprNode Left, TPExprNode Right);
static TPExprNode Bbxor(TPExprNode Left, TPExprNode Right);
static TPExprNode Bceq (TPExprNode Left, TPExprNode Right);
static TPExprNode Bcne (TPExprNode Left, TPExprNode Right);
static TPExprNode Bclt (TPExprNode Left, TPExprNode Right);
static TPExprNode Bcle (TPExprNode Left, TPExprNode Right);
static TPExprNode Bcgt (TPExprNode Left, TPExprNode Right);
static TPExprNode Bcge (TPExprNode Left, TPExprNode Right);
static TPExprNode Bland(TPExprNode Left, TPExprNode Right);
static TPExprNode Blor (TPExprNode Left, TPExprNode Right);
static TPExprNode Bbsr (TPExprNode Left, TPExprNode Right);
static TPExprNode Bbsl (TPExprNode Left, TPExprNode Right);



static TPExprNode
Badd (TPExprNode Left, TPExprNode Right) {
    TPExprNode New;
    TPDeclSpec NewType;
    if (IsStruct(Left->pType) || IsStruct(Right->pType)) {
        Error(ERROR0, "Addition of Structures is not possible.");
        return Left;
    }
    if (IsReference(Left->pType) && IsReference(Right->pType)) {
        Error(ERROR0, "Addition of References is not possible.");
        return Left;
    }
    if (IsSimple(Left->pType) && IsReference(Right->pType)) {
        New   = Right;
        Right = Left;
        Left  = New;
        /* fall through (then pass) next test */
    }
    if (IsReference(Left->pType) && IsSimple(Right->pType)) {
        if (IsPointer(Left->pType)) Right = Bmul(Right, ExprMakeConstI(CalcSizeOf(Left->pType->Use.DecPtr.pTarget)));
        else                       Right = Bmul(Right, ExprMakeConstI(CalcSizeOf(Left->pType->Use.DecArray.pTarget)));
        /* fall through to simple add */
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger += Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Add")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType, Left);
        Right   = ExprMakeCastNode(NewType, Right);
        return NewBinary(Add,Left,Right);
    }
 }

static TPExprNode
Bsub (TPExprNode Left, TPExprNode Right) {
    TPExprNode New;
    TPDeclSpec NewType;
    if (IsStruct(Left->pType) || IsStruct(Right->pType)) {
        Error(ERROR0, "Subtraction of Structures is not possible.");
        return Left;
    }
    if (IsReference(Left->pType) && IsReference(Right->pType)) {
        if (!CompDecl(Left->pType, Right->pType)) {
            Error(ERROR0, "Subtraction of dissimilar references is not possible.");
            return Left;
        }
        if (Left->Usage == uConst && Right->Usage == uConst) {
            Left->Use.Const.lInteger -= Right->Use.Const.lInteger;
            Left->Use.Const.lInteger /= CalcSizeOf(Right->pType->Use.DecPtr.pTarget);
            switch(CalcSizeOf(Left->pType)) {
                case 1: Left = ExprMakeCastNode(LpStd_Ubyte, Left); break;
                case 2: Left = ExprMakeCastNode(LpStd_Uword, Left); break;
                default:Left = ExprMakeCastNode(LpStd_Ulong, Left); break;
            }
            ExprCleanUp(Right);
            return Left;
        } else {
            New = NewBinary(Sub,Left,Right);
            New = NewBinary(Div,New,ExprMakeConstI(CalcSizeOf(Left->pType->Use.DecArray.pTarget)));
            switch(CalcSizeOf(New->pType)) {
                case 1: New = ExprMakeCastNode(LpStd_Ubyte, New); break;
                case 2: New = ExprMakeCastNode(LpStd_Uword, New); break;
                default:New = ExprMakeCastNode(LpStd_Ulong, New); break;
            }
            return New;
        }
    }
    if (IsReference(Right->pType)) {
        Error(ERROR0, "Subtraction of a reference is not possible.");
        return Left;
    }
    if (IsReference(Left->pType) && IsSimple(Right->pType)) {
        if (IsPointer(Left->pType)) Right = Bmul(Right, ExprMakeConstI(CalcSizeOf(Left->pType->Use.DecPtr.pTarget)));
        else                       Right = Bmul(Right, ExprMakeConstI(CalcSizeOf(Left->pType->Use.DecArray.pTarget)));
        /* fall through to simple sub */
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger -= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Sub")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(Sub,Left,Right);
    }
 }

static TPExprNode
Bmul (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Multiplication of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger   *= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Mul")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(Mul,Left,Right);
    }
 }

static TPExprNode
Bdiv (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Division of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger /= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Div")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(Div,Left,Right);
    }
 }


static TPExprNode
Bmod (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Modulus of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger %= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Mod")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(Mod,Left,Right);
    }
 }


static TPExprNode
Bband(TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Bitwise-And of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger &= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize And")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(BAnd,Left,Right);
    }
 }

static TPExprNode
Bbor (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Bitwise-Or of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger |= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Or")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(BOr,Left,Right);
    }
 }

static TPExprNode
Bbxor(TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Bitwise-Xor of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger ^= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Xor")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(BXor,Left,Right);
    }
 }

static TPExprNode
Bbsr (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Shift-Right of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger >>= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize >>")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(BSR,Left,Right);
    }
 }

static TPExprNode
Bbsl (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Shift-Left of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger <<= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize <<")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(BSL,Left,Right);
    }
 }

static TPExprNode
Bceq (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {
        Error(ERROR0, "Comparison of structures is not possible.");                                           
        return Left;
    }                                                                                                      
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                             
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                          
            Error(ERROR0, "Comparison a reference to a non-reference is not possible.");                     
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger == Right->Use.Const.lInteger) ? TRUE : FALSE;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize ==")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(CEQ,Left,Right);
    }
}

static TPExprNode
Bcne (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {
        Error(ERROR0, "Comparison of structures is not possible.");
        return Left;
    }
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {
            Error(ERROR0, "Comparison a reference to a non-reference is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger != Right->Use.Const.lInteger) ? TRUE : FALSE;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize !=")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(CNE,Left,Right);
    }
}                                                                                                          

static TPExprNode
Bclt (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                  \
       Error(ERROR0, "Comparison of structures is not possible.");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                             \
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                          \
            Error(ERROR0, "Comparison a reference to a non-reference is not possible.");                     \
            return Left;                                                                                   \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger < Right->Use.Const.lInteger) ? TRUE : FALSE;        \
        ExprCleanUp(Right);                                                                                        \
        return Left;
    } else {
#pragma message("Optimize <")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(CLT,Left,Right);
    }
}                                                                                                          \

static TPExprNode
Bcle (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                  \
        Error(ERROR0, "Comparison of structures is not possible.");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                             \
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                          \
            Error(ERROR0, "Comparison a reference to a non-reference is not possible.");                     \
            return Left;                                                                                   \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger <= Right->Use.Const.lInteger) ? TRUE : FALSE;        \
        ExprCleanUp(Right);                                                                                        \
        return Left;
    } else {
#pragma message("Optimize <=")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(CLE,Left,Right);
    }
}                                                                                                          \

static TPExprNode
Bcgt (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                  \
       Error(ERROR0, "Comparison of structures is not possible.");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                             \
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                          \
            Error(ERROR0, "Comparison a reference to a non-reference is not possible.");                     \
            return Left;                                                                                   \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger > Right->Use.Const.lInteger) ? TRUE : FALSE;        \
        ExprCleanUp(Right);                                                                                        \
        return Left;
    } else {
#pragma message("Optimize >")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(CGT,Left,Right);
    }
}                                                                                                          \

static TPExprNode
Bcge (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                  \
       Error(ERROR0, "Comparison of structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                             \
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                          \
            Error(ERROR0, "Comparison a reference to a non-reference is not possible.");                     \
            return Left;                                                                                   \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger >= Right->Use.Const.lInteger) ? TRUE : FALSE;        \
        ExprCleanUp(Right);                                                                                        \
        return Left;
    } else {
#pragma message("Optimize >=")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(CGE,Left,Right);
    }
}                                                                                                          \



static TPExprNode
Bland(TPExprNode Left, TPExprNode Right) {
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                  \
       Error(ERROR0, "Logical Operations on structures is not possible.");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger = Left->Use.Const.lInteger && Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        Left->pType = LpStd_Ubyte;
        return Left;
    } else {
#pragma message("Optimize &&")
        Left    = ExprMakeCastNode(LpStd_Ubyte,Left);
        Right   = ExprMakeCastNode(LpStd_Ubyte,Right);
        return NewBinary(LAnd,Left,Right);
    }
}                                                                                                          \

static TPExprNode
Blor (TPExprNode Left, TPExprNode Right) {
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                  \
       Error(ERROR0, "Logical Operations on structures is not possible.");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger = Left->Use.Const.lInteger || Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        Left->pType = LpStd_Ubyte;
        return Left;
    } else {
#pragma message("Optimize ||")
        Left    = ExprMakeCastNode(LpStd_Ubyte,Left);
        Right   = ExprMakeCastNode(LpStd_Ubyte,Right);
        return NewBinary(LOr,Left,Right);
    }
}


TPExprNode
ExprMakeBinaryNode(TIdExprBiOp Op, TPExprNode Left, TPExprNode Right) {
    switch (Op) {
        case    Add:    return Badd (Left,Right);
        case    Sub:    return Bsub (Left,Right);
        case    Mul:    return Bmul (Left,Right);
        case    Div:    return Bdiv (Left,Right);
        case    Mod:    return Bmod (Left,Right);
        case    BAnd:   return Bband(Left,Right);
        case    BOr:    return Bbor (Left,Right);
        case    BXor:   return Bbxor(Left,Right);
        case    CEQ:    return Bceq (Left,Right);
        case    CNE:    return Bcne (Left,Right);
        case    CLT:    return Bclt (Left,Right);
        case    CLE:    return Bcle (Left,Right);
        case    CGT:    return Bcgt (Left,Right);
        case    CGE:    return Bcge (Left,Right);
        case    LAnd:   return Bland(Left,Right);
        case    LOr:    return Blor (Left,Right);
        case    BSR:    return Bbsr (Left,Right);
        case    BSL:    return Bbsl (Left,Right);
        default:        Error(FATAL, "MakeBinaryNode: UnKnown Binary Operator %d\n", Op);
                        return Left;
    }
 }



/* ************************************************** */
/*  Ternary  */
/* ********* */

TPExprNode
TernaryCondExp(TPExprNode First, TPExprNode Second, TPExprNode Third) {
    TPExprNode New;
    if (First->Usage == uConst) {
        if (First->Use.Const.lInteger) {
            ExprCleanUp(First);
            ExprCleanUp(Third);
            return Second;
        } else {
            ExprCleanUp(First);
            ExprCleanUp(Second);
            return Third;
        }
    }
    New = NewExprNode(uTernary);
    New->pType = ResultingType(Second->pType,Third->pType);
    New->Use.Ternary.Op     = CondExp;
    New->Use.Ternary.First  = First;
    New->Use.Ternary.Second = ExprMakeCastNode(New->pType,Second);
    New->Use.Ternary.Third  = ExprMakeCastNode(New->pType,Third);
    return New;
 }

TPExprNode
ExprMakeTernaryNode(TIdExprTriOp Op,  TPExprNode First, TPExprNode Second, TPExprNode Third) {
    switch (Op) {
        case  CondExp:  return TernaryCondExp(First,Second,Third);
                        break;
        default:        Error(FATAL, "MakeTernaryNode: UnKnown Ternary Operator %d\n", Op);
                        return First;
    }
}



/* *************************************************************************** */
/*  Action Nodes                                                               */
/*  need some run time action to be performed in order to determin the result  */
/* *************************************************************************** */


    

TPExprNode
ExprMakeDotNode(TPExprNode Left,  LPSTR Field) {
    TPExprNode New;
    if (!IsStruct(Left->pType)) {
        Error(ERROR0, "Dot expected to be preceeded by a Struct/Union.");
        return Left;
    }
    if (CalcStructElementOffset(Left->pType->Use.DecSpec.pPtr, Field) < 0) {
        Error(ERROR0, "Unknown struct/union field '%s'.",Field);
        return Left;
    }
    New = NewExprNode(uDot);
    New->pType = CalcStructElementType(Left->pType->Use.DecSpec.pPtr, Field);
    New->Use.Dot.pRecord = Left;
    New->Use.Dot.pszField  = Field;
    return New;  
}

TPExprNode
ExprMakeArrowNode(TPExprNode Left,  LPSTR Field) {
    TPExprNode New;
    if (!IsPtrStruct(Left->pType)) {
        Error(ERROR0, "Arrow expected to be preceeded by a Pointer to Struct/Union.");
        return Left;
    }
    if (CalcStructElementOffset(Left->pType->Use.DecPtr.pTarget->Use.DecSpec.pPtr, Field) < 0) {
        Error(ERROR0, "Unknown struct/union field '%s'.",Field);
        return Left;
    }
    New = NewExprNode(uDot);
    New->pType = CalcStructElementType(Left->pType->Use.DecPtr.pTarget->Use.DecSpec.pPtr, Field);
    New->Use.Dot.pRecord = Left;
    New->Use.Dot.pszField  = Field;
    return New;  
}


TPExprNode
ExprMakeArrayNode(TPExprNode Vec,  TPExprNode Ind) {
    TPExprNode New;
    if (!IsReference(Vec->pType) && IsSimple(Ind->pType)) {
        Error(ERROR0, "Reference expected before [...].");
        return Vec;
    }
    New = NewExprNode(uArray);
    New->Use.Array.pVector = Vec;
    if (IsPointer(Vec->pType)) {
        New->Use.Array.pIndex = Bmul(Ind, ExprMakeConstI(CalcSizeOf(Vec->pType->Use.DecPtr.pTarget)));
        New->pType = Vec->pType->Use.DecPtr.pTarget;
    } else {
        New->Use.Array.pIndex = Bmul(Ind, ExprMakeConstI(CalcSizeOf(Vec->pType->Use.DecArray.pTarget)));
        New->pType = Vec->pType->Use.DecArray.pTarget;
    }
    return New;
 }



TPExprNode
ExprMakeFuncNode(TPExprNode Func,  TPExprNode Params) {
    TPExprNode New;
    if (!IsFunc(Func->pType)) {
        Error(ERROR0, "Function expected before (...).");
        return Func;
    }
    New = NewExprNode(uFunc);
    New->pType = Func->pType->Use.DecFunc.pReturnType;
    New->Use.pFunc.pFunc   = Func;                  // Funky !
    New->Use.pFunc.pParams = Params;
    return New;
 }


/* ************************************************** */
/*  Assignment */
/* *********** */

TPExprNode
ExprMakeAssignNode(TIdExprAssign Op, TPExprNode Lval, TPExprNode Rval) {
    TPExprNode New;
    New = NewExprNode(uAssign);
    New->Use.Assign.Op    = Op;
    New->pType             = Lval->pType;    
    New->Use.Assign.pLval  = Lval;
    New->Use.Assign.pRval  = Rval;
    return New;
}

/* ************************************************** */
/*  Cast  */
/* ****** */
static LONG
TypeConvert(TPDeclSpec NewType, TPDeclSpec OldType, LONG Const) {
    WORD SzOld, SzNew;
    if (IsStruct(NewType) || IsStruct(OldType)) {
        Error(ERROR0, "Casting to/from struct is not possible.");
        return 0L;
    }
    SzOld = (WORD)CalcSizeOf(OldType);
    SzNew = (WORD)CalcSizeOf(NewType);
    if (IsReference(NewType) && IsReference(OldType) && (SzOld != SzNew)) {
        Error(WARNING0, "Conversion between near & far pointers.");
    }
    if (!(IsReference(NewType) || IsReference(OldType))) {
        if (SzNew > SzOld) {                                            // Cast up
            if (OldType->Use.DecSpec.Type & TypeUNSIGNED) {
                switch (SzOld) {                                        // Cast up Unsigned
                    case 1: Const &= 0x000000ff; break;
                    case 2: Const &= 0x0000ffff; break;
                    case 3: Const &= 0x00ffffff; break;
                    case 4: Const &= 0xffffffff; break;
                    default: Error(ERROR0, "Casting unsigned constant from an unsupported size.");
                }
            } else {                                                    // Cast up signed
                switch (SzOld) {
                    case 1: if (Const & 0x00000080) Const |= 0xffffff00; else Const &= 0x000000ff; break;
                    case 2: if (Const & 0x00008000) Const |= 0xffff0000; else Const &= 0x0000ffff; break;
                    case 3: if (Const & 0x00800000) Const |= 0xff000000; else Const &= 0x00ffffff; break;
                    case 4: if (Const & 0x80000080) Const |= 0x00000000; else Const &= 0xffffffff; break;
                    default: Error(ERROR0, "Casting signed constant from an unsupported size.");
                }
            }
        }
    }
    switch (SzNew) {
        case 1: Const &= 0x000000ff; break;
        case 2: Const &= 0x0000ffff; break;
        case 3: Const &= 0x00ffffff; break;
        case 4: Const &= 0xffffffff; break;
        default: Error(ERROR0, "Casting constant to an unsupported size.");
    }
    return Const;
}

TPExprNode ExprMakeCastNode(TPDeclSpec Type, TPExprNode Node) {
    TPExprNode New;
    if (Node->Usage == uConst) {
        Node->Use.Const.lInteger = TypeConvert(Type, Node->pType, Node->Use.Const.lInteger);
        Node->pType = Type;
        return Node;
    } else {
        New = NewExprNode(uCast);
        New->pType = Type;
        New->Use.Cast.pTarget = Node;
        return New;
    }
 }


TPExprNode ExprMakeInitNode(TPExprNode pNode) {         // initializer element
    TPExprNode pNew;
    pNew = NewExprNode(uInit);
    pNew->Use.Init.pAssignment = pNode;
    //pNew->Use.Init.pSibling    = NULL;
    pNew->Use.Init.pChildren   = NULL;
    return pNew;
}

TPExprNode ExprMakeInitList(TPExprNode pNode) {         // braketed set of elements
    TPExprNode pNew;
    pNew = NewExprNode(uInit);
    pNew->Use.Init.pAssignment = NULL;
    //pNew->Use.Init.pSibling    = NULL;
    pNew->Use.Init.pChildren   = pNode;
    return pNew;
}

/*
TPExprNode ExprInitConcat(TPExprNode pNode, TPExprNode pSibling) {
    TPExprNode n;
    for (n=pNode; n->Use.Init.pSibling; n=n->Use.Init.pSibling);
    n->Use.Init.pSibling = pSibling;
    return pNode;
}
*/

TPExprNode  ExprConcat(TPExprNode pNode, TPExprNode pSibling) {
    TPExprNode n;
    for (n = pNode; n->pSibling; n = n->pSibling);
    n->pSibling = pSibling;
    return pNode;
}


#ifdef _DEBUG
void PrintNode(TPExprNode pN) {
    switch (pN->Usage) {
        case uConst:    printf("%lx ",  pN->Use.Const.lInteger);
                        break;
        case uVar:      printf("<%s> ",  pN->Use.Var.pszIdentifier);
                        break;
        case uUnary:    printf("(op ");
                        PrintNode(pN->Use.Unary.pOperand);
                        printf(")");
                        break;
        default:    Error(WARNING0, "Other ");
                    break;
    }
}

void ExprPrintInit(TPExprNode n) {
    while (n) {
        if (n->Usage != uInit) {
            Error(FATAL, "PrintInit: What !\n");
        }
        if (n->Use.Init.pAssignment) {
            PrintNode(n->Use.Init.pAssignment);
        }
        if (n->Use.Init.pChildren) {
            printf("{ ");
            ExprPrintInit(n->Use.Init.pChildren);
            printf("} ");
        }
        n=n->pSibling;
    }
}
#endif // _DEBUG


/* ****************************************************************** */

DWORD ExprConstInt(TPExprNode E) {
    if (E->Usage != uConst) {
        Error(ERROR0, "Initializer must be a Constant value.");
        return 0L;
    }
    return E->Use.Const.lInteger;
 }


/* ****************************************************************** */


void
ExprCleanUp(TPExprNode n) {
    if (!n) {
        Error(FATAL, "Cleanup: Null\n");
        return;
    }
    switch (n->Usage) {
        case    uConst:
        case    uVar:       break;
        case    uUnary:     ExprCleanUp(n->Use.Unary.pOperand);
                            break;
        case    uBinary:    ExprCleanUp(n->Use.Binary.pLeft);
                            ExprCleanUp(n->Use.Binary.pRight);
                            break;
        case    uTernary:   ExprCleanUp(n->Use.Ternary.First);
                            ExprCleanUp(n->Use.Ternary.Second);
                            ExprCleanUp(n->Use.Ternary.Third);
                            break;
        default:            Error(FATAL, "CleanUp: More to clean ! [%d]\n", n->Usage);
                            break;
    }
    Dispose(n);
}

/* *************************************************** */



/* *************************************************** */


#ifdef _DEBUG

char *Uops[] = {  "-u",  "+u",  "~u",    "u++",  "++u",
                  "u--", "--u", "sizeof","addr", "ptr", "!u" };

char *Bops[] = {  "+b",  "-b",  "*b",    "/b",   "%b",
                  "&b",  "|b",  "^b",    "==b",  "!=b",
                  "<b",  "<=b", ">b",    ">=b",  "&&b",
                  "||b", ">>b", "<<b" };

void PrintType(int iDepth, TPExprNode n) {
    printf(" ==> ");
    ParseDeclSpec(iDepth, n->pType,FALSE);
 }

void ExprParse(int iDepth, TPExprNode n) {
    if (!n) {
        printf("..Null\n");
        return;
    }
    
    switch (n->Usage) {
        case    uConst:     ConsoleIndent(iDepth);
                            ConsolePrintf(CON_MAGENTA_BRIGHT, "%ld",    n->Use.Const.lInteger);
                            PrintType(iDepth, n);
                            break;
        case    uVar:       ConsoleIndent(iDepth);
                            ConsolePrintf(CON_YELLOW_BRIGHT, "[%s]",  n->Use.Var.pszIdentifier);
                            PrintType(iDepth, n);
                            break;
        case    uUnary:     ConsoleIndent(iDepth);
                            printf("%s", Uops[n->Use.Unary.Op]);
                            PrintType(iDepth, n);
                            ExprParse(iDepth + 1, n->Use.Unary.pOperand);
                            break;
        case    uBinary:    ExprParse(iDepth + 1, n->Use.Binary.pLeft);
                            ConsoleIndent(iDepth);
                            printf("%s", Bops[n->Use.Unary.Op]);
                            PrintType(iDepth, n);
                            ExprParse(iDepth + 1, n->Use.Binary.pRight);
                            break;
        case    uTernary:   ConsoleIndent(iDepth);
                            printf("Tern");
                            PrintType(iDepth, n);
                            ExprParse(iDepth + 1, n->Use.Ternary.First);
                            ConsoleIndent(iDepth);
                            printf("Then\n");
                            ExprParse(iDepth + 1, n->Use.Ternary.Second);
                            ConsoleIndent(iDepth);
                            printf("Else\n");
                            ExprParse(iDepth + 1, n->Use.Ternary.Third);
                            break;
        case    uDot:       ExprParse(iDepth + 1, n->Use.Dot.pRecord);
                            ConsoleIndent(iDepth);
                            printf("Dot");
                            PrintType(iDepth, n);
                            ConsoleIndent(iDepth);
                            printf("[%s]\n",n->Use.Dot.pszField);
                            break;
        case    uArrow:     ExprParse(iDepth + 1, n->Use.Arrow.pRecord);
                            ConsoleIndent(iDepth);
                            printf("Arrow");
                            PrintType(iDepth, n);
                            ConsoleIndent(iDepth);
                            printf("[%s]\n",n->Use.Arrow.pszField);
                            break;
        case    uArray:     ExprParse(iDepth + 1, n->Use.Array.pVector);
                            ConsoleIndent(iDepth);
                            printf("Array");
                            PrintType(iDepth, n);
                            ExprParse(iDepth + 1, n->Use.Array.pIndex);
                            break;
        case    uFunc:      ExprParse(iDepth + 1, n->Use.pFunc.pFunc);
                            ConsoleIndent(iDepth);
                            printf("Function");
                            PrintType(iDepth, n);
                            ExprParse(iDepth + 1, n->Use.pFunc.pParams);
                            break;
        case    uCast:      ConsoleIndent(iDepth);
                            printf("Cast");
                            PrintType(iDepth, n);
                            ExprParse(iDepth + 1, n->Use.Cast.pTarget);
                            break;
        default:            Error(FATAL, "ParseExpr: What [%d]\n", n->Usage);
                            break;
    }
}
#endif // _DEBUG

/* eof */

