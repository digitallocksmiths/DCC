
#define _CRT_SECURE_NO_WARNINGS

//#include <conio.h>
#include <stdio.h>
//#include <ctype.h>
//#include <signal.h>
//#include <setjmp.h>
//#include <stdlib.h>
//#include <memory.h>
//#include <string.h>
#include <assert.h>
#include <Windows.h>

//#include "C_Yacced.tab.h"
#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "Gen.h"
#include "main.h"


#define GEN_PREFIX "L"
static WORD GenCount = 0;

LPSTR GenLabel(LPSTR PreFix) {
	LPSTR Label = New(strlen(GEN_PREFIX)+strlen(PreFix)+6+1);
	sprintf(Label, GEN_PREFIX "%s%06ld", PreFix, GenCount++);
	return Label;
 }


static void Pad(int n) {
    while (n>0) {
        printf(" ");
        n--;
    }
}

#define LABEL_WIDTH   20
#define OPCODE_WIDTH  10
#define OPERAND_WIDTH 15
#define ASSEMBLER_WIDTH (OPCODE_WIDTH+OPERAND_WIDTH)


static void GenAsmOut(LPSTR pszLabel, LPSTR pszOpcode, LPSTR pszOperand, LPSTR pszComment, BOOL fNL) {
    int n;
    if ((pszLabel != NULL) && (*pszLabel != '\0')) { n = printf("%s:", pszLabel); }
    else { n = 0; }
    Pad(LABEL_WIDTH - n);

    if ((pszOpcode != NULL) && (*pszOpcode != '\0')) { n = printf("%s", pszOpcode); }
    else { n = 0; }
    Pad(OPCODE_WIDTH - n);

    if ((pszOperand != NULL) && (*pszOperand != '\0')) { n = printf("%s", pszOperand); }
    else { n = 0; }
    Pad(OPERAND_WIDTH - n);

    if (pszComment != NULL) {
        n = printf("; %s", pszComment);
        if (fNL) {
            printf("\n");
        }
    }
    else {
        printf("\n");
    }

}

static LPSTR sign_unsign(WORD T) {
    if ((T & TypeUNSIGNED) == TypeUNSIGNED) return "unsigned ";
    if ((T & TypeSIGNED) == TypeSIGNED)   return "signed ";
    return "";
}

BOOL GenIsData(WORD nUse) {
    switch (nUse) {
    case DecSpec:
    case DecPtr:
    case DecArray:  return TRUE;
    case DecId:
    case DecFunc:   return FALSE;
    default:
        assert(FALSE);
    }
    return FALSE;
}

#define TT(D,T) (((D) & (T)) == (T))


static void GenObjectComment(TPDeclSpec pDecl) {
    while (pDecl) {
        switch (pDecl->Usage) {
        case    DecId:          // Id
        case    DecFunc:        // Function 
            printf("GenBssObjectComment():  Unexpected Useage '%d'\n", pDecl->Usage);
            return;

        case    DecArray:
            printf("Array[%ld] of ", pDecl->Use.DecArray.Size);
            pDecl = pDecl->Use.DecArray.pTarget;
            break;

        case    DecPtr:
            switch (pDecl->Use.DecPtr.Qual) {
            case QualCONST:    printf("pointer to constant\n");  break;
            case QualVOLATILE: printf("pointer to volatile\n");  break;
            case QualNEAR:     printf("pointer to near\n");      break;
            case QualFAR:      printf("pointer to far\n");       break;
            default:           printf("pointer (generic)\n");   break;
            }
            return;

        case    DecSpec:
            if ((pDecl->Use.DecSpec.Type) & TypeSTRUCT) {
                LpStructSet p = pDecl->Use.DecSpec.Ptr;
                if (p->fUnion) printf("union '%s'\n", p->szSetName);
                else           printf("structure '%s'\n", p->szSetName);
                return;
            }
            else if ((pDecl->Use.DecSpec.Type) & TypeENUM) {
                TPEnumSet e = pDecl->Use.DecSpec.Ptr;
                printf("enum '%s'\n", e->pszSetName);
                return;
            }
            else if ((pDecl->Use.DecSpec.Type) & TypeTYPEDEF) {
                printf("typedef not yet supported\n");
                //ParseDeclSpec(pDecl->Use.DecSpec.Ptr, fDoBrothers); 
                return;
            }
            else {
                if   TT(pDecl->Use.DecSpec.Type, (TypeLONG | TypeDOUBLE))printf("long double");
                else if TT(pDecl->Use.DecSpec.Type, TypeDOUBLE)          printf("double");
                else if TT(pDecl->Use.DecSpec.Type, TypeFLOAT)           printf("float");
                else if TT(pDecl->Use.DecSpec.Type, TypeLONG)            printf("%slong", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeSHORT)           printf("%sshort ", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeINT)             printf("%sint", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeCHAR)            printf("%schar", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeSIGNED)          printf("signed");
                else if TT(pDecl->Use.DecSpec.Type, TypeUNSIGNED)        printf("unsigned");
                else if TT(pDecl->Use.DecSpec.Type, TypeVOID)            printf("void");
                else                                                     printf("unknown type 0x%04x", pDecl->Use.DecSpec.Type);

                //              DescClass(pDecl->Use.DecSpec.Class); 
                //              DescQual(pDecl->Use.DecSpec.Qual); 
                printf("\n");
            }
            return;

        default:
            printf("GenBssObjectComment(): Unknown Useage '%d'\n", pDecl->Usage);
            return;
        }
    }
}

// ##########################################################################################
// Data segment generator

static BOOL SetupConstInitializer(TPDeclSpec T, LPSTR pszOpcode, LPSTR pszOperand, __int64 nVal) {

    switch (CalcSizeOf(T)) {
    case 1: sprintf(pszOpcode, ".byte");
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED)  sprintf(pszOperand, "%hhu", (unsigned char)(nVal & 0xFF));
        else                                                       sprintf(pszOperand, "%hhd", (signed char)(nVal & 0xFF));
        return TRUE;
    case 2: sprintf(pszOpcode, ".word"); ;
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED)  sprintf(pszOperand, "%hu", (unsigned short)(nVal & 0xFFFF));
        else                                                       sprintf(pszOperand, "%hd", (signed short)(nVal & 0xFFFF));
        return TRUE;
    case 4: sprintf(pszOpcode, ".dword"); ;
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED)  sprintf(pszOperand, "%I32u", (unsigned int)(nVal & 0xFFFFFFFFL));
        else                                                       sprintf(pszOperand, "%I32d", (signed int)(nVal & 0xFFFFFFFFL));
        return TRUE;
    default: sprintf(pszOpcode, "; unknown size");
        sprintf(pszOperand, "%I64u", nVal);
        return FALSE;
    }
}

static BOOL SetupVarInitializer(TPDeclSpec T, LPSTR pszOpcode, LPSTR pszOperand, LPSTR pszVar) {

    sprintf(pszOperand, "%s", pszVar);

    switch (CalcSizeOf(T)) {
    case 1: sprintf(pszOpcode, ".byte");
        break;
    case 2: sprintf(pszOpcode, ".word"); ;
        break;
    case 4: sprintf(pszOpcode, ".dword"); ;
        break;
    default: sprintf(pszOpcode, "; unknown size");
        return FALSE;
    }
    return TRUE;

}


void GenDataObjectString(TPDeclSpec pDecl) {                                                            // Initialized Strings
    char szOperand[32];
    char szComment[32];
    char *pszLabel;

    assert(pDecl->Usage == DecId);
    TPDeclSpec T = pDecl->Use.DecId.pTarget;
    LPSTR pszInit = pDecl->Use.DecId.pszInitializedStr;

    int nLen = strlen(pszInit)+1;
    
    pszLabel = pDecl->Use.DecId.pszName;

    while (nLen--) {
        sprintf(szOperand, "%hhu", *pszInit);
        if (isprint(*pszInit)) {
            sprintf(szComment, "%02x, \'%c\'    ", *pszInit, *pszInit);
        }
        else {
            sprintf(szComment, "%02x,        ", *pszInit);
        }
        GenAsmOut(pszLabel, ".byte", szOperand, szComment, (pszLabel == NULL));
        if (pszLabel != NULL) {
            GenObjectComment(pDecl->Use.DecId.pTarget);
        }
        pszLabel = NULL;
        pszInit++;
    }
}


void GenDataObjectPointer(TPDeclSpec pDecl) {                                                           // Initialized pointers

    char szOpcode[32];
    char szOperand[32];

    szOpcode[0] = 0;
    szOperand[0] = 0;

    assert(pDecl->Usage == DecId);
    TPDeclSpec T = pDecl->Use.DecId.pTarget;
    TPExprNode Init = pDecl->Use.DecId.pInitializer;

    assert(Init->Usage == uInit);
    TPExprNode Val = Init->Use.Init.Assignment;

    if (Val->Usage == uConst) {
        unsigned __int64    nVal;
        nVal = Val->Use.Const.Integer;
        if (!SetupConstInitializer(T, szOpcode, szOperand, nVal)) {
            ErrorGen("Unrecognized size of variable ", pDecl->Use.DecId.pszName);
        }
    }
    else if (Val->Usage == uVar) {
        if (!SetupVarInitializer(T, szOpcode, szOperand, Val->Use.Var.Identifier)) {
            ErrorGen("Unrecognized size of variable ", pDecl->Use.DecId.pszName);
        }
    }
    else {
        WarningGen("Non constant pointer value in initialization of ", pDecl->Use.DecId.pszName);
    }

    GenAsmOut(pDecl->Use.DecId.pszName, szOpcode, szOperand, "", FALSE);
    GenObjectComment(pDecl->Use.DecId.pTarget);
}

void GenDataObjectArray(TPDeclSpec pDecl) {                                                             // Initialized Arrays
    TPDeclSpec T = pDecl->Use.DecId.pTarget;
    char szOperand[32];
    printf("processing %s\n", pDecl->Use.DecId.pszName);

    ErrorGen("GenDataObjectArray() Unimplemented", NULL);
    sprintf(szOperand, "Array[%ld] of ", T->Use.DecArray.Size);
    GenAsmOut(pDecl->Use.DecId.pszName, ".db", szOperand, "wibble", TRUE);
}


void    GenDataObjectUnion(TPDeclSpec pDecl) {
    TPDeclSpec T = pDecl->Use.DecId.pTarget;
    printf("processing %s\n", pDecl->Use.DecId.pszName);
    ErrorGen("GenDataObjectUnion() Unimplemented", NULL);
    printf("Union\n ");
}

void    GenDataObjectStructure(TPDeclSpec pDecl) {
    TPDeclSpec T = pDecl->Use.DecId.pTarget;
    printf("processing %s\n", pDecl->Use.DecId.pszName);
    ErrorGen("GenDataObjectStructure() Unimplemented", NULL);
    printf("Structure\n");
}

void    GenDataObjectEnum(TPDeclSpec pDecl) {                                                        // Enum value
    char szOperand[32];

    assert(pDecl->Usage == DecId);
    TPDeclSpec T = pDecl->Use.DecId.pTarget;
    TPExprNode Init = pDecl->Use.DecId.pInitializer;

    assert(Init->Usage == uInit);
    TPExprNode Val = Init->Use.Init.Assignment;

    int        nVal;
    if (Val->Usage != uConst) {
        WarningGen("Non constant interger in Enum initialization of ", pDecl->Use.DecId.pszName);
        nVal = 0;
    }
    else {
        nVal = Val->Use.Const.Integer;
    }

    sprintf(szOperand, "%d", nVal);
    GenAsmOut(pDecl->Use.DecId.pszName, ".word", szOperand, "", FALSE);
    GenObjectComment(pDecl->Use.DecId.pTarget);
}

void    GenDataObjectTypedef(TPDeclSpec pDecl) {
    TPDeclSpec T = pDecl->Use.DecId.pTarget;
    printf("processing %s\n", pDecl->Use.DecId.pszName);
    ErrorGen("GenDataObjectTypedef() Unimplemented", NULL);
    printf("Typedef\n");
}

void    GenDataObjectBasetype(TPDeclSpec pDecl) {
    
    char szOpcode[32];
    char szOperand[32];

    assert(pDecl->Usage == DecId);
    TPDeclSpec T = pDecl->Use.DecId.pTarget;
    TPExprNode Init = pDecl->Use.DecId.pInitializer;

    assert(Init->Usage == uInit);
    TPExprNode Val = Init->Use.Init.Assignment;

    unsigned __int64        nVal;
    if (Val->Usage != uConst) {
        WarningGen("Non constant interger in initialization of ", pDecl->Use.DecId.pszName);
        nVal = 0;
    }
    else {
        nVal = Val->Use.Const.Integer;
    }

    if (!SetupConstInitializer(T, szOpcode, szOperand, nVal)) {
        ErrorGen("Unrecognized size of variable ", pDecl->Use.DecId.pszName);
    }

    GenAsmOut(pDecl->Use.DecId.pszName, szOpcode, szOperand, "", FALSE);
    GenObjectComment(pDecl->Use.DecId.pTarget);
}


static void GenDataObject(TPDeclSpec pDecl) {
    TPDeclSpec T = pDecl->Use.DecId.pTarget;
    //printf("processing %s\n", pDecl->Use.DecId.pszName);
    
    switch (T->Usage) {
        case    DecId:          // Id
        case    DecFunc:        // Function 
            printf("GenDataObject():  Unexpected Useage '%d'\n", pDecl->Usage);
            return;

        case    DecArray:
            GenDataObjectArray(pDecl);
            return;

        case    DecPtr:
            GenDataObjectPointer(pDecl);
            return;

        case    DecSpec:
            if ((T->Use.DecSpec.Type) & TypeSTRUCT) {
                LpStructSet p = T->Use.DecSpec.Ptr;
                if (p->fUnion) GenDataObjectUnion(pDecl);
                else           GenDataObjectStructure(pDecl);
                return;
            }
            else if ((T->Use.DecSpec.Type) & TypeENUM) {
                TPEnumSet e = T->Use.DecSpec.Ptr;
                GenDataObjectEnum(pDecl);
                return;
            }
            else if ((T->Use.DecSpec.Type) & TypeTYPEDEF) {
                GenDataObjectTypedef(pDecl);
                return;
            }
            else {
                GenDataObjectBasetype(pDecl);
                return;
            }
            return;

        default:
            printf("GenBssObjectComment(): Unknown Useage '%d'\n", pDecl->Usage);
            return;
        }

}

void GenData(TPDeclSpec pDecl) {
    //char szOperand[32];
    TPDeclSpec pDeclList;

    GenAsmOut(NULL, ".segment", "DATA", "=== Start of DATA segment ===", TRUE);

    for (pDeclList = pDecl; pDeclList; pDeclList = pDeclList->Chain) {
        if ((pDeclList->Usage == DecId) &&
            GenIsData(pDeclList->Use.DecId.pTarget->Usage) &&
            (pDeclList->Use.DecId.pszInitializedStr)) {
            GenDataObjectString(pDeclList);
        }
    }

    for (pDeclList = pDecl; pDeclList; pDeclList = pDeclList->Chain) {
        if ((pDeclList->Usage == DecId) &&
            GenIsData(pDeclList->Use.DecId.pTarget->Usage) &&
            (pDeclList->Use.DecId.pInitializer)) {
            GenDataObject(pDeclList);
        }
    }

    GenAsmOut(NULL, ".endseg", NULL, "=== End of DATA segment ===\n", TRUE);

}

// ##########################################################################################
// Bss segment generator


void GenBss(TPDeclSpec pDecl) {
    char szOperand[32];

    GenAsmOut(NULL, ".segment", "BSS", "=== Start of BSS segment ===", TRUE);

    for (; pDecl; pDecl = pDecl->Chain) {
        if ((pDecl->Usage == DecId) &&
            GenIsData(pDecl->Use.DecId.pTarget->Usage) &&
            !(pDecl->Use.DecId.pszInitializedStr || pDecl->Use.DecId.pInitializer)) {
            sprintf(szOperand, "%4d", CalcSizeOf(pDecl->Use.DecId.pTarget));
            GenAsmOut(pDecl->Use.DecId.pszName, ".space", szOperand, "", FALSE);
            GenObjectComment(pDecl->Use.DecId.pTarget);
        }
    }

    GenAsmOut(NULL, ".endseg", NULL, "=== End of BSS segment ===\n", TRUE);

}

/* eof */
