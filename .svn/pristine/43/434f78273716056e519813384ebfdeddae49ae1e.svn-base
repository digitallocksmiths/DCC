// # $URL$
// # $Revision$


#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <Windows.h>

#include "Utilities\Console.h"

//#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "Gen.h"
#include "Statements.h"
#include "main.h"
#include "ExprOptimize.h"

int iGlbLocalSize = 0;


void GenStatements(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel); // forward

#ifdef _DEBUG


void    GenStatementPrettyPrint(int iDepth, TPStatement pStat, BOOL fNext) {
    
    if (pStat == NULL) {
        return;
    }
    do {
        ConsoleIndent(iDepth);
        if (pStat->pszLabel) {
            printf("%s: ", pStat->pszLabel);
        }
        switch (pStat->Usage) {
        case    StatementCOMPOUND:
            printf("COMPOUND {\n");
            GenStatementPrettyPrint(iDepth + 1, pStat->Use._compound.pStatement, TRUE);
            ConsoleIndent(iDepth); printf("COMPOUND_END }\n");
            break;

        case    StatementRETURN:
            printf("RETURN %s\n", (pStat->Use._return.pExpr) ? "something" : "void");
            break;

        case    StatementIF:
            printf("IF (%s) THEN\n", (pStat->Use._if.pCond) ? "something" : "void");
            GenStatementPrettyPrint(iDepth + 1, pStat->Use._if.pYes, TRUE);
            if (pStat->Use._if.pNo) {
                ConsoleIndent(iDepth); printf("ELSE\n");
                GenStatementPrettyPrint(iDepth + 1, pStat->Use._if.pNo, TRUE);
            }
            ConsoleIndent(iDepth); printf("IF_END\n");
            break;

        case    StatementWHILE:
            printf("WHILE (%s) DO\n", (pStat->Use._while.pCond) ? "something" : "void");
            if (pStat->Use._while.pAction) {
                GenStatementPrettyPrint(iDepth + 1, pStat->Use._while.pAction, TRUE);
            }
            ConsoleIndent(iDepth); printf("WHILE_END\n");
            break;

        case    StatementDO:
            printf("DO\n");
            if (pStat->Use._do.pAction) {
                GenStatementPrettyPrint(iDepth + 1, pStat->Use._do.pAction, TRUE);
            }
            ConsoleIndent(iDepth+1); printf("while condition (%s)\n", (pStat->Use._do.pCond) ? "something" : "void");
            ConsoleIndent(iDepth); printf("DO_END\n");
            break;

        case    StatementFOR:
            printf("FOR\n");
            ConsoleIndent(iDepth + 1); printf("Init      (%s)\n", (pStat->Use._for.pInit)   ? "something" : "void");
            ConsoleIndent(iDepth + 1); printf("Condition (%s)\n", (pStat->Use._for.pCond)   ? "something" : "void");
            if (pStat->Use._for.pAction) {
                GenStatementPrettyPrint(iDepth + 2, pStat->Use._for.pAction, TRUE);
            }
            ConsoleIndent(iDepth + 1); printf("Repeat    (%s)\n", (pStat->Use._for.pRepeat) ? "something" : "void");

            ConsoleIndent(iDepth); printf("FOR_END\n");
            break;

        case    StatementEXPR:
            printf("EXPRESSION (%s)\n", (pStat->Use._expr.pExpr) ? "something" : "void");
            //GenExpressionPrettyPrint(iDepth + 1, pStat->Use._expr.pExpr);
//            pStat->Use._expr.pExpr  = ExprOptimize(pStat->Use._expr.pExpr);
#pragma message("GenStatementPrettyPrint: ExprOptimize commented out")

            break;

        case    StatementBREAK:
            printf("BREAK\n");
            break;

        case    StatementCONTINUE:
            printf("CONTINUE\n");
            break;

        case    StatementGOTO:
            printf("GOTO '%s'\n", pStat->Use._goto.pszLabel);
            break;

        case    StatementSWITCH:
            printf("SWITCH (%s)\n", (pStat->Use._switch.pExpr) ? "something" : "WTF?");
            if (pStat->Use._switch.pBody) {
                GenStatementPrettyPrint(iDepth + 1, pStat->Use._switch.pBody, TRUE);
            }
            ConsoleIndent(iDepth); printf("SWITCH_END\n");
            break;

        case    StatementCASE:
            printf("CASE '%s'\n", (pStat->Use._case.pExpr) ? "something" : "default");
            if (pStat->Use._case.pBody) {
                GenStatementPrettyPrint(iDepth + 1, pStat->Use._case.pBody, TRUE);
            }
            break;

        default: Error(FATAL, "StatementPrint(): unknown statement usage");
        }
        pStat = pStat->pNext;
    } while (fNext && pStat);
}
#endif // _DEBUG



// ##########################################################################
// #  Function: GenStatementLabel
// #        Generate an statement lable for the current 'c' statement.. 
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
LPSTR GenStatementLabel(LPSTR pszFn, LPSTR pszLab) {
    static char szLab[256];

    if (pszLab != NULL) {
        sprintf_s(szLab, sizeof(szLab), "Label_%s_%s", pszFn, pszLab);
    }
    else {
        szLab[0] = '\0';
    }
    return szLab;
}

// ##########################################################################
// #  Function: GenStatementLabel
// #        Generate an assembler line for the Statement Start. 
// #        If the statement is labeled the label will be genterated here.
// #
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenStatementIntro(FILE *hOut, TPStatement pStat, LPSTR pszFn, LPSTR pszAction, LPSTR pszExtraComment) {
    static char szComment[100];
    LPSTR pszLab = GenStatementLabel(pszFn, pStat->pszLabel);

    sprintf_s(szComment, sizeof(szComment), "; ==== %s Statement =======================================", pszAction);
    szComment[OPCODE_WIDTH + OPERAND_WIDTH - 2] = ' ';
    szComment[OPCODE_WIDTH + OPERAND_WIDTH - 1] = '\0';
    GenAsmOut(hOut, pszLab, szComment, "", pszExtraComment, TRUE, FALSE);
}

// ##########################################################################
// #  Function: GenExpr
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenExpr(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {
    GenStatementIntro(hOut, pStat, pszFunctionName, "Expr", "");
    GenExpression(hOut, pStat->Use._expr.pExpr);
    GenAsmOut(hOut, "", ";      Expr end ------------", "", NULL, TRUE, FALSE);
}

// ##########################################################################
// #  Function: GenCompound
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenCompound(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {
    LPSTR       szEndRef = GenLabel("_compound_Id_");
    GenStatementIntro(hOut, pStat, pszFunctionName, "Compound", szEndRef);
    GenStatements(hOut, pStat->Use._compound.pStatement, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel);
    GenAsmOut(hOut, "", ";      Compound End --------", "", szEndRef, TRUE, FALSE);
}

// ##########################################################################
// #  Function: GenReturn
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenReturn(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {
    GenStatementIntro(hOut, pStat, pszFunctionName, "Return", "");
    Error(FATAL, "GenReturn() Not yet implemented");
}

// ##########################################################################
// #  Function: GenIf
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenIf(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {
    LPSTR       szIfThenLabel = GenLabel("_IfThen_");
    LPSTR       szIfElseLabel = GenLabel("_IfElse_");
    LPSTR       szIfDoneLabel = GenLabel("_IfDone_");

    GenStatementIntro(hOut, pStat, pszFunctionName, "If", "");

    if (pStat->Use._if.pCond == NULL) {
        Error(WARNINGX, "GenIf(): no condition in If statement");
        GenAsmOut(hOut, "", "; ***** IF condition was missing ! no code generated", "", "", TRUE, FALSE);
        return;
    }

    GenExpression(hOut, pStat->Use._while.pCond);                                               //
    GenAsmOut(hOut, "", "or", "r4,r4", "  1:", TRUE, FALSE);                                    //  Test

    if (pStat->Use._if.pNo == NULL) {
        GenAsmOut(hOut, "", "breq", szIfDoneLabel, "1/2:", TRUE, FALSE);                            //  fail skip Then body
        GenAsmOut(hOut, szIfThenLabel, ";      If Then ------------", "", "", TRUE, FALSE);         //  Then
        GenStatements(hOut, pStat->Use._if.pYes, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel);    //  Body
    }
    else {
        GenAsmOut(hOut, "", "breq", szIfElseLabel, "1/2:", TRUE, FALSE);                            //  fail jmp Else
        GenAsmOut(hOut, szIfThenLabel, ";      If Then ------------", "", "", TRUE, FALSE);         //  Then
        GenStatements(hOut, pStat->Use._if.pYes, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel);    //  Body
        GenAsmOut(hOut, "", "rjmp", szIfDoneLabel, "1/2:", TRUE, FALSE);                            //  exit
    
        GenAsmOut(hOut, szIfElseLabel, ";      If Else ------------", "", "", TRUE, FALSE);         //  Else
        GenStatements(hOut, pStat->Use._if.pNo, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel);     //  Body
    }
    
    GenAsmOut(hOut, szIfDoneLabel, ";      If End --------------", "", "", TRUE, FALSE);

}

// ##########################################################################
// #  Function: GenWhile
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenWhile(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {
    LPSTR       szNewWhileTestLabel = GenLabel("_WhileTest_");
    LPSTR       szNewWhileBreakLabel = GenLabel("_WhileBreak_");

    GenStatementIntro(hOut, pStat, pszFunctionName, "While", "");

    if (pStat->Use._while.pCond == NULL) {
        Error(WARNINGX, "GenWhile(): no condition in while statement");
        GenAsmOut(hOut, "", "; ***** WHILE condition was missing ! no code generated", "", "", TRUE, FALSE);
        return;
    }

    GenAsmOut(hOut, szNewWhileTestLabel, ";      While Condition ----", "", "", TRUE, FALSE);
    GenExpression(hOut, pStat->Use._while.pCond);
    GenAsmOut(hOut, "", "or", "r4,r4", "  1:", TRUE, FALSE);
    if (pStat->Use._while.pAction == NULL) {                                                // ? no body so 
        GenAsmOut(hOut, "", "brne", szNewWhileTestLabel, "1/2:", TRUE, FALSE);              //          jmp to retest if needed
    }                                                                                       //          or fall out
    else {                                                                                  // ? body
        GenAsmOut(hOut, "", "breq", szNewWhileBreakLabel, "1/2:", TRUE, FALSE);             //          jmp to exit or fall into body
        GenStatements(hOut, pStat->Use._while.pAction, pszFunctionName, pszExitLabel, szNewWhileBreakLabel, szNewWhileTestLabel);
        GenAsmOut(hOut, "", "rjmp", szNewWhileTestLabel, "1/2:", TRUE, FALSE);              //
    }
    GenAsmOut(hOut, szNewWhileBreakLabel, ";      While end -----------", "", "", TRUE, FALSE);
}

// ##########################################################################
// #  Function: GenDo
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenDo(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {
    LPSTR       szNewDoAgainLabel = GenLabel("_DoAgain_");
    LPSTR       szNewDoTestLabel  = GenLabel("_DoTest_");
    LPSTR       szNewDoBreakLabel = GenLabel("_DoBreak_");

    GenStatementIntro(hOut, pStat, pszFunctionName, "Do", "");
    GenAsmOut(hOut, szNewDoAgainLabel, ";      Do Body ------------", "", "", TRUE, FALSE);
    GenStatements(hOut, pStat->Use._do.pAction, pszFunctionName, pszExitLabel, szNewDoBreakLabel, szNewDoTestLabel);

    if (pStat->Use._do.pCond != NULL) {
        GenAsmOut(hOut, szNewDoTestLabel, ";      Do test -------------", "", "", TRUE, FALSE);
        GenExpression(hOut, pStat->Use._do.pCond);
        GenAsmOut(hOut, "", "or", "r4,r4", "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "brne", szNewDoAgainLabel, "1/2:", TRUE, FALSE);
    }
    else {
        Error(WARNINGX, "GenDo(): no condition in do statement");
        GenAsmOut(hOut, szNewDoTestLabel, "; ***** DO condition was missing !", "", "", TRUE, FALSE);
    }

    GenAsmOut(hOut, szNewDoBreakLabel, ";      Do end --------------", "", "", TRUE, FALSE);

}

// ##########################################################################
// #  Function: GenFor
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenFor(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {
    LPSTR       szNewForTestLabel = GenLabel("_ForTest_");
    LPSTR       szNewForAgainLabel = GenLabel("_ForAgain_");
    LPSTR       szNewBreakLabel = GenLabel("_Break_");

    GenStatementIntro(hOut, pStat, pszFunctionName, "For", "");
    if (pStat->Use._for.pInit != NULL) {
        GenExpression(hOut, pStat->Use._for.pInit);
    }

    if (pStat->Use._for.pCond != NULL) {
        GenAsmOut(hOut, szNewForTestLabel, ";      For test ------------", "", "", TRUE, FALSE);
        GenExpression(hOut, pStat->Use._for.pCond);
        GenAsmOut(hOut, "", "or", "r4,r4",           "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "breq", szNewBreakLabel, "1/2:", TRUE, FALSE);
        GenAsmOut(hOut, "", ";      For Body ------------", "", "", TRUE, FALSE);
    }
    else {
        GenAsmOut(hOut, szNewForAgainLabel, ";      For Body ------------", "", "", TRUE, FALSE);
    }

    GenStatements(hOut, pStat->Use._for.pAction, pszFunctionName, pszExitLabel, szNewBreakLabel, szNewForAgainLabel);

    if (pStat->Use._for.pRepeat != NULL) {
        GenAsmOut(hOut, szNewForAgainLabel, ";      For Body end --------", "", "", TRUE, FALSE);
        GenExpression(hOut, pStat->Use._for.pRepeat);
    }

    GenAsmOut(hOut, "", "rjmp", szNewForTestLabel, "  2:", TRUE, FALSE);
    GenAsmOut(hOut, szNewBreakLabel,   ";      For end -------------", "", "", TRUE, FALSE);
}

// ##########################################################################
// #  Function: GenBreak
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenBreak(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {
    GenStatementIntro(hOut, pStat, pszFunctionName, "Break", "");
    if ((pszBreakLabel == NULL) || (*pszBreakLabel == '\0')) {
        Error(WARNINGX, "GenBreak(): Function '%s' break ignored. It has no enclosing compound statement.", pszFunctionName);
        GenAsmOut(hOut, "", "; ***** Unexpected break statement found here ***", "", NULL, TRUE, FALSE);
        return;
    }
    GenAsmOut(hOut, "", "rjmp", pszBreakLabel, "  2: break", TRUE, FALSE);
}

// ##########################################################################
// #  Function: GenContinue
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenContinue(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {
    GenStatementIntro(hOut, pStat, pszFunctionName, "Continue", "");
    if ((pszContinueLabel == NULL) || (*pszContinueLabel == '\0')) {
        Error(WARNINGX, "GenContinue(): Function '%s' continue ignored. It has no enclosing loop.", pszFunctionName);
        GenAsmOut(hOut, "", "; ***** Unexpected continue statement found here ***", "", NULL, TRUE, FALSE);
        return;
    }
    GenAsmOut(hOut, "", "rjmp", pszContinueLabel, "  2: continue", TRUE, FALSE);
}

// ##########################################################################
// #  Function: GenGoto
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenGoto(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {
    GenStatementIntro(hOut, pStat, pszFunctionName, "Goto", "");
    GenAsmOut(hOut, "", "rjmp", GenStatementLabel(pszFunctionName, pStat->Use._goto.pszLabel), "  2: continue", TRUE, FALSE);
}

// ##########################################################################
// #  Function: GenSwitch
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenSwitch(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {
    LPSTR       pszNewBreakLabel = GenLabel("_Break_");
    LPSTR       pszCaseTestLabel = GenLabel("_Case_");
    LPSTR       pszCaseBodyLabel = GenLabel("_Body_");
    
    char        szOperand[32];
    char        szComment[32];
    char        szTestLabel[32];
    char        szBodyLabel[32];
    int         iTestCount;
    int         iBodyCount;

    TPStatement pCase;
    GenStatementIntro(hOut, pStat, pszFunctionName, "Switch", "");
    GenExpression(hOut, pStat->Use._switch.pExpr);

    int nExprTypeSize = CalcSizeOf(pStat->Use._switch.pExpr->pType);
    switch (nExprTypeSize) {
    case 4: GenAsmOut(hOut, "", "movw", "r20, r4", "  1: result to temp reg for immediate comparisons", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", "r22, r6", "  1:", TRUE, FALSE);
            break;
    case 2: GenAsmOut(hOut, "", "movw", "r20, r4", "  1: result to temp reg for immediate comparisons", TRUE, FALSE);
            break;
    case 1: GenAsmOut(hOut, "", "mov", "r20, r4", "  1: result to temp reg for immediate comparisons", TRUE, FALSE);
    }

    iTestCount = 1;
    iBodyCount = 1;
    sprintf(szTestLabel, "%s_%d", pszCaseTestLabel, iTestCount++);
    sprintf(szBodyLabel, "%s_%d", pszCaseBodyLabel, iBodyCount++);

    sprintf(szTestLabel, "%s_%d", pszCaseTestLabel, iTestCount++);
    for (pCase = pStat->Use._switch.pBody; pCase != NULL; pCase = pCase->pNext) {
        ASSERT(pCase->Usage == StatementCASE);
        
        if (pCase->Use._case.pExpr != NULL) {                                                   // case
            long lVal;
            ASSERT(pCase->Use._case.pExpr->Usage == uConst);
            switch (nExprTypeSize) {
            case 1: lVal = (pCase->Use._case.pExpr->Use.Const.lInteger & 0xFF);
                    sprintf(szOperand, "r20, 0x%02x", lVal);
                    sprintf(szComment, "  1: -> Case %d", lVal);
                    GenAsmOut(hOut, "", "cpi", szOperand, szComment, TRUE, FALSE);
                    GenAsmOut(hOut, "", "breq", szBodyLabel, "1/2:", TRUE, FALSE);
                    break;
            case 2: lVal = (pCase->Use._case.pExpr->Use.Const.lInteger & 0xFFFF);
                    sprintf(szOperand, "r20, 0x%02x", (lVal&0xFF));
                    sprintf(szComment, "  1: -> Case %d", lVal);
                    GenAsmOut(hOut, szTestLabel, "cpi", szOperand, szComment, TRUE, FALSE);
                    sprintf(szTestLabel, "%s_%d", pszCaseTestLabel, iTestCount++);
                    GenAsmOut(hOut, "", "brne", szTestLabel, "1/2:", TRUE, FALSE);
                    sprintf(szOperand, "r21, 0x%02x", ((lVal>>8) & 0xFF));
                    GenAsmOut(hOut, "", "cpi", szOperand, "  1:", TRUE, FALSE);
                    GenAsmOut(hOut, "", "breq", szBodyLabel, "1/2:", TRUE, FALSE);
                    break;
            case 4: lVal = pCase->Use._case.pExpr->Use.Const.lInteger;
                    sprintf(szOperand, "r20, 0x%02x", (lVal & 0xFF));
                    sprintf(szComment, "  1: -> Case %ld", lVal);
                    GenAsmOut(hOut, szTestLabel, "cpi", szOperand, szComment, TRUE, FALSE);
                    sprintf(szTestLabel, "%s_%d", pszCaseTestLabel, iTestCount++);
                    GenAsmOut(hOut, "", "brne", szTestLabel, "1/2:", TRUE, FALSE);
                    
                    sprintf(szOperand, "r21, 0x%02x", ((lVal >> 8) & 0xFF));
                    GenAsmOut(hOut, "", "cpi", szOperand, "  1:", TRUE, FALSE);
                    GenAsmOut(hOut, "", "brne", szTestLabel, "1/2:", TRUE, FALSE);
                    
                    sprintf(szOperand, "r22, 0x%02x", ((lVal >> 16) & 0xFF));
                    GenAsmOut(hOut, "", "cpi", szOperand, "  1:", TRUE, FALSE);
                    GenAsmOut(hOut, "", "brne", szTestLabel, "1/2:", TRUE, FALSE);

                    sprintf(szOperand, "r23, 0x%02x", ((lVal >> 24) & 0xFF));
                    GenAsmOut(hOut, "", "cpi", szOperand, "  1:", TRUE, FALSE);
                    GenAsmOut(hOut, "", "breq", szBodyLabel, "1/2:", TRUE, FALSE);
                    break;
            default: Error(FATAL, "GenSwitch(): wierd size");
            }
            if (pCase->Use._case.pBody != NULL) {
                sprintf(szBodyLabel, "%s_%d", pszCaseBodyLabel, iBodyCount++);
            }
        }
        else {                                                                                  // default
            if (nExprTypeSize == 1) {
                GenAsmOut(hOut, "", "jrmp", szBodyLabel, "  2: -> Default", TRUE, FALSE);
            }
            else {
                GenAsmOut(hOut, szTestLabel, "jrmp", szBodyLabel, "  2: -> Default", TRUE, FALSE);
            }
        }
    }

    iBodyCount = 1;
    sprintf(szBodyLabel, "%s_%d", pszCaseBodyLabel, iBodyCount++);

    for (pCase = pStat->Use._switch.pBody; pCase != NULL; pCase = pCase->pNext) {

        if (pCase->Use._case.pExpr != NULL) {                                                   // case
            if (pCase->Use._case.pBody != NULL) {
                GenAsmOut(hOut, szBodyLabel, ";      Case ----------------", "", "", TRUE, FALSE);
                GenStatements(hOut, pCase->Use._case.pBody, pszFunctionName, pszExitLabel, pszNewBreakLabel, pszContinueLabel);
                sprintf(szBodyLabel, "%s_%d", pszCaseBodyLabel, iBodyCount++);
            }
        }
        else {                                                                                  // default
            GenAsmOut(hOut, szBodyLabel, ";      Default -------------", "", "", TRUE, FALSE);
            GenStatements(hOut, pCase->Use._case.pBody, pszFunctionName, pszExitLabel, pszNewBreakLabel, pszContinueLabel);
        }
    }
    GenAsmOut(hOut, pszNewBreakLabel, ";      Switch end ----------", "", "", TRUE, FALSE);

}

// ##########################################################################
// #  Function: GenCase
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenCase(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {
    GenStatementIntro(hOut, pStat, pszFunctionName, "Case", "");
    Error(FATAL, "GenCase() Not yet implemented");
}

// ##########################################################################
// #  Function: GenStatements
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenStatements(FILE *hOut, TPStatement pStat, LPSTR pszFunctionName, LPSTR pszExitLabel, LPSTR pszBreakLabel, LPSTR pszContinueLabel) {

    while (pStat != NULL) {

        switch (pStat->Usage) {
        case    StatementCOMPOUND:  GenCompound(hOut, pStat, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel); break;
        case    StatementRETURN:    GenReturn(hOut, pStat, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel); break;
        case    StatementIF:        GenIf(hOut, pStat, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel); break;
        case    StatementWHILE:     GenWhile(hOut, pStat, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel); break;
        case    StatementDO:        GenDo(hOut, pStat, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel); break;
        case    StatementFOR:       GenFor(hOut, pStat, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel); break;
        case    StatementEXPR:      GenExpr(hOut, pStat, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel); break;
        case    StatementBREAK:     GenBreak(hOut, pStat, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel); break;
        case    StatementCONTINUE:  GenContinue(hOut, pStat, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel); break;
        case    StatementGOTO:      GenGoto(hOut, pStat, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel); break;
        case    StatementSWITCH:    GenSwitch(hOut, pStat, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel); break;
//      case    StatementCASE:      GenCase(hOut, pStat, pszFunctionName, pszExitLabel, pszBreakLabel, pszContinueLabel); break;
        default: Error(FATAL, "GenStatements(): unknown statement usage");
        }
        pStat = pStat->pNext;
    }
}


// ##########################################################################
// #  Function: GenCalcParamSize
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenParamVars(FILE *hOut, TPDeclSpec  pParams, int  iLocalsSize) {
#define REVERSE
    char        caString[256];
    int         iParamsSize;

    iParamsSize = 0;

    ASSERT(pParams->Use.DecId.pTarget->Usage == DecSpec);
    if ((pParams->Use.DecId.pTarget->Use.DecSpec.Type & TypeVOID) == TypeVOID) {
        GenAsmOut(hOut, "", "; #   Params: <none>", "", NULL, TRUE, FALSE);
        return iParamsSize;
    }

    LPSTR       pszIntro = "  Params: ";
    TPDeclSpec  pP;
#ifdef REVERSE
    int         iParamCounts;
    for (pP = pParams, iParamCounts = 0; pP != NULL; pP = pP->Use.DecId.pBrother, iParamCounts++);
    while (iParamCounts--) {
        int i;
        for (pP = pParams, i = 0; i < iParamCounts; pP = pP->Use.DecId.pBrother, i++); 
#else 
  for (pP = pParams ; pP != NULL; pP = pP->Use.DecId.pBrother) {
#endif // REVERSE
        ASSERT(pP->Use.DecId.pTarget->Usage == DecSpec);
        int iThisParamsSize = CalcSizeOf(pP->Use.DecId.pTarget);
        iParamsSize += iThisParamsSize;
        sprintf_s(caString, sizeof(caString), "; # %s@Y+%-3d, %s  size=%d %s",
            pszIntro,
            iLocalsSize + pP->Use.DecId.iOffset,
            pP->Use.DecId.pszName,
            iThisParamsSize,
            DescTypeString(pP->Use.DecId.pTarget->Use.DecSpec.Type));
        GenAsmOut(hOut, "", caString, "", NULL, TRUE, FALSE);
        pszIntro = "        : ";
    }

    return iParamsSize;
}


// ##########################################################################
// #  Function: CalcLocalSize
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int CalcLocalSize(TPStatement pStatment) {
    int         iReturnValue = 0;
    int         iMax1 = 0;
    int         iMax2 = 0;
    TPStatement pS;
    TPDeclSpec  pParams;


    if (pStatment == NULL) {            // statement was empty (eg "while(x--) ;")
        return 0;
    }

    switch (pStatment->Usage) {
    case    StatementCOMPOUND:
        iReturnValue = 0;           // size of locals here

        pParams = pStatment->Use._compound.pDeclList;
        if (pParams == NULL) {
            ;
        }
        else {
            while (pParams) {
                int iVarSize = CalcSizeOf(pParams->Use.DecId.pTarget);
                iReturnValue += iVarSize;
                pParams = pParams->Use.DecId.pBrother;
            }
        }

        for (pS = pStatment->Use._compound.pStatement; pS != NULL; pS = pS->pNext) {
            iMax1 = CalcLocalSize(pS);
            iMax2 = max(iMax1, iMax2);
        }
        return iReturnValue + iMax2;

    case    StatementIF:
        iMax1 = CalcLocalSize(pStatment->Use._if.pYes);
        iMax2 = CalcLocalSize(pStatment->Use._if.pNo);
        return max(iMax1, iMax2);

    case    StatementWHILE:
        return CalcLocalSize(pStatment->Use._while.pAction);

    case    StatementDO:
        return CalcLocalSize(pStatment->Use._do.pAction);

    case    StatementFOR:
        return CalcLocalSize(pStatment->Use._for.pAction);

    case    StatementRETURN:
    case    StatementEXPR:
    case    StatementBREAK:
    case    StatementCONTINUE:
    case    StatementGOTO:
    case    StatementSWITCH:
    case    StatementCASE:
        return 0;

    default: Error(FATAL, "CalcLocalSize(): unknown statement usage");
    }

    return 0;
}

// ##########################################################################
// #  Function: GenCalcLocalSize
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenLocalVars(FILE *hOut, TPStatement pStatment, int  iLocalsSize) {
    char        caString[256];

    int         iReturnValue = 0;
    int         iMax1 = 0;
    int         iMax2 = 0;
    TPStatement pS;
    TPDeclSpec  pParams;

    if (pStatment == NULL) {            // statement was empty (eg "while(x--) ;")
        return 0;
    }

    switch (pStatment->Usage) {
    case    StatementCOMPOUND:
        iReturnValue = 0;           // size of locals here

        LPSTR pszIntro = "  Locals: ";
        pParams = pStatment->Use._compound.pDeclList;
        if (pParams == NULL) {
            sprintf_s(caString, sizeof(caString), "; # %s<none>", pszIntro);
            GenAsmOut(hOut, "", caString, "", NULL, TRUE, FALSE);
        }
        else {
            while (pParams) {
                int iVarSize = CalcSizeOf(pParams->Use.DecId.pTarget);
                iReturnValue += iVarSize;
                ASSERT(pParams->Use.DecId.pTarget->Usage == DecSpec);
                sprintf_s(caString, sizeof(caString), "; # %s@Y+%-3d, %s  size=%d %s",
                    pszIntro,
                    iLocalsSize + pParams->Use.DecId.iOffset,
                    pParams->Use.DecId.pszName,
                    iVarSize,
                    DescTypeString(pParams->Use.DecId.pTarget->Use.DecSpec.Type));
                GenAsmOut(hOut, "", caString, "", NULL, TRUE, FALSE);

                pszIntro = "        : ";
                pParams = pParams->Use.DecId.pBrother;
            }
        }

        for (pS = pStatment->Use._compound.pStatement; pS != NULL; pS = pS->pNext) {
            iMax1 = GenLocalVars(hOut, pS, iLocalsSize);
            iMax2 = max(iMax1, iMax2);
        }
        return iReturnValue + iMax2;

    case    StatementIF:
        iMax1 = GenLocalVars(hOut, pStatment->Use._if.pYes, iLocalsSize);
        iMax2 = GenLocalVars(hOut, pStatment->Use._if.pNo, iLocalsSize);
        return max(iMax1, iMax2);

    case    StatementWHILE:
        return GenLocalVars(hOut, pStatment->Use._while.pAction, iLocalsSize);

    case    StatementDO:
        return GenLocalVars(hOut, pStatment->Use._do.pAction, iLocalsSize);

    case    StatementFOR:
        return GenLocalVars(hOut, pStatment->Use._for.pAction, iLocalsSize);

    case    StatementRETURN:
    case    StatementEXPR:
    case    StatementBREAK:
    case    StatementCONTINUE:
    case    StatementGOTO:
    case    StatementSWITCH:
    case    StatementCASE:
        return 0;

    default: Error(FATAL, "GenCalcLocalSize(): unknown statement usage");
    }

    return 0;
}




// ##########################################################################
// #  Function: GenFunction
// #        *public* <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenFunction(FILE *hOut, LPSTR pszName, TPDeclSpec pFunc) {
    char        caString[256];
    int         iParamsSize;
    int         iLocalsSize;
    int         iReturnSize;
    LPSTR       szExitLabel = GenLabel("_Exit_");

    ASSERT(pFunc->Usage == DecFunc);
    sprintf_s(caString, sizeof(caString), "; # Function: %s", pszName);
    GenAsmOut(hOut, pszName, "; ###########################################", "", NULL, TRUE, TRUE);
    GenAsmOut(hOut, "",      caString,                                        "", NULL, TRUE, FALSE);

    ASSERT(pFunc->Use.DecFunc.pReturnType->Usage == DecSpec);
    iReturnSize = CalcSizeOf(pFunc->Use.DecFunc.pReturnType);
    switch (iReturnSize) {
    case 0: sprintf_s(caString, sizeof(caString), "; #   Return: %s", DescTypeString(pFunc->Use.DecFunc.pReturnType->Use.DecSpec.Type)); break;
    case 1: sprintf_s(caString, sizeof(caString), "; #   Return: %s (r%d)", DescTypeString(pFunc->Use.DecFunc.pReturnType->Use.DecSpec.Type), EXP_REG_BASE); break;
    case 2: sprintf_s(caString, sizeof(caString), "; #   Return: %s (r%d,r%d)", DescTypeString(pFunc->Use.DecFunc.pReturnType->Use.DecSpec.Type), EXP_REG_BASE, EXP_REG_BASE + 1); break;
    case 4: sprintf_s(caString, sizeof(caString), "; #   Return: %s (r%d,r%d,r%d,r%d)", DescTypeString(pFunc->Use.DecFunc.pReturnType->Use.DecSpec.Type), EXP_REG_BASE, EXP_REG_BASE + 1, EXP_REG_BASE + 2, EXP_REG_BASE + 3); break;
    default:
        Error(ERRORX, "Function %s. returning more than 4 bytes is not supported", pszName);
        sprintf_s(caString, sizeof(caString), "; # Return: %s - size=%d NOT SUPPORTED", DescTypeString(pFunc->Use.DecFunc.pReturnType->Use.DecSpec.Type), iReturnSize);
    }
    GenAsmOut(hOut, "", caString, "", NULL, TRUE, FALSE);

    iLocalsSize = CalcLocalSize(pFunc->Use.DecFunc.pBody);
    iParamsSize = GenParamVars(hOut, pFunc->Use.DecFunc.pPList, iLocalsSize);
    sprintf_s(caString, sizeof(caString), "; #   CPU   : @Y+%d, Return Address", iLocalsSize+3);          GenAsmOut(hOut, "", caString, "", NULL, TRUE, FALSE);
    sprintf_s(caString, sizeof(caString), "; #         : @Y+%d, Preserved Frame Pointer", iLocalsSize+1); GenAsmOut(hOut, "", caString, "", NULL, TRUE, FALSE);
    iLocalsSize = GenLocalVars(hOut, pFunc->Use.DecFunc.pBody, iLocalsSize);
    sprintf_s(caString, sizeof(caString), "; #         : sizeof(locals) = %d", iLocalsSize);
    GenAsmOut(hOut, "", caString, "", NULL, TRUE, FALSE);
    GenAsmOut(hOut, "", "; ###########################################", "", NULL, TRUE, FALSE);

    
    if (iParamsSize + iLocalsSize == 0) {
        GenAsmOut(hOut, "", "; #### no frame needed #####", "", "no parameters or locals", TRUE, FALSE);
    }
    else {
        GenAsmOut(hOut, "", "; #### frame setup #########", "", "", TRUE, FALSE);
        GenAsmOut(hOut, "", "push", "r29", "  2: (YH) preserve Frame", TRUE, FALSE);
        GenAsmOut(hOut, "", "push", "r28", "  2: (YL)", TRUE, FALSE);
        GenAsmOut(hOut, "", "in", "r29, _IO_SPH", "  1: FP <- SP", TRUE, FALSE);
        GenAsmOut(hOut, "", "in", "r28, _IO_SPL", "  1:", TRUE, FALSE);
#pragma message("    GenFunction: iLocalsSize<? use dummy pushes to make local's space")

        if (iLocalsSize != 0) {
            GenAsmOut(hOut, "", "; #### alloc locals ########", "", "", TRUE, FALSE);
//          GenAsmOut(hOut, "", "movw", "r26, r28", "  1: X <- FP (equ SP)", TRUE, FALSE);
//          sprintf_s(caString, sizeof(caString), "r26, %d", iLocalsSize);
//          GenAsmOut(hOut, "", "sbiw", caString, "  2: X -= sizeof(locals)", TRUE, FALSE);
//          GenAsmOut(hOut, "", "out", "_IO_SPH, r27", "  1: SP <- X", TRUE, FALSE);
//          GenAsmOut(hOut, "", "out", "_IO_SPL, r26", "  1:", TRUE, FALSE);

            sprintf_s(caString, sizeof(caString), "r28, %d", iLocalsSize);
            GenAsmOut(hOut, "", "sbiw", caString, "  2: FP -= sizeof(locals))", TRUE, FALSE);
            GenAsmOut(hOut, "", "out", "_IO_SPH, r29", "  1: SP <- FP", TRUE, FALSE);
            GenAsmOut(hOut, "", "out", "_IO_SPL, r28", "  1:", TRUE, FALSE);


        }
    }
    GenAsmOut(hOut, "", "; #### body text ###########", "", "", TRUE, FALSE);

    iGlbLocalSize = iLocalsSize;                                                                // needed to displace local and parameter lookup into +ve offsets.
    GenStatements(hOut, pFunc->Use.DecFunc.pBody, pszName, szExitLabel, NULL, NULL);


    GenAsmOut(hOut, "", "; #### exit ################", "", "", TRUE, FALSE);
    if (iParamsSize + iLocalsSize == 0) {
        GenAsmOut(hOut, szExitLabel, "ret", "", " 4: ", TRUE, FALSE);
    }
    else {
//        GenAsmOut(hOut, szExitLabel, "out", "_IO_SPH, r29", "  1: SP <- FP", TRUE, FALSE);
//        GenAsmOut(hOut, "", "out", "_IO_SPL, r28", "  1:", TRUE, FALSE);
//        GenAsmOut(hOut, "", "pop", "r28", "  2: FP <- preserved Frame", TRUE, FALSE);
//        GenAsmOut(hOut, "", "pop", "r29", "  2: ", TRUE, FALSE);
//        GenAsmOut(hOut, "", "ret", "", "  4: ", TRUE, FALSE);

        sprintf_s(caString, sizeof(caString), "r28, %d", iLocalsSize);
        GenAsmOut(hOut, szExitLabel, "adiw", caString, "  2: Y += sizeof(locals)", TRUE, FALSE);
        GenAsmOut(hOut, "",          "out",  "_IO_SPH, r29", "  1: SP <- Y", TRUE, FALSE);
        GenAsmOut(hOut, "",          "out",  "_IO_SPL, r28", "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "",          "pop",  "r28",    "  2: FP <- preserved Frame", TRUE, FALSE);
        GenAsmOut(hOut, "",          "pop",  "r29",    "  2: ", TRUE, FALSE);
        GenAsmOut(hOut, "",          "ret",  "",       "  4: ", TRUE, FALSE);


    }
    GenAsmOut(hOut, "", "\n", "\n", NULL, TRUE, FALSE);
}


// ##########################################################################
// #  Function: GenText
// #        *public* <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenText(FILE *hOut, TPDeclSpec pDeclList) {
    //char szOperand[32];
    TPDeclSpec pDecl;

    GenAsmOut(hOut, NULL, NULL, NULL, "#########################", TRUE, FALSE);
    //GenAsmOut(hOut, NULL, NULL, NULL, "# Start of BSS segment #", TRUE, FALSE);
    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_BEGIN_TEXT, "", "# Start of TEXT segment #", TRUE, FALSE);
    GenAsmOut(hOut, NULL, "", "", "#########################", TRUE, FALSE);

    GenAsmOut(hOut, "", "", "", "Here starts the executable code", TRUE, FALSE);
    for (pDecl = pDeclList; pDecl; pDecl = pDecl->pChain) {
        if ((pDecl->Usage == DecId) &&
            GenIsFunction(pDecl->Use.DecId.pTarget->Usage)) {

            TPDeclSpec pF = pDecl->Use.DecId.pTarget;
            ASSERT(pF->Usage == DecFunc);
            GenFunction(hOut, pDecl->Use.DecId.pszName, pDecl->Use.DecId.pTarget);

        }
    }
    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_END, NULL, "=== End of TEXT segment ===\n\n", TRUE, FALSE);

}


/* eof */
