#include <conio.h>
#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <setjmp.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <assert.h>
#include <Windows.h>

//#include <ext\types.h>

#include "C_Yacced.tab.h"
#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "main.h"

/* *********************************************** */

/* *********************************************** */

/********************/
/* ENUM descriptors */
/********************/

LpEnumSet   Enums = NULL;

static BOOL
FindEnum(LpEnumElement El, LPSTR Name) {
    for (;El;El=El->Next) {
        if (!strcmp(El->ElementName, Name)) return TRUE;
    }
    return FALSE;
 }
    

LpEnumElement
FindEnumElement(LPSTR Name) {
    LpEnumSet       Set;
    LpEnumElement   El;
    for (Set=Enums; Set; Set=Set->Next)
        for (El=Set->Elements; El; El=El->Next)
            if (!strcmp(El->ElementName, Name))
                return El;
    return NULL;
 }
 
static BOOL
EnumDuplicate(LPSTR Name) {
    return (FindEnumElement(Name)) ? TRUE : FALSE;
 }

LpEnumElement
MakeEnumElement(LPSTR Name, LpExprNode Expr) {
    LpEnumElement NewEl;
    if (EnumDuplicate(Name)) Error1("Duplicate Enumeration Constant", Name);
    NewEl = New(sizeof(EnumElement));
    NewEl->ElementName  = Name;
    NewEl->Assigned     = FALSE;
    if (Expr) {
        NewEl->Assigned = TRUE;
        NewEl->Value    = ConstInt(Expr);
    }
    NewEl->Next         = NULL;
    return NewEl;
 }


LpEnumElement
AddEnumElement(LpEnumElement List, LpEnumElement New) {
    LpEnumElement Old = List;
    if (FindEnum(List,New->ElementName))  Error1("Repeated Enumeration Constant", New->ElementName);
    if (!List) {
        if (!New->Assigned) New->Value = 0;
        return New;
    }
    for (;Old->Next;Old = Old->Next);
    Old->Next = New;
    if (!New->Assigned) New->Value = 1+Old->Value;
    New->Next = NULL;
    return List;
 }


#ifdef _DEBUG
void
PrintEnumElements(LpEnumElement El) {
    printf("[ ");
    for (;El;El=El->Next) {
        printf("%s=%d%c ", El->ElementName, El->Value, (El->Next)?',':' ');
    }
    printf("] ");
 }
#endif //_DEBUG

LpEnumSet
FindEnumSet(LPSTR Name) {
    LpEnumSet Set=Enums;
    if (!strcmp(Name,"")) return NULL;                          // always fail with anonimous Set
    for (;(Set && strcmp(Name,Set->SetName)); Set=Set->Next) ;  // try find others
    return Set;
 }

LpEnumSet
AddEnumSet(LPSTR Name, LpEnumElement Elements) {
    LpEnumSet NewSet;
    if ((NewSet = FindEnumSet(Name)) == NULL) {                 // non existant so make new one
        NewSet = New(sizeof(EnumSet));
        NewSet->SetName  = Name;
        NewSet->Elements = Elements;
        NewSet->Next     = Enums;
        Enums = NewSet;
    } else {
        if (NewSet->Elements == NULL) {                         // first definition after a forward referance
            NewSet->Elements = Elements;
        } else {
            if (Elements != NULL) {                             // Attempted redefinition
                Error0("Redefinition of Enumerated Set ",Name);
            } else {
                ;                                               // backwards reference. OK ... do nowt
            }
                
        }
    }
    return NewSet;
 }

#ifdef _DEBUG

void
PrintEnumSet(LpEnumSet Set) {
    printf("Enum\t'%s'\t", Set->SetName);
    PrintEnumElements(Set->Elements);
}

void
PrintEnumSets(void) {
    LpEnumSet Set=Enums;
    printf("EMUMS\n");
    for (;Set; Set=Set->Next) {
        PrintEnumSet(Set);
        printf("\n");
    }
    printf("\n");

}
#endif // _DEBUG

/****************************/
/* STRUCT/UNION descriptors */
/****************************/

LpStructSet Structs = NULL;

LpStructSet
FindStructSet(LPSTR Name) {
    LpStructSet Set=Structs;
    if (!strcmp(Name,"")) return NULL;                          // always fail with anonimous Set
    for (;(Set && strcmp(Name,Set->SetName)); Set=Set->Next) ;  // try find others
    return Set;
}

LpStructSet
AddStructSet(LPSTR Name, BOOL Union, LpDeclSpec Elements) {
    LpStructSet NewSet;
    if ((NewSet = FindStructSet(Name)) == NULL) {               // non existant so make new one
        NewSet = New(sizeof(StructSet));
        NewSet->SetName  = Name;
        NewSet->Union    = Union;
        NewSet->Elements = Elements;
        NewSet->Next     = Structs;
        Structs          = NewSet;
    } else {
        if ((NewSet->Union == Union) &&
            (NewSet->Elements == NULL)) {                       // first definition after a forward reference
            NewSet->Elements = Elements;
        } else {
            if (Elements != NULL) {                             // Attempted redefinition
                Error0("Redefinition of Struct/Union ",Name);
            } else {
                ;                                               // backwards reference. OK ... do nowt
            }
                
        }
    }
    return NewSet;
}


#ifdef _DEBUG

static void
PrintStructSet(LpStructSet Set, BOOL Expand) {
    if (Set->Union) printf("Union\t");
    else            printf("Struct\t");
    printf("'%s'", Set->SetName);
    if (Expand) {
        printf("\t{\n");
        ParseDeclSpec(Set->Elements, TRUE);
        printf("}");
    }
}


void
PrintStructSets(void) {
    LpStructSet Set = Structs;
    printf("STRUCTS\n");
    for (;Set;Set=Set->Next) {
        PrintStructSet(Set,TRUE);
        printf("\n");
    }
    printf("\n");
}

#endif // _DEBUG



/* ******************************************************* */
/*  General Type Housekeeping  */
/* *************************** */

static LpDeclSpec
NewDeclSpec(Usage Use) {
    LpDeclSpec NewEl;
    NewEl = New(sizeof(DeclSpec));
    NewEl->Usage = Use;
    NewEl->Chain = NULL;
    return NewEl;
 }


static LpDeclSpec
NewSpecBlank(Usage Use) {
    LpDeclSpec NewEl;
    NewEl = NewDeclSpec(Use);
    switch (Use) {
        case DecSpec:   NewEl->Use.DecSpec.Class  = 0;
                        NewEl->Use.DecSpec.Type   = 0;
                        NewEl->Use.DecSpec.Qual   = 0;
                        NewEl->Use.DecSpec.Ptr    = NULL;
                        break;
        default:        printf("NewSpecBlank: %d is unknown !\n",(int)Use);
                        break;
    }
    return NewEl;
 }

/* ******************************************************* */
/*  Basic Types  */
/* ************* */

static WORD
DeclClass( WORD Set, WORD Element) {
    if (Set && (Set != Element))
        Warning0("More than one storage class specified", "");
    else
        Set |= Element;
    return Set;
 }




static WORD
DeclType(WORD Set, WORD Element) {
    if (((Element == TypeVOID)    && (Set & (         TypeCHAR|TypeINT|TypeFLOAT|TypeDOUBLE|TypeSIGNED|TypeUNSIGNED|TypeSHORT|TypeLONG))) ||
        ((Element == TypeCHAR)    && (Set & (TypeVOID|         TypeINT|TypeFLOAT|TypeDOUBLE                                           ))) ||
        ((Element == TypeINT)     && (Set & (TypeVOID|TypeCHAR|        TypeFLOAT|TypeDOUBLE                                           ))) ||
        ((Element == TypeFLOAT)   && (Set & (TypeVOID|TypeCHAR|TypeINT|          TypeDOUBLE|TypeSIGNED|TypeUNSIGNED|TypeSHORT|TypeLONG))) ||
        ((Element == TypeDOUBLE)  && (Set & (TypeVOID|TypeCHAR|TypeINT|TypeFLOAT|           TypeSIGNED|TypeUNSIGNED|TypeSHORT         ))) ||
        ((Element == TypeSHORT)   && (Set & (TypeVOID|TypeCHAR|        TypeFLOAT|TypeDOUBLE|                                  TypeLONG))) ||
        ((Element == TypeLONG)    && (Set & (TypeVOID|TypeCHAR|        TypeFLOAT|                                   TypeSHORT         ))) ||
        ((Element == TypeSIGNED)  && (Set & (TypeVOID|                 TypeFLOAT|TypeDOUBLE|           TypeUNSIGNED                   ))) ||
        ((Element == TypeUNSIGNED)&& (Set & (TypeVOID|                 TypeFLOAT|TypeDOUBLE|TypeSIGNED                                ))) ||
        ((Element == TypeENUM)    && (Set & (TypeVOID|TypeCHAR|TypeINT|TypeFLOAT|TypeDOUBLE|TypeSIGNED|TypeUNSIGNED|TypeSHORT|TypeLONG))) ||
        ((Element == TypeSTRUCT)  && (Set & (TypeVOID|TypeCHAR|TypeINT|TypeFLOAT|TypeDOUBLE|TypeSIGNED|TypeUNSIGNED|TypeSHORT|TypeLONG))) ||
        ((Element == TypeTYPEDEF) && (Set & (TypeVOID|TypeCHAR|TypeINT|TypeFLOAT|TypeDOUBLE|TypeSIGNED|TypeUNSIGNED|TypeSHORT|TypeLONG))))
            Warning0("Type declaration contains contradictory properties", "");
    else Set |= Element;
    return Set;
 }

static WORD
DeclQual(WORD Set, WORD Element) {
    if ((Set == 0) || (Set == Element)) return Element;
    Warning0("Type Qualification contains contradictory properties", "");
    return Set;
 }

static LPVOID
DeclPtr(LPVOID Set, LPVOID Element) {
    if (Set == 0) return Element;
    Warning0("Complex Type Qualification contains contradictory properties", "");
    return Set;
 }

LpDeclSpec
NewSpecClass(WORD Class) {
    LpDeclSpec NewEl = NewSpecBlank(DecSpec);
    NewEl->Use.DecSpec.Class = Class;
    return NewEl;
 }  
 
LpDeclSpec
NewSpecType(WORD Type, LPVOID Ptr) {
    LpDeclSpec NewEl = NewSpecBlank(DecSpec);
    NewEl->Use.DecSpec.Type = Type;
    NewEl->Use.DecSpec.Ptr  = Ptr;
    return NewEl;
 }

LpDeclSpec
NewSpecQual(WORD Qual) {
    LpDeclSpec NewEl = NewSpecBlank(DecSpec);
    NewEl->Use.DecSpec.Qual = Qual;
    return NewEl;
 }

static LpDeclSpec FindTarget(LpDeclSpec Ptr) {
    while (Ptr) {
        switch (Ptr->Usage) {
            case DecId:
                 Ptr = Ptr->Use.DecId.pTarget;
                 break;
            case DecSpec:
                 return Ptr;
            case DecPtr:
                 Ptr = Ptr->Use.DecPtr.pTarget;
                 break;
            case DecArray:
                 Ptr = Ptr->Use.DecArray.pTarget;
                 break;
            case DecFunc:
                 Ptr = Ptr->Use.DecFunc.pTarget;
                 break;
            default:
                printf("FindTarget: Unknown Use [%02x]\n", Ptr->Usage);
                return Ptr;
        }
    }
    assert(FALSE);
    return 0;
 }


LpDeclSpec
ConcatDeclSpec(LpDeclSpec Old, LpDeclSpec New) {
    LpDeclSpec O=FindTarget(Old);
    LpDeclSpec N=FindTarget(New);
    if (O->Usage != DecSpec) printf("ConcatDeclSpec: What 1!\n");
    if (N->Usage != DecSpec) printf("ConcatDeclSpec: What 2!\n");
    if (N->Use.DecSpec.Class)
        O->Use.DecSpec.Class = DeclClass(O->Use.DecSpec.Class,N->Use.DecSpec.Class); 
    if (N->Use.DecSpec.Type)
        O->Use.DecSpec.Type  = DeclType( O->Use.DecSpec.Type, N->Use.DecSpec.Type);
    if (N->Use.DecSpec.Qual)
        O->Use.DecSpec.Qual  = DeclQual( O->Use.DecSpec.Qual, N->Use.DecSpec.Qual); 
    if (N->Use.DecSpec.Ptr)
        O->Use.DecSpec.Ptr   = DeclPtr(  O->Use.DecSpec.Ptr,  N->Use.DecSpec.Ptr); 
    return Old;
 }

/* ******************************************** */

LpDeclSpec
NewPointer(LpDeclSpec Qualifier, LpDeclSpec Target) {
    WORD       q;
    if (!Qualifier) Qualifier = NewSpecQual(0);
    q = Qualifier->Use.DecSpec.Qual;
    Qualifier->Usage = DecPtr;                      // recycle as pointer
    Qualifier->Use.DecPtr.pTarget = Target;          // recycle as pointer
    Qualifier->Use.DecPtr.Qual   = q;               // recycle as pointer
    return Qualifier;
 }

LpDeclSpec
NewIdentifier(LPSTR Name) {
    LpDeclSpec N;
    N = NewDeclSpec(DecId);
    N->Use.DecId.pszName = Name;
    N->Use.DecId.pTarget = NULL;
    N->Use.DecId.pInitializer = NULL;
    N->Use.DecId.pBrother = NULL;
    return N;
 }

LpDeclSpec NewArray(LpDeclSpec Dec, LpExprNode Expr) {
    LpDeclSpec N;
    N = NewDeclSpec(DecArray);
    if (Expr) {
        if (Expr->Usage != uConst) {
            //ParseExpr(Expr, 0);
            Error0("Constant required for Array Dimentions.","");
            N->Use.DecArray.Size = 0;
        } else {
            N->Use.DecArray.Size = ConstInt(Expr);
        }
    } else {
            N->Use.DecArray.Size = 0;
    }
    N->Use.DecArray.pTarget = NULL;
    return AppendDecl(Dec,N);
 }

LpDeclSpec
NewFunc(LpDeclSpec Dec, LPVOID PList, LPVOID IdList) {
    LpDeclSpec N;
    N = NewDeclSpec(DecFunc);
    N->Use.DecFunc.PList  = PList;
    N->Use.DecFunc.IdList = IdList;
    N->Use.DecFunc.pTarget = NULL;
    return AppendDecl(Dec,N);
 }


LpDeclSpec AddInitializerStr(LpDeclSpec pDec, LPSTR pStr) {
    if (pDec->Usage != DecId) {
        printf("AddInitializer: Error1\n");
        return pDec;
    }
    pDec->Use.DecId.pszInitializerStr = pStr;
    //PrintInit(pStr); printf("\n");
    return pDec;
}


LpDeclSpec  AddInitializer(LpDeclSpec pDec, LpExprNode pInit) {
    if (pDec->Usage != DecId) {
        printf("AddInitializer: Error1\n");
        return pDec;
    }
    pDec->Use.DecId.pInitializer = pInit;
    PrintInit(pInit); printf("\n");
    return pDec;
 }


LpDeclSpec
AppendDecl(LpDeclSpec a,LpDeclSpec b) {
    LpDeclSpec c = a;
    if (!c) return b;
    for (;;) {
        switch (c->Usage) {
            case    DecId:
                    if (c->Use.DecId.pBrother) AppendDecl(c->Use.DecId.pBrother, b);
                    if (c->Use.DecId.pTarget) {
                        c = c->Use.DecId.pTarget;
                        break;
                    }  else {
                        c->Use.DecId.pTarget = b;
                        return a;
                    }
                    break;
            case    DecSpec:
                    printf("AppendDecl: Trouble append to Spec\n");
                    return a;
            case    DecPtr:
                    if (c->Use.DecPtr.pTarget) {
                        c = c->Use.DecPtr.pTarget;
                        break;
                    }  else {
                        c->Use.DecPtr.pTarget = b;
                        return a;
                    }
                    break;
            case    DecArray:
                    if (c->Use.DecArray.pTarget) {
                        c = c->Use.DecArray.pTarget;
                        break;
                    }  else {
                        c->Use.DecArray.pTarget = b;
                        return a;
                    }
                    break;
            case    DecFunc:
                    if (c->Use.DecFunc.pTarget) {
                        c = c->Use.DecFunc.pTarget;
                        break;
                    }  else {
                        c->Use.DecFunc.pTarget = b;
                        return a;
                    }
                    break;
            default:
                    printf("AppendDecl: Unknown Use\n");
                    break;
        }
    }
 }

LpDeclSpec
MakeBrother(LpDeclSpec a,LpDeclSpec b) {
    LpDeclSpec c;
    if (a->Usage != DecId || b->Usage != DecId) {
        printf("MakeBrother: Error1\n");
        return a;
    }
    for (c=a; c->Use.DecId.pBrother != NULL; c=c->Use.DecId.pBrother);
    c->Use.DecId.pBrother=b;
    return a;
 }



#ifdef _DEBUG
 
#define putch(x) putc((x),stdout) 
 
static void
DescClass(WORD q) {
    printf("Class[");
    putch((q & ClassAUTO)       ? 'A':'_');
    putch((q & ClassREGISTER)   ? 'R':'_');
    putch((q & ClassSTATIC)     ? 'S':'_');
    putch((q & ClassEXTERN)     ? 'E':'_');
    putch((q & ClassTYPEDEF)    ? 'T':'_');
    putch(']');
}

static void
DescType(WORD q) {
    printf("type[");
    if(q & TypeUNSIGNED) printf("unsigned ");
    if(q & TypeSIGNED)   printf("signed ");
    if(q & TypeDOUBLE)   printf("double ");
    if(q & TypeFLOAT)    printf("float ");
    if(q & TypeLONG)     printf("long ");
    if(q & TypeINT)      printf("int ");
    if(q & TypeSHORT)    printf("short ");
    if(q & TypeCHAR)     printf("char ");
    if(q & TypeVOID)     printf("void ");
    putch(']');
}

static void
DescQual(WORD q) {
    printf("Qual[");
    putch((q & QualCONST)   ? 'C':'_');
    putch((q & QualVOLATILE)? 'V':'_');
    putch((q & QualNEAR)    ? 'N':'_');
    putch((q & QualFAR)     ? 'F':'_');
    putch(']');
}

void
ParseDeclSpec(LpDeclSpec Ptr, BOOL DoBrothers) {
    if (!Ptr) {
            printf("..Null..\n");
            return;
    } else {
        switch (Ptr->Usage) {
            case    DecId:          // Id
                    printf("\t'%s'\t",Ptr->Use.DecId.pszName);
                    if (Ptr->Use.DecId.pInitializer) printf("I = ");
                    else                            printf("  = ");
                    ParseDeclSpec(Ptr->Use.DecId.pTarget, DoBrothers);
                    if (DoBrothers && Ptr->Use.DecId.pBrother) ParseDeclSpec(Ptr->Use.DecId.pBrother,DoBrothers);
                    return;
            case    DecSpec:
                    if      ((Ptr->Use.DecSpec.Type) & TypeSTRUCT)  { PrintStructSet(Ptr->Use.DecSpec.Ptr,FALSE); DescQual(Ptr->Use.DecSpec.Qual); }
                    else if ((Ptr->Use.DecSpec.Type) & TypeENUM)    { PrintEnumSet(Ptr->Use.DecSpec.Ptr);         DescQual(Ptr->Use.DecSpec.Qual); }
                    else if ((Ptr->Use.DecSpec.Type) & TypeTYPEDEF) { printf("Typedef "); ParseDeclSpec(Ptr->Use.DecSpec.Ptr,DoBrothers); }
                    else                                            { DescClass(Ptr->Use.DecSpec.Class); DescType(Ptr->Use.DecSpec.Type); DescQual(Ptr->Use.DecSpec.Qual); }
                    printf("\n");
                    return;
            case    DecPtr:
                    printf("P");  DescQual(Ptr->Use.DecPtr.Qual); printf("-> "); 
                    ParseDeclSpec(Ptr->Use.DecPtr.pTarget, DoBrothers);
                    return;
            case    DecArray:
                    printf("A[%ld]-> ", Ptr->Use.DecArray.Size);
                    ParseDeclSpec(Ptr->Use.DecArray.pTarget, DoBrothers);
                    return;
            case    DecFunc:
                    printf("F(...)<= ");
                    ParseDeclSpec(Ptr->Use.DecFunc.pTarget, DoBrothers);
                    return;
            default:
                    printf("ParseDeclSpec: Unknown Use\n");
                    return;
        }
    }
}


#endif // _DEBUG


/* ***************************************************************** */
/*  Declarations  */
/* ************** */

static LpDeclSpec
DuplicateD(LpDeclSpec Ptr) {
    LpDeclSpec New;
    New = NewDeclSpec(Ptr->Usage);
    *New = *Ptr;
    return New;
 }

static LpDeclSpec
DuplicateDecl(LpDeclSpec Ptr) {
    LpDeclSpec Start,Latest;
    if (!Ptr) return NULL;
    Start = Latest = DuplicateD(Ptr);
    while (Latest) {
        switch (Latest->Usage) {
            case DecId:
                    Latest->Use.DecId.pTarget = DuplicateD(Latest->Use.DecId.pTarget);
                    Latest = Latest->Use.DecId.pTarget;
                    break;
            case DecSpec:
                    return Start;
                    break;
            case DecPtr:
                    Latest->Use.DecPtr.pTarget = DuplicateD(Latest->Use.DecPtr.pTarget);
                    Latest = Latest->Use.DecPtr.pTarget;
                    break;
            case DecArray:
                    Latest->Use.DecArray.pTarget = DuplicateD(Latest->Use.DecArray.pTarget);
                    Latest = Latest->Use.DecArray.pTarget;
                    break;
            case DecFunc:
                    Latest->Use.DecFunc.pTarget = DuplicateD(Latest->Use.DecFunc.pTarget);
                    Latest = Latest->Use.DecFunc.pTarget;
                    break;
            default:
                printf("DuplicateDecl: Unknown Use [%02x]\n", Latest->Usage);
                return 0L;
        }
    }
    assert(FALSE);
    return 0;
}


static BOOL
IsClassProperty(LpDeclSpec Ptr, WORD Property) {
    while (Ptr) {
        switch (Ptr->Usage) {
            case DecId:
                    Ptr = Ptr->Use.DecId.pTarget;
                    break;
            case DecSpec:
                    return (Ptr->Use.DecSpec.Class & Property);
                    break;
            case DecPtr:
                    Ptr = Ptr->Use.DecPtr.pTarget;
                    break;
            case DecArray:
                    Ptr = Ptr->Use.DecArray.pTarget;
                    break;
            case DecFunc:
                    Ptr = Ptr->Use.DecFunc.pTarget;
                    break;
            default:
                printf("IsClassProperty: Unknown Use [%02x]\n", Ptr->Usage);
                return 0L;
        }
    }
    return FALSE;
 }

#define IsAuto(Ptr)     IsClassProperty(Ptr, ClassAUTO)
#define IsRegister(Ptr) IsClassProperty(Ptr, ClassREGISTER)
#define IsStatic(Ptr)   IsClassProperty(Ptr, ClassSTATIC)
#define IsExtern(Ptr)   IsClassProperty(Ptr, ClassEXTERN)
#define IsTypedef(Ptr)  IsClassProperty(Ptr, ClassTYPEDEF)

static void
StripClassProperty(LpDeclSpec Ptr, WORD Property) {
    while (Ptr) {
        switch (Ptr->Usage) {
            case DecId:
                    Ptr = Ptr->Use.DecId.pTarget;
                    break;
            case DecSpec:
                    Ptr->Use.DecSpec.Class &= ~Property;
                    return;
            case DecPtr:
                    Ptr = Ptr->Use.DecPtr.pTarget;
                    break;
            case DecArray:
                    Ptr = Ptr->Use.DecArray.pTarget;
                    break;
            case DecFunc:
                    Ptr = Ptr->Use.DecFunc.pTarget;
                    break;
            default:
                printf("StripClassProperty: Unknown Use [%02x]\n", Ptr->Usage);
                return;
        }
    }
    return;
 }

#define StripAuto(Ptr)     StripClassProperty(Ptr, ClassAUTO)
#define StripRegister(Ptr) StripClassProperty(Ptr, ClassREGISTER)
#define StripStatic(Ptr)   StripClassProperty(Ptr, ClassSTATIC)
#define StripExtern(Ptr)   StripClassProperty(Ptr, ClassEXTERN)
#define StripTypedef(Ptr)  StripClassProperty(Ptr, ClassTYPEDEF)

static BOOL
CompDeclStruct(LpDeclSpec a, LpDeclSpec b) {
    while (a && b) {
        if (a->Usage != b->Usage) return FALSE;
        switch (a->Usage) {
            case DecId:
                    a = a->Use.DecId.pTarget;
                    b = b->Use.DecId.pTarget;
                    break;
            case DecSpec:
                    return TRUE;
            case DecPtr:
                    a = a->Use.DecPtr.pTarget;
                    b = b->Use.DecPtr.pTarget;
                    break;
            case DecArray:
                    a = a->Use.DecArray.pTarget;
                    b = b->Use.DecArray.pTarget;
                    break;
            case DecFunc:
                    a = a->Use.DecFunc.pTarget;
                    b = b->Use.DecFunc.pTarget;
                    break;
            default:
                printf("CompDeclStruct: Unknown Use [%02x]\n", a->Usage);
                return FALSE;
        }
    }
    assert(FALSE);
    return 0;
 }


BOOL
CompDecl(LpDeclSpec a, LpDeclSpec b) {
    for (;;) {
        if (a->Usage == DecId) {                                         // case DecId
           if (b->Usage != DecId)       return FALSE;
           else {                       a = a->Use.DecId.pTarget;
                                        b = b->Use.DecId.pTarget;
           }
        } else if (a->Usage == DecSpec) {                                // case DecSpec
           if (b->Usage != DecSpec)     return FALSE;
           else { if (a->Use.DecSpec.Type != b->Use.DecSpec.Type)                 return FALSE;
                  if (!(a->Use.DecSpec.Type & (TypeSTRUCT|TypeENUM|TypeTYPEDEF))) return TRUE;
                  if (a->Use.DecSpec.Ptr == b->Use.DecSpec.Ptr)                   return TRUE;
                  return FALSE;
           }
        } else if (a->Usage == DecPtr) {                                 // case DecPtr
           a = a->Use.DecPtr.pTarget;
           if (b->Usage == DecArray)    b = b->Use.DecArray.pTarget;
           else if (b->Usage == DecPtr) b = b->Use.DecPtr.pTarget;
           else                         return FALSE;
        } else if (a->Usage == DecArray) {                               // case DecArray
           a = a->Use.DecArray.pTarget;
           if (b->Usage == DecArray)    b = b->Use.DecArray.pTarget;
           else if (b->Usage == DecPtr) b = b->Use.DecPtr.pTarget;
           else                         return FALSE;
        } else if (a->Usage == DecFunc) {                                // case DecFunc
                                        a = a->Use.DecFunc.pTarget;
                                        b = b->Use.DecFunc.pTarget;
        } else {
            printf("CompDecl: Unknown Use [%02x]\n", a->Usage);
            return FALSE;
        }
    }
 }



static BOOL
TestParams(LpDeclSpec a, LpDeclSpec b) {
    LpDeclSpec p1 = a->Use.DecFunc.PList;                   // a param 1
    LpDeclSpec p2 = b->Use.DecFunc.PList;                   // b param 1
    if (p1 == NULL) {                                       // Empty ? ... fill it
            a->Use.DecFunc.PList  = p2;
            return TRUE;
    }
    if (p2 == NULL) {
            b->Use.DecFunc.PList  = p1;
            return TRUE;
    }
    while (p1 && p2) {
        if (!strcmp(p1->Use.DecId.pszName,"...")) {            // Ellipsis ? ... fill it
            *p1 = *p2;
            return TRUE;
        }
        if (!strcmp(p2->Use.DecId.pszName,"...")) {
            *p2 = *p1;
            return TRUE;
        }
        if (!CompDecl(p1, p2))                              // Different ?
            return FALSE;                                   // Scrap it !
        p1 = p1->Use.DecId.pBrother;
        p2 = p2->Use.DecId.pBrother;
    }
    return ((p1 == NULL) && (p2 == NULL));
 }



/* *************************************************** */

LpDeclSpec  GlobalTypes;
LpDeclSpec  LocalTypes;
LpDeclSpec  GlobalObjects;
LpDeclSpec  LocalObjects;

static LpDeclSpec
FindDecl(LpDeclSpec List, LPSTR Name) {
    for ( ;
          (List != NULL && strcmp(List->Use.DecId.pszName,Name));
          List = List->Chain );
    return List;
 }

LpDeclSpec
FindType(LPSTR Name) {
    LpDeclSpec L;
    L = FindDecl(LocalTypes, Name);
    if (!L) L = FindDecl(GlobalTypes, Name);
    if (L)  StripTypedef(L);
    return DuplicateDecl(L);
}

LpDeclSpec
FindGlobalObject(LPSTR Name) {
    return FindDecl(GlobalObjects, Name);
}

LpDeclSpec
FindLocalObject(LPSTR Name) {
    return FindDecl(LocalObjects, Name);
}


LpDeclSpec
AddToDefintionList(LpDeclSpec List, LpDeclSpec Element) {
    LpDeclSpec L;                               // list pointer
    LpDeclSpec K,N;                             // known and new
    Element->Chain = NULL;
    if (List == NULL) return Element;
    for (L=List;L->Chain != NULL; L = L->Chain) {
        if (!strcmp(L->Use.DecId.pszName,Element->Use.DecId.pszName)) break;
    }
    if (!strcmp(L->Use.DecId.pszName,Element->Use.DecId.pszName)) {
        // redefinition.
        // Permit removal of extern flag
        // keep quite if identical and extern
        if (CompDeclStruct(L,Element)) {
            K=FindTarget(L);
            N=FindTarget(Element);
            if ((K->Use.DecSpec.Type == N->Use.DecSpec.Type) &&                         // Type Match and
                (K->Use.DecSpec.Qual == N->Use.DecSpec.Qual) &&                         // Qual Match and
                (((K->Use.DecSpec.Type & (TypeSTRUCT|TypeENUM|TypeTYPEDEF)) == 0) ||    //    not a complicated type or
                  (K->Use.DecSpec.Ptr == N->Use.DecSpec.Ptr))) {                        //    same complicated type
                  if ((Element->Use.DecId.pTarget->Usage == DecFunc) &&                  // Treat Func definitions as extern !
                      (TestParams(L->Use.DecId.pTarget, Element->Use.DecId.pTarget))) {   // As long as parampeters are OK.
                        return List;
                  } else if ((K->Use.DecSpec.Class == ClassEXTERN) ||                   // at least one is extern
                             (N->Use.DecSpec.Class == ClassEXTERN)) {
                        K->Use.DecSpec.Class &= N->Use.DecSpec.Class;
                        return List;
                  }
            }
        }
        Warning0("Ignoring the redefiniion of ",Element->Use.DecId.pszName);
    } else {
        L->Chain = Element;
    }
    return List;
 }

#ifdef _DEBUG
static void
ListDefinitions(LpDeclSpec List) {
    for (;List; List = List->Chain) {
        ParseDeclSpec(List,FALSE);
    }
 }

void
ListGlobalTypes(void) {
    printf("Global Types\n");
    ListDefinitions(GlobalTypes);
    printf("\n");
}

void
ListLocalTypes(void) {
    printf("Local Types\n");
    ListDefinitions(LocalTypes);
    printf("\n");
}

void
ListGlobalObjects(void) {
    printf("Global Objects\n");
    ListDefinitions(GlobalObjects);
    printf("\n");
}

void
ListLocalObjects(void) {
    printf("Local Objects\n");
    ListDefinitions(LocalObjects);
    printf("\n");
}
 
#endif // _DEBUG

static DWORD    CalcStructSize(LpStructSet Struct);
static BOOL     IsATypeDef(LpDeclSpec Ptr);

void
Declaration(LpDeclSpec Ptr, BOOL Global) {
    LpDeclSpec Tmp;
    while (Ptr) {
        if (!Ptr) {
            printf("Declaration: Declare Nothing ?\n");
            return;
        }
        if (Ptr->Usage != DecId) {
            // printf("Unnamed elements cannot be declared !\n");
            return;
        }
        
        // printf("%s\t", (Ptr->Use.DecId.Initializer) ? "Init":"");
        Tmp = Ptr->Use.DecId.pTarget;
        if (IsTypedef(Tmp)) {
            if (Global) GlobalTypes = AddToDefintionList(GlobalTypes,Ptr);
            else        LocalTypes  = AddToDefintionList(LocalTypes,Ptr);
        } else {
            CalcSizeOf(Tmp);
            if (Global) GlobalObjects = AddToDefintionList(GlobalObjects,Ptr);
            else        LocalObjects  = AddToDefintionList(LocalObjects,Ptr);
        }
        Ptr = Ptr->Use.DecId.pBrother;

    }
 }


static WORD
PtrDest(LpDeclSpec Target) {
    while (Target) {
        switch (Target->Usage) {
            case DecPtr:    return Target->Use.DecPtr.Qual;         // where is the pointer ?
            case DecFunc:   return QualCONST;                       // Functions must be in constant
            case DecSpec:   return Target->Use.DecSpec.Qual;        // Where is the base type ?
            case DecArray:  Target = Target->Use.DecArray.pTarget;
                            break;
            default:        printf("PtrDest: Trouble [%d]\n", Target->Usage);
                            return 0;
        }
    }
    printf("PtrDest: Trouble ?\n");
    assert(FALSE);
    return 0;
 }

 
#define TT(P,T) (((P)->Use.DecSpec.Type & (T)) == (T))

DWORD
CalcSizeOf(LpDeclSpec Ptr) {
    if (!Ptr) return 0L;
    switch (Ptr->Usage) {
        case    DecId:          // Id
                printf("CalcSizeOf of DecId '%s' !!!\n",Ptr->Use.DecId.pszName);
                return 0L;
        case    DecPtr:
                switch (PtrDest(Ptr->Use.DecPtr.pTarget)) {
                    case QualCONST:         return SIZE_PTR_CONST;
                    case QualVOLATILE:      return SIZE_PTR_VOLATILE;
                    case QualNEAR:          return SIZE_PTR_NEAR;
                    case QualFAR:           return SIZE_PTR_FAR;
                    default:                return SIZE_PTR_DEFAULT;
                }
        case    DecArray:
                return Ptr->Use.DecArray.Size * CalcSizeOf(Ptr->Use.DecArray.pTarget);
        case    DecFunc:
                return SIZE_FUNC;
        case    DecSpec:
                if      ((Ptr->Use.DecSpec.Type) & TypeENUM)    return 2L;
                else if ((Ptr->Use.DecSpec.Type) & TypeSTRUCT)  return CalcStructSize(Ptr->Use.DecSpec.Ptr);
                else if ((Ptr->Use.DecSpec.Type) & TypeTYPEDEF) return CalcSizeOf(Ptr->Use.DecSpec.Ptr);
                else {
                    if TT(Ptr,(TypeLONG|TypeDOUBLE))    return SIZE_LONGDOUBLE;
                    if TT(Ptr,TypeDOUBLE)               return SIZE_DOUBLE;
                    if TT(Ptr,TypeFLOAT)                return SIZE_FLOAT;
                    if TT(Ptr,TypeLONG)                 return SIZE_LONG;
                    if TT(Ptr,TypeSHORT)                return SIZE_SHORT;
                    if TT(Ptr,TypeINT)                  return SIZE_INT;
                    if TT(Ptr,TypeCHAR)                 return SIZE_CHAR;
                    if TT(Ptr,TypeSIGNED)               return SIZE_INT;
                    if TT(Ptr,TypeUNSIGNED)             return SIZE_INT;
                    if TT(Ptr,TypeVOID)                 return SIZE_VOID;
                    printf("CalcSizeOf: DecSpec.Type = %02x\n",Ptr->Use.DecSpec.Type);
                    return 0L;
                }
        default:
                printf("CalcSizeOf: Unknown Use\n");
                return 0L;
    }
}


static DWORD
CalcStructSize(LpStructSet Struct) {
    LpDeclSpec Elements = Struct->Elements;
    DWORD Total = 0L;
    if (!Elements)
        Error0("Object contains undefined Struct/Union ",Struct->SetName);
    if (Struct->Union) {
        while (Elements) {
            if (Elements->Usage != DecId) printf("CalcStructSize: U Problem !\n");
            Total = __max(Total, CalcSizeOf(Elements->Use.DecId.pTarget));
            Elements = Elements->Use.DecId.pBrother;
        }
    } else {
        while (Elements) {
            if (Elements->Usage != DecId) printf("CalcStructSize: S Problem !\n");
            Total += CalcSizeOf(Elements->Use.DecId.pTarget);
            Elements = Elements->Use.DecId.pBrother;
        }
    }
    return Total;
 }

LONG
CalcStructElementOffset(LpStructSet Struct, LPSTR Field) {
    LpDeclSpec Elements = Struct->Elements;
    LONG Total = 0L;
    if (!Elements)
        Error0("Object contains undefined Struct/Union ",Struct->SetName);
    if (Struct->Union) {
        while (Elements) {
            if (Elements->Usage != DecId) printf("CalcStructElementOffset: U Problem !\n");
            if (!strcmp(Field, Elements->Use.DecId.pszName)) return 0;
            Elements = Elements->Use.DecId.pBrother;
        }
    } else {
        while (Elements) {
            if (Elements->Usage != DecId) printf("CalcStructElementOffset: S Problem !\n");
            if (!strcmp(Field, Elements->Use.DecId.pszName)) return Total;
            Total += CalcSizeOf(Elements->Use.DecId.pTarget);
            Elements = Elements->Use.DecId.pBrother;
        }
    }
    return -1;
 }

LpDeclSpec
CalcStructElementType(LpStructSet Struct, LPSTR Field) {
    LpDeclSpec Elements = Struct->Elements;
    LONG Total = 0L;
    if (!Elements) Error0("Object contains undefined Struct/Union ",Struct->SetName);
    if (Struct->Union) {
        while (Elements) {
            if (Elements->Usage != DecId) printf("CalcStructElementType: U Problem !\n");
            if (!strcmp(Field, Elements->Use.DecId.pszName)) return Elements->Use.DecId.pTarget;
            Elements = Elements->Use.DecId.pBrother;
        }
    } else {
        while (Elements) {
            if (Elements->Usage != DecId) printf("CalcStructElementType: S Problem !\n");
            if (!strcmp(Field, Elements->Use.DecId.pszName)) return Elements->Use.DecId.pTarget;
            Elements = Elements->Use.DecId.pBrother;
        }
    }
    return NULL;
 }

                                                            // *****************************************
BOOL                                                        // Can the Type be represented in an integer
IsIntegralType(LpDeclSpec Type) {                           // *****************************************
    if (!Type) {
        printf("IsIntegralType: Null.\n");
        return FALSE;
    }
    switch (Type->Usage) {
        case DecPtr:
        case DecArray:
        case DecFunc:   return TRUE;
        case DecSpec:   return (!(Type->Use.DecSpec.Type &
                                 (TypeVOID|TypeFLOAT|TypeDOUBLE|
                               // TypeSTRUCT|TypeENUM|
                                 TypeTYPEDEF)));
        case DecId: 
        default:        printf("IsIntegralType: What Usage [%d].\n",Type->Usage);
                        return FALSE;
    }
}

                                                            // ***************************************
BOOL                                                        // Can the Type be represented in an Real
IsRealType(LpDeclSpec Type) {                               // ***************************************
    if (!Type) {
        printf("IsRealType: Null.\n");
        return FALSE;
    }
    switch (Type->Usage) {
        case DecPtr:
        case DecArray:
        case DecFunc:   return FALSE;
        case DecSpec:   return (Type->Use.DecSpec.Type &
                                (TypeFLOAT|TypeDOUBLE));
        case DecId: 
        default:        printf("IsRealType: What Usage [%d].\n",Type->Usage);
                        return FALSE;
    }
 }



/* eof */




