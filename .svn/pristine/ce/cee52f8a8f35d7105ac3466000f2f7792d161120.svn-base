%{
/* ************************************ */
/* Ansi C Grammar:                      */
/* Sean Kelly:  19.07.95                */
/* Based on K & R (Ansi C) Ed. 2        */
/* ************************************ */

#include <Windows.h>
#include <stdio.h>
//#include <ext\types.h>

#include "utilities\Console.h"

#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "main.h"

// Yacc generates two unreferenced lables for 'yynewerror' & 'yyerrlab'
#pragma warning(disable : 4102)


void    yyerror(PSTR s);
%}

/* Define terminal tokens */


/* keywords */
%token _AUTO            _DOUBLE          _INT             _STRUCT
%token _BREAK           _ELSE            _LONG            _SWITCH
%token _CASE            _ENUM            _REGISTER        _TYPEDEF
%token _CHAR            _EXTERN          _RETURN          _UNION
%token _CONST           _FLOAT           _SHORT           _UNSIGNED
%token _CONTINUE        _FOR             _SIGNED          _VOID
%token _DEFAULT         _GOTO            _SIZEOF          _VOLATILE
%token _DO              _IF              _STATIC          _WHILE
%token _NEAR            _FAR

/* ANSI Grammar suggestions */
%token  IDENTIFIER              STRINGliteral
%token  INTEGERconstant         CHARACTERconstant
%token  FLOATINGconstant        ENUMERATIONconstant 

%token  TYPEDEFname

/* Multi-Character operators */
%token  ARROW            /*    ->                              */
%token  INC DEC          /*    ++      --                      */
%token  LS RS            /*    <<      >>                      */
%token  LE GE EQ NE      /*    <=      >=      ==      !=      */
%token  ANDAND OROR      /*    &&      ||                      */
%token  ELLIPSIS         /*    ...                             */

/* modifying assignment operators */
%token MULTassign  DIVassign    MODassign   /*   *=      /=      %=      */
%token PLUSassign  MINUSassign              /*   +=      -=              */
%token LSassign    RSassign                 /*   <<=     >>=             */
%token ANDassign   XORassign     ORassign   /*   &=      ^=      |=      */


%union {
    DWORD   Integer;         // integral values
    DOUBLE  Real;            // Floating point
    LPSTR   Ident;           // labels/strings/identifiers etc
    BOOL    Bool;            // Boolean Stuff eg Struct or Union
    struct  {
            DOUBLE  pack;
            DWORD   LineNo,LinePos,OldNo,OldPos;
    } LineInfo;
    LPVOID  ptr;
}

%type <Ident>   IDENTIFIER
%type <ptr>     TYPEDEFname                 // lpDeclSpec
%type <ptr>     enumerator.list             // lpEnumElement
%type <ptr>     enumerator                  // lpEnumElement
%type <ptr>     enum.specifier              // lpEnumSet
%type <ptr>     declaration.specifiers      // LpDeclSpec
%type <ptr>     storage.class.specifier     // LpDeclSpec
%type <ptr>     type.specifier              // LpDeclSpec
%type <ptr>     type.qualifier              // LpDeclSpec
%type <ptr>     pointer                     // LpDeclSpec
%type <ptr>     type.qualifier.list         // LpDeclSpec
%type <ptr>     declarator                  // LpDeclSpec
%type <ptr>     direct.declarator           // LpDeclSpec
%type <ptr>     init.declarator             // LpDeclSpec
%type <ptr>     init.declarator.list        // LpDeclSpec
%type <ptr>     declaration                 // LpDeclSpec
%type <ptr>     struct.declaration.list     // LpDeclSpec
%type <ptr>     struct.declaration          // LpDeclSpec
%type <ptr>     specifier.qualifier.list    // LpDeclSpec
%type <ptr>     struct.declarator.list      // LpDeclSpec
%type <ptr>     struct.declarator           // LpDeclSpec
%type <ptr>     struct.or.union.specifier   // LpStructSet
%type <Bool>    struct.or.union

%type <ptr>     parameter.type.list         // LpExprNode
%type <ptr>     parameter.list              // LpExprNode
%type <ptr>     parameter.declaration       // LpExprNode
%type <ptr>     identifier.list             // LpExprNode
%type <ptr>     initializer                 // LpExprNode
%type <ptr>     initializer.list            // LpExprNode
%type <ptr>     type.name                   // LpDeclSpec
%type <ptr>     abstract.declarator         // LpDeclSpec
%type <ptr>     direct.abstract.declarator  // LpDeclSpec

%type <ptr>     expression                  // LpExprNode
%type <ptr>     assignment.expression       // LpExprNode
%type <Integer> assignment.operator         // ExprAssign
%type <ptr>     conditional.expression      // LpExprNode
%type <ptr>     constant.expression         // LpExprNode
%type <ptr>     logical.OR.expression       // LpExprNode
%type <ptr>     logical.AND.expression      // LpExprNode
%type <ptr>     inclusive.OR.expression     // LpExprNode
%type <ptr>     exclusive.OR.expression     // LpExprNode
%type <ptr>     AND.expression              // LpExprNode
%type <ptr>     equality.expression         // LpExprNode
%type <ptr>     relational.expression       // LpExprNode
%type <ptr>     shift.expression            // LpExprNode
%type <ptr>     additive.expression         // LpExprNode
%type <ptr>     multiplicative.expression   // LpExprNode
%type <ptr>     cast.expression             // LpExprNode
%type <ptr>     unary.expression            // LpExprNode
%type <Integer> unary.operator              // ExprUnOp
%type <ptr>     postfix.expression          // LpExprNode
%type <ptr>     primary.expression          // LpExprNode
%type <ptr>     argument.expression.list    // LpExprNode
%type <ptr>     constant                    // LpExprNode



%type <Ident>   STRINGliteral
%type <Integer> INTEGERconstant
%type <Integer> CHARACTERconstant
%type <Real>    FLOATINGconstant
%type <Integer> ENUMERATIONconstant 


%start prog.start

%%
prog.start:
      translation.unit
    ;

translation.unit:
      external.declaration
    | translation.unit external.declaration
    ;

external.declaration:
      function.definition                                           { ; }
    | declaration                                                   { Declaration($1, TRUE); }
    ;

function.definition:
                             declarator                  compound.statement
    | declaration.specifiers declarator                  compound.statement
    |                        declarator declaration.list compound.statement
    | declaration.specifiers declarator declaration.list compound.statement
    ;
    
declaration:
      declaration.specifiers                      ';'               { $$ = $1;                      }
    | declaration.specifiers init.declarator.list ';'               { $$ = AppendDecl($2,$1);       }
    ;

declaration.list:
      declaration                                                   { /* printf("Local Vars\n"); */ }
    | declaration.list declaration                                  { ;                             }
    ;

declaration.specifiers:
      storage.class.specifier                                       { $$ = $1;                      }   // NULL assume int !!!!
    | storage.class.specifier declaration.specifiers                { $$ = ConcatDeclSpec($2,$1);   }
    | type.specifier                                                { $$ = $1;                      }
    | type.specifier declaration.specifiers                         { $$ = ConcatDeclSpec($2,$1);   }
    | type.qualifier                                                { $$ = $1;                      }
    | type.qualifier declaration.specifiers                         { $$ = ConcatDeclSpec($2,$1);   }
    ;

storage.class.specifier:
      _AUTO                                                         { $$ = NewSpecClass(ClassAUTO);         }
    | _REGISTER                                                     { $$ = NewSpecClass(ClassREGISTER);     }
    | _STATIC                                                       { $$ = NewSpecClass(ClassSTATIC);       }
    | _EXTERN                                                       { $$ = NewSpecClass(ClassEXTERN);       }
    | _TYPEDEF                                                      { $$ = NewSpecClass(ClassTYPEDEF);      }
    ;

type.specifier:
      _VOID                                                         { $$ = NewSpecType(TypeVOID,    NULL); } // basic types
    | _CHAR                                                         { $$ = NewSpecType(TypeCHAR,    NULL); }
    | _SHORT                                                        { $$ = NewSpecType(TypeSHORT,   NULL); }
    | _INT                                                          { $$ = NewSpecType(TypeINT,     NULL); }
    | _LONG                                                         { $$ = NewSpecType(TypeLONG,    NULL); }
    | _FLOAT                                                        { $$ = NewSpecType(TypeFLOAT,   NULL); }
    | _DOUBLE                                                       { $$ = NewSpecType(TypeDOUBLE,  NULL); }
    | _SIGNED                                                       { $$ = NewSpecType(TypeSIGNED,  NULL); }
    | _UNSIGNED                                                     { $$ = NewSpecType(TypeUNSIGNED,NULL); }
    | struct.or.union.specifier                                     { $$ = NewSpecType(TypeSTRUCT,  $1);   }
    | enum.specifier                                                { $$ = NewSpecType(TypeENUM,    $1);   }
    | TYPEDEFname                                                   { $$ = $1;                             }
    ;

type.qualifier:
      _CONST                                                        { $$ = NewSpecQual(QualCONST);         }
    | _VOLATILE                                                     { $$ = NewSpecQual(QualVOLATILE);      }
    | _NEAR                                                         { $$ = NewSpecQual(QualNEAR);          }
    | _FAR                                                          { $$ = NewSpecQual(QualFAR);           }
    ;

struct.or.union.specifier:
      struct.or.union            '{' struct.declaration.list '}'    { $$ = AddStructSet("", $1, $3);    }
    | struct.or.union IDENTIFIER '{' struct.declaration.list '}'    { $$ = AddStructSet($2, $1, $4);    }
    | struct.or.union IDENTIFIER                                    { $$ = AddStructSet($2, $1, NULL);  }
    ;

struct.or.union:
      _STRUCT                                                       { $$ = FALSE;  }
    | _UNION                                                        { $$ = TRUE;   }
    ;

struct.declaration.list:
      struct.declaration                                            { $$ = $1;                  }
    | struct.declaration.list struct.declaration                    { $$ = MakeBrother($1,$2);  }
    ;
    
    
init.declarator.list:
      init.declarator                                               { $$ = $1;                      }
    | init.declarator.list ',' init.declarator                      { $$ = MakeBrother($1,$3);      }
    ;

init.declarator:
      declarator                                                    { $$ = $1;                      }
    | declarator '=' initializer                                    { $$ = AddInitializer($1,$3);   }
    ;

struct.declaration:
      specifier.qualifier.list struct.declarator.list ';'           { $$ = AppendDecl($2,$1);       }
    ;

specifier.qualifier.list:
      type.specifier                                                { $$ = $1;                      }
    | type.specifier specifier.qualifier.list                       { $$ = ConcatDeclSpec($2,$1);   }
    | type.qualifier                                                { $$ = $1;                      }
    | type.qualifier specifier.qualifier.list                       { $$ = ConcatDeclSpec($2,$1);   }
    ;

struct.declarator.list:
      struct.declarator                                             { $$ = $1;                      }
    | struct.declarator.list ',' struct.declarator                  { $$ = MakeBrother($1,$3);      }
    ;

struct.declarator:
      declarator                                                    { $$ = $1;                      }
    |            ':' constant.expression                            { ConsolePrintf(CON_CYAN,"StrDec :#2\n");       }
    | declarator ':' constant.expression                            { $$ = $1; ConsolePrintf(CON_CYAN,"StrDec:#3\n"); }
    ;

enum.specifier:
      _ENUM '{' enumerator.list '}'                                 { $$ = EnumSetAdd("",$3);       }
    | _ENUM IDENTIFIER '{' enumerator.list '}'                      { $$ = EnumSetAdd($2,$4);       }
    | _ENUM IDENTIFIER                                              { $$ = EnumSetAdd($2,NULL);     }
    ;

enumerator.list:
      enumerator                                                    { $$ = EnumElementAdd(NULL,$1); }
    | enumerator.list ',' enumerator                                { $$ = EnumElementAdd($1,$3);   }
    ;

enumerator:
      IDENTIFIER                                                    { $$ = EnumElementMake($1,NULL);}
    | IDENTIFIER '=' constant.expression                            { $$ = EnumElementMake($1,$3);  }
    ;

declarator:
              direct.declarator                                     { $$ = $1;                      }
    | pointer direct.declarator                                     { $$ = AppendDecl($2,$1);       }
    ;

direct.declarator:
      IDENTIFIER                                                    { $$ = NewIdentifier($1);       }
    | '(' declarator ')'                                            { $$ = $2;                      }
    | direct.declarator '['                     ']'                 { $$ = NewArray($1,NULL);       }
    | direct.declarator '[' constant.expression ']'                 { $$ = NewArray($1,$3);         }
    | direct.declarator '(' parameter.type.list ')'                 { $$ = NewFunc($1,$3,NULL);     }
    | direct.declarator '('                     ')'                 { $$ = NewFunc($1,NULL,NULL);   }
    | direct.declarator '(' identifier.list     ')'                 { $$ = NewFunc($1,NULL,$3);     }
    ;

pointer:
      '*'                                                           { $$ = NewPointer(NULL, NULL);  }
    | '*' type.qualifier.list                                       { $$ = NewPointer($2, NULL);    }
    | '*'                     pointer                               { $$ = NewPointer(NULL, $2);    }
    | '*' type.qualifier.list pointer                               { $$ = NewPointer($2, $3);      }
    ;

type.qualifier.list:
      type.qualifier                                                { $$ = $1;                      }
    | type.qualifier.list type.qualifier                            { $$ = ConcatDeclSpec($1,$2);   }
    ;

parameter.type.list:
      parameter.list                                                { $$ = $1;                      }
    | parameter.list ',' ELLIPSIS                                   { $$ = MakeBrother($1,NewIdentifier("..."));  }
    ;

parameter.list:
      parameter.declaration                                         { $$ = $1;                      }
    | parameter.list ',' parameter.declaration                      { $$ = MakeBrother($1,$3);      }
    ;

parameter.declaration:
      declaration.specifiers declarator                             { $$ = AppendDecl($2,$1);                              }
    | declaration.specifiers                                        { $$ = AppendDecl(NewIdentifier(""),$1);               }
    | declaration.specifiers abstract.declarator                    { $$ = AppendDecl(NewIdentifier(""),AppendDecl($2,$1));}
    ;

identifier.list:
      IDENTIFIER                                                    { $$ = NewIdentifier($1);                   }
    | identifier.list ',' IDENTIFIER                                { $$ = MakeBrother($1,NewIdentifier($3));   }
    ;

initializer:
      assignment.expression                                         { $$ = MakeInitNode($1);        }
    | '{' initializer.list '}'                                      { $$ = MakeInitList($2);        }
    | '{' initializer.list ',' '}'                                  { $$ = MakeInitList($2);        }
    ;

initializer.list:
      initializer                                                   { $$ = $1;                      }
    | initializer.list ',' initializer                              { $$ = MakeInitConcat($1,$3);   }
    ;

type.name:
      specifier.qualifier.list                                      { $$ = $1;                      } /* ***************** */
    | specifier.qualifier.list abstract.declarator                  { $$ = AppendDecl($2,$1);       }
    ;

abstract.declarator:
      pointer                                                       { $$ = $1;                      }
    | pointer direct.abstract.declarator                            { $$ = AppendDecl($2,$1);       }
    |         direct.abstract.declarator                            { $$ = $1;                      }
    ;

direct.abstract.declarator:
      '(' abstract.declarator ')'                                   { $$ = $2;                      }
    |                            '['                     ']'        { $$ = NewArray(NULL,NULL);     }
    | direct.abstract.declarator '['                     ']'        { $$ = NewArray($1,NULL);       }
    |                            '[' constant.expression ']'        { $$ = NewArray(NULL,$2);       }
    | direct.abstract.declarator '[' constant.expression ']'        { $$ = NewArray($1,$3);         }
    |                            '('                     ')'        { $$ = NewFunc(NULL,NULL,NULL); }
    | direct.abstract.declarator '('                     ')'        { $$ = NewFunc($1,NULL,NULL);   }
    |                            '(' parameter.type.list ')'        { $$ = NewFunc(NULL,NULL,NULL); } /* ***************** */
    | direct.abstract.declarator '(' parameter.type.list ')'        { $$ = NewFunc($1,NULL,NULL);   } /* ***************** */
    ;

statement:
      labeled.statement
    | expression.statement
    | compound.statement
    | selection.statement
    | iteration.statement
    | jump.statement
    ;

labeled.statement:
      IDENTIFIER ':' statement
    | _CASE constant.expression ':' statement
    | _DEFAULT ':' statement
    ;

expression.statement:
                 ';'
    | expression ';'
    ;

compound.statement:
      '{'                                 '}'
    | '{'                  statement.list '}'
    | '{' declaration.list                '}'
    | '{' declaration.list statement.list '}'
    ;

statement.list:
      statement
    | statement.list statement
    ;

selection.statement:
      _IF '(' expression ')' statement
    | _IF '(' expression ')' statement _ELSE statement
    | _SWITCH '(' expression ')' statement
    ;

iteration.statement:
      _WHILE '(' expression ')' statement
    | _DO statement _WHILE '(' expression ')'
    | _FOR '('            ';'            ';'            ')' statement
    | _FOR '(' expression ';'            ';'            ')' statement
    | _FOR '('            ';' expression ';'            ')' statement
    | _FOR '(' expression ';' expression ';'            ')' statement
    | _FOR '('            ';'            ';' expression ')' statement
    | _FOR '(' expression ';'            ';' expression ')' statement
    | _FOR '('            ';' expression ';' expression ')' statement
    | _FOR '(' expression ';' expression ';' expression ')' statement
    ;

jump.statement:
      _GOTO IDENTIFIER ';'
    | _CONTINUE ';'
    | _BREAK ';'
    | _RETURN            ';'
    | _RETURN expression ';'
    ;

expression:
      assignment.expression
    | expression ',' assignment.expression
    ;

assignment.expression:
      conditional.expression                                            { $$ = $1;                         }
    | unary.expression assignment.operator assignment.expression        { $$ = MakeAssignNode((ExprAssign)$2, $1, $3); }
    ;

assignment.operator:
      '='                                                               { $$ = AsNop;   }
    | MULTassign                                                        { $$ = AsMul;   }
    | DIVassign                                                         { $$ = AsDiv;   }
    | MODassign                                                         { $$ = AsMod;   }
    | PLUSassign                                                        { $$ = AsAdd;   }
    | MINUSassign                                                       { $$ = AsSub;   }
    | LSassign                                                          { $$ = AsSL;    }
    | RSassign                                                          { $$ = AsSR;    }
    | ANDassign                                                         { $$ = AsBAnd;  }
    | XORassign                                                         { $$ = AsBXor;  }
    | ORassign                                                          { $$ = AsBOr;   }
    ;

conditional.expression:
      logical.OR.expression                                             { $$ = $1;                                      }
    | logical.OR.expression '?' expression ':' conditional.expression   { $$ = MakeTernaryNode(CondExp, $1, $3, $5);    }
    ;

constant.expression:
      conditional.expression                                            { $$ = $1;                              }
    ;

logical.OR.expression:
      logical.AND.expression                                            { $$ = $1;                              }
    | logical.OR.expression OROR logical.AND.expression                 { $$ = MakeBinaryNode(LOr,$1,$3);       }
    ;

logical.AND.expression:
      inclusive.OR.expression                                           { $$ = $1;                              }
    | logical.AND.expression ANDAND inclusive.OR.expression             { $$ = MakeBinaryNode(LAnd,$1,$3);      }
    ;

inclusive.OR.expression:
      exclusive.OR.expression                                           { $$ = $1;                              }
    | inclusive.OR.expression '|' exclusive.OR.expression               { $$ = MakeBinaryNode(BOr,$1,$3);       }
    ;

exclusive.OR.expression:
      AND.expression                                                    { $$ = $1;                              }
    | exclusive.OR.expression '^' AND.expression                        { $$ = MakeBinaryNode(BXor,$1,$3);      }
    ;

AND.expression:
      equality.expression                                               { $$ = $1;                              }
    | AND.expression '&' equality.expression                            { $$ = MakeBinaryNode(BAnd,$1,$3);      }
    ;

equality.expression:
      relational.expression                                             { $$ = $1;                              }
    | equality.expression EQ relational.expression                      { $$ = MakeBinaryNode(CEQ,$1,$3);       }
    | equality.expression NE relational.expression                      { $$ = MakeBinaryNode(CNE,$1,$3);       }
    ;

relational.expression:
      shift.expression                                                  { $$ = $1;                              }
    | relational.expression '<' shift.expression                        { $$ = MakeBinaryNode(CLT,$1,$3);       }
    | relational.expression '>' shift.expression                        { $$ = MakeBinaryNode(CGT,$1,$3);       }
    | relational.expression LE  shift.expression                        { $$ = MakeBinaryNode(CLE,$1,$3);       }
    | relational.expression GE  shift.expression                        { $$ = MakeBinaryNode(CGE,$1,$3);       }
    ;

shift.expression:
      additive.expression                                               { $$ = $1;                              }
    | shift.expression LS additive.expression                           { $$ = MakeBinaryNode(BSL,$1,$3);       }
    | shift.expression RS additive.expression                           { $$ = MakeBinaryNode(BSR,$1,$3);       }
    ;

additive.expression:
      multiplicative.expression                                         { $$ = $1;                              }
    | additive.expression '+' multiplicative.expression                 { $$ = MakeBinaryNode(Add,$1,$3);       }
    | additive.expression '-' multiplicative.expression                 { $$ = MakeBinaryNode(Sub,$1,$3);       }
    ;

multiplicative.expression:
      cast.expression                                                   { $$ = $1;                              }
    | multiplicative.expression '*' cast.expression                     { $$ = MakeBinaryNode(Mul,$1,$3);       }
    | multiplicative.expression '/' cast.expression                     { $$ = MakeBinaryNode(Div,$1,$3);       }
    | multiplicative.expression '%' cast.expression                     { $$ = MakeBinaryNode(Mod,$1,$3);       }
    ;

cast.expression:
      unary.expression                                                  { $$ = $1;                              }
    | '(' type.name ')' cast.expression                                 { $$ = MakeCastNode($2,$4);             }
    ;

unary.expression:
      postfix.expression                                                { $$ = $1;                              }
    | INC unary.expression                                              { $$ = MakeUnaryNode(PreInc,$2);        }
    | DEC unary.expression                                              { $$ = MakeUnaryNode(PreDec,$2);        }
    | unary.operator cast.expression                                    { $$ = MakeUnaryNode((ExprUnOp)$1,$2);  }
    | _SIZEOF unary.expression                                          { $$ = MakeUnaryNode(SizeOf,$2);        }
    | _SIZEOF '(' type.name ')'                                         { $$ = MakeExprConstI(CalcSizeOf($3));  }
    ;

unary.operator:
      '&'                                                               { $$ = Addr;    }
    | '*'                                                               { $$ = Ptr;     }
    | '+'                                                               { $$ = Plus;    }
    | '-'                                                               { $$ = Minus;   }
    | '~'                                                               { $$ = Neg;     }
    | '!'                                                               { $$ = Not;     }
    ;

postfix.expression:
      primary.expression                                                { $$ = $1;                              }
    | postfix.expression '[' expression ']'                             { $$ = MakeArrayNode($1,$3);            }
    | postfix.expression '('                          ')'               { $$ = MakeFuncNode($1,NULL);           }
    | postfix.expression '(' argument.expression.list ')'               { $$ = MakeFuncNode($1,$3);             }
    | postfix.expression '.' IDENTIFIER                                 { $$ = MakeDotNode($1,$3);              }
    | postfix.expression ARROW IDENTIFIER                               { $$ = MakeArrowNode($1,$3);            }
    | postfix.expression INC                                            { $$ = MakeUnaryNode(PostInc,$1);       }
    | postfix.expression DEC                                            { $$ = MakeUnaryNode(PostDec,$1);       }
    ;

primary.expression:
      IDENTIFIER                                                        { $$ = MakeExprVar($1);                 }
    | constant                                                          { $$ = $1;                              }
    | STRINGliteral                                                     { $$ = MakeExprConstS($1);              }
    | '(' expression ')'                                                { $$ = $2;                              }
    ;

argument.expression.list:
      assignment.expression                                             { $$ = $1;                              }
    | argument.expression.list ',' assignment.expression                { $$ = $3;                              } /* ********** */
    ;

constant:
      INTEGERconstant                                                   { $$ = MakeExprConstI($1);              }
    | CHARACTERconstant                                                 { $$ = MakeExprConstC($1);              }
    | FLOATINGconstant                                                  { $$ = MakeExprConstF($1);              }
    | ENUMERATIONconstant                                               { $$ = MakeExprConstI($1);              }
    ;


%%

/* ----end of grammar----*/


void
yyerror(PSTR s) {
    Error(ERROR0, s,0L);
}


/* eof */
