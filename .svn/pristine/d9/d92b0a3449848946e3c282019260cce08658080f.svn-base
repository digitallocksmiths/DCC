
#define _CRT_SECURE_NO_WARNINGS

//#include <conio.h>
#include <stdio.h>
//#include <ctype.h>
//#include <signal.h>
//#include <setjmp.h>
//#include <stdlib.h>
//#include <memory.h>
//#include <string.h>
//#include <assert.h>
#include <Windows.h>

//#include "C_Yacced.tab.h"
#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "Gen.h"
#include "main.h"


#define GEN_PREFIX "L"
static WORD GenCount = 0;

LPSTR GenLabel(LPSTR PreFix) {
	LPSTR Label = New(strlen(GEN_PREFIX)+strlen(PreFix)+6+1);
	sprintf(Label, GEN_PREFIX "%s%06ld", PreFix, GenCount++);
	return Label;
 }


static void Pad(FILE *hOut, int n) {
    while (n>0) {
        fprintf(hOut, " ");
        n--;
    }
}


static void GenAsmOut(FILE *hOut, LPSTR pszLabel, LPSTR pszOpcode, LPSTR pszOperand, LPSTR pszComment, BOOL fNL) {
    int n;
    if ((pszLabel != NULL) && (*pszLabel != '\0')) { n = fprintf(hOut, "%s:", pszLabel); }
    else { n = 0; }
    Pad(hOut, LABEL_WIDTH - n);

    if ((pszOpcode != NULL) && (*pszOpcode != '\0')) { n = fprintf(hOut, "%s", pszOpcode); }
    else { n = 0; }
    Pad(hOut, OPCODE_WIDTH - n);

    if ((pszOperand != NULL) && (*pszOperand != '\0')) { n = fprintf(hOut, "%s", pszOperand); }
    else { n = 0; }
    Pad(hOut, OPERAND_WIDTH - n);

    if (pszComment != NULL) {
        n = fprintf(hOut, "; %s", pszComment);
        if (fNL) {
            fprintf(hOut, "\n");
        }
    }
    else {
        fprintf(hOut, "\n");
    }

}

static LPSTR sign_unsign(WORD T) {
    if ((T & TypeUNSIGNED) == TypeUNSIGNED) return "unsigned ";
    if ((T & TypeSIGNED) == TypeSIGNED)   return "signed ";
    return "";
}

BOOL GenIsData(WORD nUse) {
    switch (nUse) {
    case DecSpec:
    case DecPtr:
    case DecArray:  return TRUE;
    case DecId:
    case DecFunc:   return FALSE;
    default:
        Error(FATAL, "GenIsData() unknown use");
    }
    return FALSE;
}

#define TT(D,T) (((D) & (T)) == (T))


static void GenObjectComment(FILE *hOut, TPDeclSpec pDecl) {
    while (pDecl) {
        switch (pDecl->Usage) {
        case    DecId:          // Id
        case    DecFunc:        // Function 
            Error(FATAL, "GenBssObjectComment():  Unexpected Useage '%d'\n", pDecl->Usage);
            return;

        case    DecArray:
            fprintf(hOut, "Array[%ld] of ", pDecl->Use.DecArray.Size);
            pDecl = pDecl->Use.DecArray.pTarget;
            break;

        case    DecPtr:
            switch (pDecl->Use.DecPtr.Qual) {
            case QualCONST:    fprintf(hOut, "pointer to constant\n");  break;
            case QualVOLATILE: fprintf(hOut, "pointer to volatile\n");  break;
            case QualNEAR:     fprintf(hOut, "pointer to near\n");      break;
            case QualFAR:      fprintf(hOut, "pointer to far\n");       break;
            default:           fprintf(hOut, "pointer (generic)\n");   break;
            }
            return;

        case    DecSpec:
            if ((pDecl->Use.DecSpec.Type) & TypeSTRUCT) {
                TPStructSet p = pDecl->Use.DecSpec.pPtr;
                if (p->fUnion) fprintf(hOut, "union '%s'\n", p->szSetName);
                else           fprintf(hOut, "structure '%s'\n", p->szSetName);
                return;
            }
            else if ((pDecl->Use.DecSpec.Type) & TypeENUM) {
                TPEnumSet e = pDecl->Use.DecSpec.pPtr;
                fprintf(hOut, "enum '%s'\n", e->pszSetName);
                return;
            }
            else if ((pDecl->Use.DecSpec.Type) & TypeTYPEDEF) {
                fprintf(hOut, "typedef not yet supported\n");
                //ParseDeclSpec(pDecl->Use.DecSpec.Ptr, fDoBrothers); 
                return;
            }
            else {
                if   TT(pDecl->Use.DecSpec.Type, (TypeLONG | TypeDOUBLE))fprintf(hOut, "long double");
                else if TT(pDecl->Use.DecSpec.Type, TypeDOUBLE)          fprintf(hOut, "double");
                else if TT(pDecl->Use.DecSpec.Type, TypeFLOAT)           fprintf(hOut, "float");
                else if TT(pDecl->Use.DecSpec.Type, TypeLONG)            fprintf(hOut, "%slong", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeSHORT)           fprintf(hOut, "%sshort ", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeINT)             fprintf(hOut, "%sint", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeCHAR)            fprintf(hOut, "%schar", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeSIGNED)          fprintf(hOut, "signed");
                else if TT(pDecl->Use.DecSpec.Type, TypeUNSIGNED)        fprintf(hOut, "unsigned");
                else if TT(pDecl->Use.DecSpec.Type, TypeVOID)            fprintf(hOut, "void");
                else                                                     fprintf(hOut, "unknown type 0x%04x", pDecl->Use.DecSpec.Type);

                //              DescClass(pDecl->Use.DecSpec.Class); 
                //              DescQual(pDecl->Use.DecSpec.Qual); 
                fprintf(hOut, "\n");
            }
            return;

        default:
            Error(FATAL, "GenBssObjectComment(): Unknown Useage '%d'\n", pDecl->Usage);
            return;
        }
    }
}

// ##########################################################################################
// Data segment generator


static void SetupConstInitializer(TPDeclSpec T, LPSTR pszOpcode, LPSTR pszOperand, LPSTR pszComment, __int64 nVal, LPSTR pszName) {

    ASSERT(T->Usage == DecSpec || T->Usage == DecPtr);

    switch (CalcSizeOf(T)) {

    case 1: sprintf(pszOpcode, ASM_DIRECTIVE_BYTE);                                                                             // size = byte
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED) sprintf(pszOperand, "%hhu", (unsigned char)(nVal & 0xFF));    //          unsigned
        else                                                      sprintf(pszOperand, "%hhd", (signed char)(nVal & 0xFF));      //          signed
        if (pszComment != NULL) {                                                                                               // ? comment wanted?
            if (isprint((unsigned char)(nVal & 0xFF))) {                                                                        //
                sprintf(pszComment, "      '%c' 0x%02x -> %s", (char)nVal, (unsigned char)(nVal & 0xFF), pszName);              //          with prontable charater
            }                                                                                                                   //                
            else {                                                                                                              //
                sprintf(pszComment, "          0x%02x -> %s", (unsigned char)(nVal & 0xFF), pszName);                           //          without printable character
            }                                                                                                                   //
        }                                                                                                                       //
        return;                                                                                                                 //  return happy

    case 2: sprintf(pszOpcode, ASM_DIRECTIVE_SHORT); ;                                                                          // size = short
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED)  sprintf(pszOperand, "%hu", (unsigned short)(nVal & 0xFFFF)); //          unsigned
        else                                                       sprintf(pszOperand, "%hd", (signed short)(nVal & 0xFFFF));   //          signed
        if (pszComment != NULL) {                                                                                               // ? comment wanted?
            sprintf(pszComment, "        0x%04x -> %s", (unsigned short)(nVal & 0xFFFF), pszName);                              //
        }                                                                                                                       //
        return;                                                                                                                 //  return happy

    case 4: sprintf(pszOpcode, ASM_DIRECTIVE_LONG); ;                                                                           // size = long
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED)  sprintf(pszOperand, "%u", (unsigned int)nVal);               //          unsigned
        else                                                       sprintf(pszOperand, "%d", (signed int)nVal);                 //          signed
        if (pszComment != NULL) {                                                                                               // ? comment wanted?
            sprintf(pszComment, "    0x%08x -> %s", (unsigned int)(nVal & 0xFFFFFFFFL), pszName);                               //
        }                                                                                                                       //
        return;                                                                                                                 //  return happy

    default: sprintf(pszOpcode, "; unknown size");                                                                              // size unknown.
        Error(FATAL, "SetupConstInitializer(): Unsuported size of variable '%s', %d", pszName, CalcSizeOf(T));
        return ;                                                                                                                //  return not happy 
    }
}


static void SetupVarInitializer(TPDeclSpec T, LPSTR pszOpcode, LPSTR pszOperand, LPSTR pszComment, LPSTR pszVar, LPSTR pszName) {       // when the operand is a string (no need to calculate it or look it up)

    ASSERT(T->Usage == DecSpec || T->Usage == DecPtr);

    sprintf(pszOperand, "%s", pszVar);
    if (pszComment != NULL) {
            sprintf(pszComment, "               -> %s",  pszName);
    }

    switch (CalcSizeOf(T)) {
    case 1: sprintf(pszOpcode, ASM_DIRECTIVE_BYTE);
        break;
    case 2: sprintf(pszOpcode, ASM_DIRECTIVE_SHORT);
        break;
    case 4: sprintf(pszOpcode, ASM_DIRECTIVE_LONG);
        break;
    default: sprintf(pszOpcode, "; unknown size");
        Error(FATAL, "SetupVarInitializer(): Unknown size of variable '%s' %d", pszName, CalcSizeOf(T));
    }
}

static DWORD InitializerCount(TPExprNode pInit) {           // get the length of the initializer list.
    DWORD n = 0;
    while (pInit != 0) {
        n++;
        pInit = pInit->pSibling;
    }
    return n;
}

// ######################################################################################################################
static void GenDataObject(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit);     // forward declaration for recursion in struct definitions.


                                                                                    
// ##########################################################################
// #  Function: GenDataObjectString
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void GenDataObjectString(FILE *hOut, TPDeclSpec pTarget, LPSTR pszInit, LPSTR pszName) {         // Arrays Initialized by Strings
    char szOpcode[32];
    char szOperand[32];
    char szComment[256];
    char szName[256];
    DWORD dwPadding;

    DWORD dwIndex = 0;
    ASSERT(pTarget->Usage == DecArray);
//#pragma message("************** GenDataObjectString() where is the defined array size taken from?")



    int iNameLen = strlen(pszName);
    sprintf_s(szName, sizeof(szName), "%s[%ld]", pszName, dwIndex);

    DWORD dwArraySize = pTarget->Use.DecArray.Size;
    DWORD dwLen = strlen(pszInit)+1;                       // number of initializers
    if (dwArraySize == 0) {
        dwArraySize = dwLen;
        pTarget->Use.DecArray.Size = dwArraySize;
    }

    if (dwArraySize < dwLen) {
        //WarningGen("To many initializers", pszName);
        dwLen = dwArraySize;
    }
    dwPadding = dwArraySize - dwLen;
    
    while (dwLen--) {
        sprintf_s(&szName[iNameLen], sizeof(szName)- iNameLen, "[%ld]", dwIndex++);
        SetupConstInitializer(pTarget->Use.DecArray.pTarget, szOpcode, szOperand, szComment, *pszInit, szName);
        GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE);
        if (dwIndex == 1) {
            memset(szName, '-', iNameLen);
        }
        pszInit++;
    }

    //sprintf_s(szComment, sizeof(szComment), "               -> packed to %lu elements", dwSize);
    memset(szName, ' ', iNameLen);
    while (dwPadding--) {
        sprintf_s(&szName[iNameLen], sizeof(szName) - iNameLen, "[%ld]", dwIndex++);
        SetupConstInitializer(pTarget->Use.DecArray.pTarget, szOpcode, szOperand, szComment, 0, szName);
        GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE);
    }
}


// ##########################################################################
// #  Function: GenDataObjectPointer
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void GenDataObjectPointer(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {                                                           // Initialized pointers

    char szOpcode[32];
    char szOperand[32];
    char szComment[64];

    szOpcode[0] = 0;
    szOperand[0] = 0;
    szComment[0] = 0;

    if (pInit != NULL) {
        ASSERT(pInit->Usage == uInit);
        TPExprNode Val = pInit->Use.Init.pAssignment;

        if (pInit->Use.Init.pChildren != NULL) {                            // start of bracketed set when singleton is expected
            //WarningGen("Unexpected structure in initializer data for variable/field ", pszName);
            SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, 0, pszName);
        }

        if (Val->Usage == uConst) {                                                                     // Cost = OK
            unsigned __int64    nVal;
            nVal = Val->Use.Const.lInteger;
            SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, nVal, pszName);
            GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE);
            return;
        }
        if ((Val->Usage == uVar) &&                                                                    // var, only if it is an array = OK.
            (Val->pType->Usage == DecArray)) {
            SetupVarInitializer(pTarget, szOpcode, szOperand, szComment, Val->Use.Var.pszIdentifier, pszName);
            GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE);
            return;
        }
        if ((Val && Val->Usage == uUnary) &&                                                            // addr of var = OK
            (Val->Use.Unary.Op == Addr)) {
            TPExprNode E = Val->Use.Unary.pOperand;
            ASSERT(E->Usage == uVar);
            SetupVarInitializer(pTarget, szOpcode, szOperand, szComment, E->Use.Var.pszIdentifier, pszName);
            GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE);
            return;

        }
        Error(FATAL, "GenDataObjectPointer(): Non constant pointer value in initialization of ");
    }
    else {
        SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, 0, pszName);
    }

    GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE);
}

// ##########################################################################
// #  Function: GenDataObjectArray
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void GenDataObjectArray(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {                      // *** Initialized Arrays ***
    char szName[256];

    ASSERT(pInit == NULL || pInit->Usage == uInit);
    ASSERT(pTarget->Usage == DecArray);                                                             // we have an array for sure.

    DWORD      dwSize = pTarget->Use.DecArray.Size;
    DWORD      dwInit;
    TPDeclSpec pElement = pTarget->Use.DecArray.pTarget;
    ASSERT(pElement != NULL);

                                                                                                    // Specical behavior when init is from a string  *** It's Complicated ! ***
    if ((pElement->Usage == DecSpec) &&                                                             // If its and array of simple types (not an array of arrays) && 
        ((pElement->Use.DecSpec.Type & TypeSTRUCT) == 0) &&                                         //    its not a structure  &&
        (pInit != NULL && pInit->Use.Init.pAssignment)) {                                           //    we also have initialization via assignment
        TPExprNode  pA = pInit->Use.Init.pAssignment;                                               //      
        if (pA->Usage == uVar) {                                                                    //      If we have an asignment from a variable
            TPDeclSpec V = FindGlobalObject(pA->Use.Var.pszIdentifier);                             //          we can find it ...
            if (V != NULL) {                                                                        //
                if (V->Usage == DecId && V->Use.DecId.pszInitializedStr != 0) {                     //          is this  variable initialized by a string.
                    ASSERT(pTarget->Usage == DecArray);                                             //              so far so good.
                    //if (dwSize == 0) {                                                            //              if our array has no given size then
                    //    dwSize = strlen(V->Use.DecId.pszInitializedStr) + 1;                      //                  it's the string length (incl zero terminator)
                    //    pTarget->Use.DecArray.Size = dwSize;                                      //
                    //}                                                                             //
                    GenDataObjectString(hOut, pTarget, V->Use.DecId.pszInitializedStr, pszName);    //              create the initialized data from the string data.          
                    return;
                }
            }
        }
    }

    if (pInit != NULL && pInit->Use.Init.pChildren) {                                               // would expect bracketed list of initializers (but may be missing)
        pInit = pInit->Use.Init.pChildren;
    }
    dwInit = InitializerCount(pInit);                                                               // initializer count
    if (dwSize == 0) {                                                                              // if the declared count is zero
        dwSize = dwInit;                                                                            //      we use the initializers to fix up the count.
        pTarget->Use.DecArray.Size = dwSize;                                                        //
    }
    //else if (dwSize < dwInit) {                                                                     // if more initializers than we want 
    //    WarningGen("GenDataObjectArray(): Too many initializors for ", pszName);                    //      have a good moan at the user.
    //}                                                                                               //

    int iNameLen = strlen(pszName);
    sprintf_s(szName, sizeof(szName), "%s", pszName);
    for (DWORD dwIndex = 0; dwIndex < dwSize; dwIndex++) {                                          // for all the elements we want
        sprintf_s(&szName[iNameLen], sizeof(szName)-iNameLen, "[%ld]", dwIndex);                    //      text stuff to make variable name+index
        if (dwIndex == 1) {                                                                         //
            memset(szName, '-', iNameLen);                                                          //
        }                                                                                           //
                                                                                                    //
        ASSERT(pInit == NULL || pInit->Usage == uInit);                                             //
                                                                                                    //
        GenDataObject(hOut, szName, pElement, pInit);                                               //      recurse to define each array element            
                                                                                                    //
        //pElement = pElement->Use.DecId.pBrother;                                                  //
        if (pInit != NULL) {                                                                        //      
            pInit = pInit->pSibling;                                                                //      consume one initialization parameter per array element.
        }                                                                                           //
    }
}


// ##########################################################################
// #  Function: GenDataObjectUnion
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectUnion(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {
    char szName[256];

    ASSERT(pInit == NULL || pInit->Usage == uInit);
    ASSERT(pTarget->Usage == DecSpec);

    TPStructSet S = pTarget->Use.DecSpec.pPtr;
    TPDeclSpec pElement = S->pElements;

    if (pInit != NULL && pInit->Use.Init.pChildren) {
        pInit = pInit->Use.Init.pChildren;
    }

    DWORD dwUnionSize = CalcSizeOf(pTarget);
    DWORD dwFirstFieldSize = 0L;

    if (pElement != NULL) {
        ASSERT(pElement->Usage == DecId);
        dwFirstFieldSize = CalcSizeOf(pElement->Use.DecId.pTarget);
        sprintf_s(szName, sizeof(szName), "%s.%s", pszName, pElement->Use.DecId.pszName);
        GenDataObject(hOut, szName, pElement->Use.DecId.pTarget, pInit);
    }
    
    if (dwUnionSize > dwFirstFieldSize) {                                                       // if the field we generated is smaller than the union
        char szComment[256];
        DWORD dwPacking = dwUnionSize - dwFirstFieldSize;
        sprintf_s(szComment, sizeof(szComment), "               -> %s packed to size %lu", pszName, dwUnionSize);
        while (dwPacking--) {
            GenAsmOut(hOut, NULL, ASM_DIRECTIVE_BYTE, "0", szComment, TRUE);
            szComment[0] = 0;
        }
    }
}

// ##########################################################################
// #  Function: GenDataObjectStructure
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectStructure(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {           // Structure generation.
    char szName[256];
    
    ASSERT(pInit == NULL || pInit->Usage == uInit);
    ASSERT(pTarget->Usage == DecSpec);

    TPStructSet S = pTarget->Use.DecSpec.pPtr;
    TPDeclSpec pElement = S->pElements;
    
    if (pInit != NULL && pInit->Use.Init.pChildren) {
        pInit = pInit->Use.Init.pChildren;
    }

    while (pElement != NULL) {
        ASSERT(pElement->Usage == DecId);
        sprintf_s(szName, sizeof(szName), "%s.%s", pszName, pElement->Use.DecId.pszName);
        GenDataObject(hOut, szName, pElement->Use.DecId.pTarget, pInit);
        pElement = pElement->Use.DecId.pBrother;
        if (pInit != NULL) {
            pInit = pInit->pSibling;
        }
    }

}

// ##########################################################################
// #  Function: GenDataObjectEnum
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectEnum(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {                        // Enum value
    char szOpcode[32];
    char szOperand[32];
    char szComment[32];

#pragma message("    **** GenDataObjectEnum(): improvement. Comment could be the enum symbol name?")
    ASSERT(pInit->Usage == uInit);
    TPExprNode Val = pInit->Use.Init.pAssignment;

    int        nVal;
    if (Val->Usage != uConst) {
        Error(FATAL, "GenDataObjectEnum():  Non constant interger in Enum initialization of ");
        nVal = 0;
    }
    else {
        nVal = Val->Use.Const.lInteger;
    }

    SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, nVal, pszName);
    GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE);
}

// ##########################################################################
// #  Function: GenDataObjectTypedef
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectTypedef(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {
    Error(FATAL, "GenDataObjectTypedef(): Unimplemented");
}

// ##########################################################################
// #  Function: GenDataObjectBasetype
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectBasetype(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {
    
    char szOpcode[32];
    char szOperand[32];
    char szComment[256];
    unsigned __int64   nVal = 0L;

    if (pInit != NULL) {
        ASSERT(pInit->Usage == uInit);
       
        if (pInit->Use.Init.pChildren != NULL) {                            // start of braketed set whee singleton is expected
            // WarningGen("Unexpected structure in initializer data for variable/field ", pszName);
            nVal = 0;
        }
        else {
            TPExprNode pVal = pInit->Use.Init.pAssignment;
            ASSERT(pVal != NULL);
            if (pVal->Usage != uConst) {
                //Error(FATAL, "GenDataObjectBasetype(): Non constant integer in initialization.");
                nVal = 0;
            }
            else {
                nVal = pVal->Use.Const.lInteger;
            }
        }
    }
    SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, nVal, pszName);

    GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE);
}


// ##########################################################################
// #  Function: GenDataObject
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void GenDataObject(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {
    
    ASSERT(pInit == NULL || pInit->Usage == uInit);

    switch (pTarget->Usage) {
        case    DecId:          // Id
        case    DecFunc:        // Function 
            Error(FATAL, "GenDataObject():  Unexpected Useage '%d'\n", pTarget->Usage);
            return;

        case    DecArray:
            GenDataObjectArray(hOut, pszName, pTarget, pInit);
            return;

        case    DecPtr:
            GenDataObjectPointer(hOut, pszName, pTarget, pInit);
            return;

        case    DecSpec:
            // consider using BOOL IsIntegralType()????
            if ((pTarget->Use.DecSpec.Type) & TypeSTRUCT) {
                TPStructSet p = pTarget->Use.DecSpec.pPtr;
                if (p->fUnion) GenDataObjectUnion(hOut, pszName, pTarget, pInit);
                else           GenDataObjectStructure(hOut, pszName, pTarget, pInit);
                return;
            }
            else if ((pTarget->Use.DecSpec.Type) & TypeENUM) {
                TPEnumSet e = pTarget->Use.DecSpec.pPtr;
                GenDataObjectEnum(hOut, pszName, pTarget, pInit);
                return;
            }
            else if ((pTarget->Use.DecSpec.Type) & TypeTYPEDEF) {
                GenDataObjectTypedef(hOut, pszName, pTarget, pInit);
                return;
            }
            else {
                GenDataObjectBasetype(hOut, pszName, pTarget, pInit);
                return;
            }
            return;

        default:
            Error(FATAL, "GenDataObject(): Unknown Useage '%d'\n", pTarget->Usage);
            return;
        }

}


// ##########################################################################
// #  Function: GenData
// #        *public* <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void    GenConst(FILE *hOut, TPDeclSpec pDecl) {
    //char szOperand[32];
    TPDeclSpec pDeclList;

    GenAsmOut(hOut, NULL, NULL, NULL, "##########################", TRUE);
    GenAsmOut(hOut, NULL, NULL, NULL, "# Start of CONST segment #", TRUE);
    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_BEGIN, "CONST", "##########################", TRUE);

    for (pDeclList = pDecl; pDeclList; pDeclList = pDeclList->pChain) {                                 // auto generated string initializers
        if ((pDeclList->Usage == DecId) &&                                                              // Must be DecId
            GenIsData(pDeclList->Use.DecId.pTarget->Usage) &&                                           // Id's use must be storage rather than definition or code.
            (pDeclList->Use.DecId.pszInitializedStr)) {                                                 // If sz pointer used here it's an auto-gen string.

            TPDeclSpec pTarget = pDeclList->Use.DecId.pTarget;
            ASSERT(pTarget->Usage == DecArray);
            if (pDeclList->Use.DecId.UsedFlags == DecId_Used) {                                         //  we can skip this initialization because the array contents will be used to initialize a defined variable array.
                ;
            }
            else if (pDeclList->Use.DecId.UsedFlags == DecId_Refed) {                                   // we need a ROM copy of the data to be referenced by an initialized pointer.
                GenAsmOut(hOut, pDeclList->Use.DecId.pszName, NULL, NULL, "", FALSE);
                GenObjectComment(hOut, pTarget);
                GenDataObjectString(hOut, pTarget, pDeclList->Use.DecId.pszInitializedStr, "");
            }
            else {
//                Error(FATAL, "GenConst(): odd variable UsedFlags setting  = %x", pDeclList->Use.DecId.UsedFlags);
            }
        }
    }

    for (pDeclList = pDecl; pDeclList; pDeclList = pDeclList->pChain) {
        if ((pDeclList->Usage == DecId) &&
            GenIsData(pDeclList->Use.DecId.pTarget->Usage) &&
            (pDeclList->Use.DecId.pInitializer)) {

            TPDeclSpec pTarget = pDeclList->Use.DecId.pTarget;
            ASSERT(pTarget);
            if (IsTypeQualifierConst(pTarget)) {
                GenAsmOut(hOut, pDeclList->Use.DecId.pszName, NULL, NULL, "", FALSE);
                GenObjectComment(hOut, pTarget);
                GenDataObject(hOut, pDeclList->Use.DecId.pszName, pTarget, pDeclList->Use.DecId.pInitializer);
            }
        }
    }

    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_END, NULL, "=== End of CONST segment ===\n\n", TRUE);

}


// ##########################################################################
// #  Function: GenData
// #        *public* <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenData(FILE *hOut, TPDeclSpec pDecl) {
    //char szOperand[32];
    TPDeclSpec pDeclList;

    GenAsmOut(hOut, NULL, NULL, NULL, "#########################", TRUE);
    GenAsmOut(hOut, NULL, NULL, NULL, "# Start of DATA segment #", TRUE);
    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_BEGIN, "DATA", "#########################", TRUE);

    for (pDeclList = pDecl; pDeclList; pDeclList = pDeclList->pChain) {
        if ((pDeclList->Usage == DecId) &&
            GenIsData(pDeclList->Use.DecId.pTarget->Usage) &&
            (pDeclList->Use.DecId.pInitializer)) {

            TPDeclSpec pTarget = pDeclList->Use.DecId.pTarget;

            ASSERT(pTarget);
            if (!IsTypeQualifierConst(pTarget)) {
                GenAsmOut(hOut, pDeclList->Use.DecId.pszName, NULL, NULL, "", FALSE);
                GenObjectComment(hOut, pTarget);
                GenDataObject(hOut, pDeclList->Use.DecId.pszName, pTarget, pDeclList->Use.DecId.pInitializer);
            }
        }
    }

    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_END, NULL, "=== End of DATA segment ===\n\n", TRUE);

}

// ##########################################################################################
// Bss segment generator


// ##########################################################################
// #  Function: GenBss
// #        *public* <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenBss(FILE *hOut, TPDeclSpec pDecl) {
    char szOperand[32];

    GenAsmOut(hOut, NULL, NULL,                        NULL,  "########################", TRUE);
    GenAsmOut(hOut, NULL, NULL,                        NULL,  "# Start of BSS segment #", TRUE);
    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_BEGIN, "BSS", "########################", TRUE);

    for (; pDecl; pDecl = pDecl->pChain) {
        if ((pDecl->Usage == DecId) &&
            GenIsData(pDecl->Use.DecId.pTarget->Usage) &&
            !(pDecl->Use.DecId.pszInitializedStr || pDecl->Use.DecId.pInitializer)) {
            sprintf(szOperand, "%4d", CalcSizeOf(pDecl->Use.DecId.pTarget));
            GenAsmOut(hOut, pDecl->Use.DecId.pszName, ASM_DIRECTIVE_SPACE, szOperand, "", FALSE);
            GenObjectComment(hOut, pDecl->Use.DecId.pTarget);
        }
    }

    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_END, NULL, "=== End of BSS segment ===\n\n", TRUE);
}

/* eof */
