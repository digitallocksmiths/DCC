
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <setjmp.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <limits.h>
#include <float.h>
#include <Windows.h>

//#include <ext\types.h>

#include "C_Yacced.tab.h"
#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "gen.h"
#include "main.h"

/*
// ############################################################
#define GEN_PREFIX "L"
static DWORD GenCount = 0;

LPSTR
GenLabel(LPSTR PreFix) {
    LPSTR Label = New(strlen(GEN_PREFIX)+strlen(PreFix)+6+1);
    sprintf(Label, GEN_PREFIX "%s%06ld", PreFix, GenCount++);
    return Label;
 }
*/

/* ******************************************************* */
/*  General Expression Housekeeping  */
/* ********************************* */

static TPExprNode
NewExprNode(ExprUsage Use) {
    TPExprNode NewEl;
    NewEl = New(sizeof(TExprNode));
    NewEl->Usage   = Use;
    NewEl->pType    = NULL;
    return NewEl;
 }

TPExprNode
MakeExprConstC(LONG Value) {
    TPExprNode New;
    New = NewExprNode(uConst);
    New->pType = NewSpecType(TypeCHAR,NULL);
    New->Use.Const.lInteger = Value;
    return New;
 }

TPExprNode
MakeExprConstI(LONG Value) {
    TPExprNode New;
    New = NewExprNode(uConst);
    if      ((SCHAR_MIN <= Value) && (Value <= SCHAR_MAX)) New->pType = NewSpecType(TypeSIGNED|  TypeCHAR, NULL);
    else if ((0 <= Value)         && (Value <= UCHAR_MAX)) New->pType = NewSpecType(TypeUNSIGNED|TypeCHAR, NULL);
    else if ((SHRT_MIN <= Value)  && (Value <= SHRT_MAX))  New->pType = NewSpecType(TypeSIGNED|  TypeSHORT,NULL);
    else if ((0 <= Value)         && (Value <= USHRT_MAX)) New->pType = NewSpecType(TypeUNSIGNED|TypeSHORT,NULL);
    else if ((LONG_MIN <= Value)  && (Value <= LONG_MAX))  New->pType = NewSpecType(TypeSIGNED|  TypeLONG, NULL);
    else                                                   New->pType = NewSpecType(TypeUNSIGNED|TypeLONG, NULL);
    New->Use.Const.lInteger = Value;
    return New;
 }

TPExprNode
MakeExprConstF(DOUBLE Value) {
    Warning0("Floating point numbers are not supported.","");
    return MakeExprConstI((LONG)Value);
 }

TPExprNode
MakeExprConstS(LPSTR Str) {
    LPSTR Lab = GenLabel("Str");
    TPDeclSpec p;
    p = NewIdentifier(Lab);
    p = NewArray(p,NULL);
    p->Use.DecId.pTarget->Use.DecArray.Size = strlen(Str)+1;
    p = AddInitializerStr(p,Str);
    p = AppendDecl(p,NewSpecType(TypeCHAR,NULL));
    Declaration(p,TRUE);
    return MakeExprVar(Lab);
 }

TPExprNode
MakeExprVar(LPSTR Variable) {
    TPExprNode New;
    TPDeclSpec V;
    New = NewExprNode(uVar);
    V   = FindLocalObject(Variable);
    if (!V) V = FindGlobalObject(Variable);
    if (!V) {
        Error0("Unknown Variable ",Variable);
        New->pType = NewSpecType(TypeLONG,NULL);
    } else {
        New->pType = V->Use.DecId.pTarget;
    }
    New->Use.Var.pszIdentifier = Variable;
    return New;
 }

/* *************************************************** */

#define IsStruct(n)    (((n)->Usage == DecSpec) &&  ((n)->Use.DecSpec.Type & TypeSTRUCT))
#define IsSimple(n)    (((n)->Usage == DecSpec) && !((n)->Use.DecSpec.Type & TypeSTRUCT))
#define IsPointer(n)    ((n)->Usage == DecPtr)
#define IsArray(n)      ((n)->Usage == DecArray)
#define IsFunc(n)       ((n)->Usage == DecFunc)
#define IsReference(n)  (IsPointer(n) || IsArray(n))
#define IsPtrStruct(n)  (IsPointer(n) && IsStruct((n)->Use.DecPtr.pTarget))

/* *************************************************** */
      
TDeclSpec    Std_Ubyte   = { DecSpec, NULL, { 0, TypeUNSIGNED|TypeCHAR, 0, NULL } } ;
TDeclSpec    Std_Sbyte   = { DecSpec, NULL, { 0, TypeSIGNED|TypeCHAR,   0, NULL } } ;
TDeclSpec    Std_Uword   = { DecSpec, NULL, { 0, TypeUNSIGNED|TypeSHORT,0, NULL } } ;
TDeclSpec    Std_Sword   = { DecSpec, NULL, { 0, TypeSIGNED|TypeSHORT,  0, NULL } } ;
TDeclSpec    Std_Ulong   = { DecSpec, NULL, { 0, TypeUNSIGNED|TypeLONG, 0, NULL } } ;
TDeclSpec    Std_Slong   = { DecSpec, NULL, { 0, TypeSIGNED|TypeLONG,   0, NULL } } ;

TPDeclSpec  LpStd_Ubyte = &Std_Ubyte;
TPDeclSpec  LpStd_Sbyte = &Std_Sbyte;
TPDeclSpec  LpStd_Uword = &Std_Uword;
TPDeclSpec  LpStd_Sword = &Std_Sword;
TPDeclSpec  LpStd_Ulong = &Std_Ulong;
TPDeclSpec  LpStd_Slong = &Std_Slong;




//static LpExprNode
//Cast(LpExprNode Left, LpDeclSpec Newtype) {
//#pragma message("Cast:  insert convert operand size code.")
//    return Left;
//}

///* ************************************************************ */
///*  pointer and node return the smallest integral pointer type  */
///* ************************************************************ */
//
//static LpDeclSpec
//CastToValidPointer(LpDeclSpec Ptr) {
//    if      (CalcSizeOf(Ptr) <= SIZE_CHAR)  return NewSpecType(TypeUNSIGNED|TypeCHAR,NULL);
//    else if (CalcSizeOf(Ptr) <= SIZE_SHORT) return NewSpecType(TypeUNSIGNED|TypeSHORT,NULL);
//    else                                    return NewSpecType(TypeUNSIGNED|TypeLONG,NULL);
//}

///* ************************************************************ */
///*  Make a binary node and insert the required castings         */
///* ************************************************************ */
//
//static LpExprNode
//FixCastings(LpExprNode New, LpExprNode Left, LpExprNode Right) {
//    if (!CompDecl(New->Type,Left->Type))  Left = MakeCastNode(New->Type, Left);
//    if (!CompDecl(New->Type,Right->Type)) Right= MakeCastNode(New->Type, Right);
//    New->Use.Binary.Left  = Left;
//    New->Use.Binary.Right = Right;
//    return New;
// }

/* ************************************************** */
/*  Unary  */
/* ******* */

static TPExprNode
NewUnary(WORD Op,  TPExprNode Node) {
    TPExprNode New;
    New = NewExprNode(uUnary);
    New->Use.Unary.Op = Op;             // operation  
    New->Use.Unary.pOperand = Node;      // target of operation
    New->pType = Node->pType;             // assume no change in type.
    return New;
 }
 
static TPExprNode
UMinus(TPExprNode Node) {
    TPExprNode New;
    if (!IsSimple(Node->pType)) {
        Warning0("Unary arithmetic is only posible on simple types.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Node->Use.Const.lInteger = -(Node->Use.Const.lInteger);
        return Node;
    } else {
        New = NewUnary(Minus, Node);
        return  New;
    }
 }
 
static TPExprNode
UPlus(TPExprNode Node) {
    if (!IsSimple(Node->pType)) {
        Warning0("Unary arithmetic is only posible on simple types.","");
        return Node;
    }
    return Node;
 }
 
static TPExprNode
UNeg(TPExprNode Node) {
    TPExprNode New;
    if (!IsSimple(Node->pType)) {
        Warning0("Unary arithmetic is only posible on simple types.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Node->Use.Const.lInteger = ~(Node->Use.Const.lInteger);
        return Node;
    } else {
        New = NewUnary(Neg, Node);
        return  New;
    }
 }
 
static TPExprNode
UNot(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Warning0("Unary logic is not possible on struct/union.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Node->Use.Const.lInteger = !(Node->Use.Const.lInteger);
        return Node;
    } else {
        New = NewUnary(Not, Node);
        New->pType = LpStd_Ubyte;
        return  New;
    }
 }
 
static TPExprNode
UPostInc(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Warning0("Cannot perform '++'/'--' on a structure.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error0("'++' or '--' on a Constant is bit dumb.","");
        return Node;
    } else {
        New = NewUnary(PostInc, Node);
        return  New;
    }
 }
 
static TPExprNode
UPreInc(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Warning0("Cannot perform '++'/'--' on a structure.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error0("'++' or '--' on a Constant is bit dumb.","");
        return Node;
    } else {
        New = NewUnary(PreInc, Node);
        return  New;
    }
 }
 
static TPExprNode
UPostDec(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Warning0("Cannot perform '++'/'--' on a structure.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error0("'++' or '--' on a Constant is bit dumb.","");
        return Node;
    } else {
        New = NewUnary(PostDec, Node);
        return  New;
    }
 }
 
static TPExprNode
UPreDec(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Warning0("Cannot perform '++'/'--' on a structure.","");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error0("'++' or '--' on a Constant is bit dumb.","");
        return Node;
    } else {
        New = NewUnary(PreDec, Node);
        return  New;
    }
 }
 
static TPExprNode
USizeof(TPExprNode Node) {
    return MakeExprConstI(CalcSizeOf(Node->pType));
 }
 
static TPExprNode
UAddr(TPExprNode Node) {
    TPExprNode New;
    if (Node->Usage == uConst)  {
        Error0("Address of constant is meaningless.","");
        return Node;
    } else {
        New = NewUnary(Addr, Node);
        New->pType = NewPointer(NULL,Node->pType);
        return  New;
    }
 }

                          
static TPExprNode
UPtr(TPExprNode Node) {
    TPExprNode New;
    if (Node->pType->Usage == DecPtr) {
        New = NewUnary(Ptr, Node);
        New->pType = Node->pType->Use.DecPtr.pTarget;
        return  New;
    } else if (Node->pType->Usage == DecArray) {
        New = NewUnary(Ptr, Node);
        New->pType = Node->pType->Use.DecArray.pTarget;
        return  New;
    } else {
        Error0("De-Reference of a Non pointer type","");
        return Node;
    }
 }


TPExprNode
MakeUnaryNode(WORD Op,  TPExprNode Node) {
    switch (Op) {
        case    Minus:      return UMinus(Node);
        case    Plus:       return UPlus(Node);
        case    Neg:        return UNeg(Node);
        case    Not:        return UNot(Node);
        case    PostInc:    return UPostInc(Node);
        case    PreInc:     return UPreInc(Node);
        case    PostDec:    return UPostDec(Node);
        case    PreDec:     return UPreDec(Node);
        case    SizeOf:     return USizeof(Node);
        case    Addr:       return UAddr(Node);
        case    Ptr:        return UPtr(Node);
        default:            printf("MakeUnaryNode: UnKnown Unary Operator %d\n", Op);
                            return Node;        
    }
 }

/* ************************************************** */
/*  Binary  */
/* ******** */

static TPDeclSpec
ResultingType(TPDeclSpec Left, TPDeclSpec Right) {
#pragma message("ResultingType: calculate result of combination.")
    return Left;
}


static TPExprNode
NewBinary(WORD Op,  TPExprNode Left, TPExprNode Right) {
    TPExprNode New;
    New = NewExprNode(uBinary);
    New->Use.Binary.Op    = Op;                         // operation  
    New->Use.Binary.pLeft  = Left;                       // target of operation
    New->Use.Binary.pRight = Right;                      // target of operation
    New->pType = ResultingType(Left->pType,Right->pType);  // assume no change in type.
    return New;
 }

static TPExprNode Badd (TPExprNode Left, TPExprNode Right);
static TPExprNode Bsub (TPExprNode Left, TPExprNode Right);
static TPExprNode Bmul (TPExprNode Left, TPExprNode Right);
static TPExprNode Bdiv (TPExprNode Left, TPExprNode Right);
static TPExprNode Bmod (TPExprNode Left, TPExprNode Right);
static TPExprNode Bband(TPExprNode Left, TPExprNode Right);
static TPExprNode Bbor (TPExprNode Left, TPExprNode Right);
static TPExprNode Bbxor(TPExprNode Left, TPExprNode Right);
static TPExprNode Bceq (TPExprNode Left, TPExprNode Right);
static TPExprNode Bcne (TPExprNode Left, TPExprNode Right);
static TPExprNode Bclt (TPExprNode Left, TPExprNode Right);
static TPExprNode Bcle (TPExprNode Left, TPExprNode Right);
static TPExprNode Bcgt (TPExprNode Left, TPExprNode Right);
static TPExprNode Bcge (TPExprNode Left, TPExprNode Right);
static TPExprNode Bland(TPExprNode Left, TPExprNode Right);
static TPExprNode Blor (TPExprNode Left, TPExprNode Right);
static TPExprNode Bbsr (TPExprNode Left, TPExprNode Right);
static TPExprNode Bbsl (TPExprNode Left, TPExprNode Right);



static TPExprNode
Badd (TPExprNode Left, TPExprNode Right) {
    TPExprNode New;
    TPDeclSpec NewType;
    if (IsStruct(Left->pType) || IsStruct(Right->pType)) {
        Error0("Addition of Structures is not possible.\n","");
        return Left;
    }
    if (IsReference(Left->pType) && IsReference(Right->pType)) {
        Error0("Addition of References is not possible.\n","");
        return Left;
    }
    if (IsSimple(Left->pType) && IsReference(Right->pType)) {
        New   = Right;
        Right = Left;
        Left  = New;
        /* fall through (then pass) next test */
    }
    if (IsReference(Left->pType) && IsSimple(Right->pType)) {
        if (IsPointer(Left->pType)) Right = Bmul(Right, MakeExprConstI(CalcSizeOf(Left->pType->Use.DecPtr.pTarget)));
        else                       Right = Bmul(Right, MakeExprConstI(CalcSizeOf(Left->pType->Use.DecArray.pTarget)));
        /* fall through to simple add */
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger += Right->Use.Const.lInteger;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Add")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType, Left);
        Right   = MakeCastNode(NewType, Right);
        return NewBinary(Add,Left,Right);
    }
 }

static TPExprNode
Bsub (TPExprNode Left, TPExprNode Right) {
    TPExprNode New;
    TPDeclSpec NewType;
    if (IsStruct(Left->pType) || IsStruct(Right->pType)) {
        Error0("Subtraction of Structures is not possible.\n","");
        return Left;
    }
    if (IsReference(Left->pType) && IsReference(Right->pType)) {
        if (!CompDecl(Left->pType, Right->pType)) {
            Error0("Subtraction of dissimilar references is not possible.\n","");
            return Left;
        }
        if (Left->Usage == uConst && Right->Usage == uConst) {
            Left->Use.Const.lInteger -= Right->Use.Const.lInteger;
            Left->Use.Const.lInteger /= CalcSizeOf(Right->pType->Use.DecPtr.pTarget);
            switch(CalcSizeOf(Left->pType)) {
                case 1: Left = MakeCastNode(LpStd_Ubyte, Left); break;
                case 2: Left = MakeCastNode(LpStd_Uword, Left); break;
                default:Left = MakeCastNode(LpStd_Ulong, Left); break;
            }
            CleanUp(Right);
            return Left;
        } else {
            New = NewBinary(Sub,Left,Right);
            New = NewBinary(Div,New,MakeExprConstI(CalcSizeOf(Left->pType->Use.DecArray.pTarget)));
            switch(CalcSizeOf(New->pType)) {
                case 1: New = MakeCastNode(LpStd_Ubyte, New); break;
                case 2: New = MakeCastNode(LpStd_Uword, New); break;
                default:New = MakeCastNode(LpStd_Ulong, New); break;
            }
            return New;
        }
    }
    if (IsReference(Right->pType)) {
        Error0("Subtraction of a reference is not possible.\n","");
        return Left;
    }
    if (IsReference(Left->pType) && IsSimple(Right->pType)) {
        if (IsPointer(Left->pType)) Right = Bmul(Right, MakeExprConstI(CalcSizeOf(Left->pType->Use.DecPtr.pTarget)));
        else                       Right = Bmul(Right, MakeExprConstI(CalcSizeOf(Left->pType->Use.DecArray.pTarget)));
        /* fall through to simple sub */
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger -= Right->Use.Const.lInteger;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Sub")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(Sub,Left,Right);
    }
 }

static TPExprNode
Bmul (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error0("Multiplication of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger   *= Right->Use.Const.lInteger;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Mul")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(Mul,Left,Right);
    }
 }

static TPExprNode
Bdiv (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error0("Division of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger /= Right->Use.Const.lInteger;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Div")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(Div,Left,Right);
    }
 }


static TPExprNode
Bmod (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error0("Modulus of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger %= Right->Use.Const.lInteger;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Mod")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(Mod,Left,Right);
    }
 }


static TPExprNode
Bband(TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error0("Bitwise-And of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger &= Right->Use.Const.lInteger;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize And")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(BAnd,Left,Right);
    }
 }

static TPExprNode
Bbor (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error0("Bitwise-Or of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger |= Right->Use.Const.lInteger;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Or")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(BOr,Left,Right);
    }
 }

static TPExprNode
Bbxor(TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error0("Bitwise-Xor of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger ^= Right->Use.Const.lInteger;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Xor")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(BXor,Left,Right);
    }
 }

static TPExprNode
Bbsr (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error0("Shift-Right of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger >>= Right->Use.Const.lInteger;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize >>")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(BSR,Left,Right);
    }
 }

static TPExprNode
Bbsl (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error0("Shift-Left of non-simple types is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger <<= Right->Use.Const.lInteger;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize <<")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(BSL,Left,Right);
    }
 }

static TPExprNode
Bceq (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {
        Error0("Comparison of structures is not possible.\n","");                                           
        return Left;
    }                                                                                                      
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                             
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                          
            Error0("Comparison a reference to a non-reference is not possible.\n","");                     
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger == Right->Use.Const.lInteger) ? TRUE : FALSE;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize ==")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(CEQ,Left,Right);
    }
}

static TPExprNode
Bcne (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {
        Error0("Comparison of structures is not possible.\n","");
        return Left;
    }
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {
            Error0("Comparison a reference to a non-reference is not possible.\n","");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger != Right->Use.Const.lInteger) ? TRUE : FALSE;
        CleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize !=")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(CNE,Left,Right);
    }
}                                                                                                          

static TPExprNode
Bclt (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                  \
       Error0("Comparison of structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                             \
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                          \
            Error0("Comparison a reference to a non-reference is not possible.\n","");                     \
            return Left;                                                                                   \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger < Right->Use.Const.lInteger) ? TRUE : FALSE;        \
        CleanUp(Right);                                                                                        \
        return Left;
    } else {
#pragma message("Optimize <")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(CLT,Left,Right);
    }
}                                                                                                          \

static TPExprNode
Bcle (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                  \
        Error0("Comparison of structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                             \
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                          \
            Error0("Comparison a reference to a non-reference is not possible.\n","");                     \
            return Left;                                                                                   \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger <= Right->Use.Const.lInteger) ? TRUE : FALSE;        \
        CleanUp(Right);                                                                                        \
        return Left;
    } else {
#pragma message("Optimize <=")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(CLE,Left,Right);
    }
}                                                                                                          \

static TPExprNode
Bcgt (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                  \
       Error0("Comparison of structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                             \
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                          \
            Error0("Comparison a reference to a non-reference is not possible.\n","");                     \
            return Left;                                                                                   \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger > Right->Use.Const.lInteger) ? TRUE : FALSE;        \
        CleanUp(Right);                                                                                        \
        return Left;
    } else {
#pragma message("Optimize >")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(CGT,Left,Right);
    }
}                                                                                                          \

static TPExprNode
Bcge (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                  \
       Error0("Comparison of structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                             \
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                          \
            Error0("Comparison a reference to a non-reference is not possible.\n","");                     \
            return Left;                                                                                   \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger >= Right->Use.Const.lInteger) ? TRUE : FALSE;        \
        CleanUp(Right);                                                                                        \
        return Left;
    } else {
#pragma message("Optimize >=")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = MakeCastNode(NewType,Left);
        Right   = MakeCastNode(NewType,Right);
        return NewBinary(CGE,Left,Right);
    }
}                                                                                                          \



static TPExprNode
Bland(TPExprNode Left, TPExprNode Right) {
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                  \
       Error0("Logical Operations on structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger = Left->Use.Const.lInteger && Right->Use.Const.lInteger;
        CleanUp(Right);
        Left->pType = LpStd_Ubyte;
        return Left;
    } else {
#pragma message("Optimize &&")
        Left    = MakeCastNode(LpStd_Ubyte,Left);
        Right   = MakeCastNode(LpStd_Ubyte,Right);
        return NewBinary(LAnd,Left,Right);
    }
}                                                                                                          \

static TPExprNode
Blor (TPExprNode Left, TPExprNode Right) {
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                  \
       Error0("Logical Operations on structures is not possible.\n","");                                           \
        return Left;                                                                                       \
    }                                                                                                      \
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger = Left->Use.Const.lInteger || Right->Use.Const.lInteger;
        CleanUp(Right);
        Left->pType = LpStd_Ubyte;
        return Left;
    } else {
#pragma message("Optimize ||")
        Left    = MakeCastNode(LpStd_Ubyte,Left);
        Right   = MakeCastNode(LpStd_Ubyte,Right);
        return NewBinary(LOr,Left,Right);
    }
}


TPExprNode
MakeBinaryNode(WORD Op, TPExprNode Left, TPExprNode Right) {
    switch (Op) {
        case    Add:    return Badd (Left,Right);
        case    Sub:    return Bsub (Left,Right);
        case    Mul:    return Bmul (Left,Right);
        case    Div:    return Bdiv (Left,Right);
        case    Mod:    return Bmod (Left,Right);
        case    BAnd:   return Bband(Left,Right);
        case    BOr:    return Bbor (Left,Right);
        case    BXor:   return Bbxor(Left,Right);
        case    CEQ:    return Bceq (Left,Right);
        case    CNE:    return Bcne (Left,Right);
        case    CLT:    return Bclt (Left,Right);
        case    CLE:    return Bcle (Left,Right);
        case    CGT:    return Bcgt (Left,Right);
        case    CGE:    return Bcge (Left,Right);
        case    LAnd:   return Bland(Left,Right);
        case    LOr:    return Blor (Left,Right);
        case    BSR:    return Bbsr (Left,Right);
        case    BSL:    return Bbsl (Left,Right);
        default:        printf("MakeBinaryNode: UnKnown Binary Operator %d\n", Op);
                        return Left;
    }
 }



/* ************************************************** */
/*  Ternary  */
/* ********* */

TPExprNode
TernaryCondExp(TPExprNode First, TPExprNode Second, TPExprNode Third) {
    TPExprNode New;
    if (First->Usage == uConst) {
        if (First->Use.Const.lInteger) {
            CleanUp(First);
            CleanUp(Third);
            return Second;
        } else {
            CleanUp(First);
            CleanUp(Second);
            return Third;
        }
    }
    New = NewExprNode(uTernary);
    New->pType = ResultingType(Second->pType,Third->pType);
    New->Use.Ternary.Op     = CondExp;
    New->Use.Ternary.First  = First;
    New->Use.Ternary.Second = MakeCastNode(New->pType,Second);
    New->Use.Ternary.Third  = MakeCastNode(New->pType,Third);
    return New;
 }

TPExprNode
MakeTernaryNode(WORD Op,  TPExprNode First, TPExprNode Second, TPExprNode Third) {
    switch (Op) {
        case  CondExp:  return TernaryCondExp(First,Second,Third);
                        break;
        default:        printf("MakeTernaryNode: UnKnown Ternary Operator %d\n", Op);
                        return First;
    }
}



/* *************************************************************************** */
/*  Action Nodes                                                               */
/*  need some run time action to be performed in order to determin the result  */
/* *************************************************************************** */


    

TPExprNode
MakeDotNode(TPExprNode Left,  LPSTR Field) {
    TPExprNode New;
    if (!IsStruct(Left->pType)) {
        Error0("Dot expected to be preceeded by a Struct/Union\n","");
        return Left;
    }
    if (CalcStructElementOffset(Left->pType->Use.DecSpec.pPtr, Field) < 0) {
        Error0("Unknown struct/union field",Field);
        return Left;
    }
    New = NewExprNode(uDot);
    New->pType = CalcStructElementType(Left->pType->Use.DecSpec.pPtr, Field);
    New->Use.Dot.pRecord = Left;
    New->Use.Dot.pszField  = Field;
    return New;  
}

TPExprNode
MakeArrowNode(TPExprNode Left,  LPSTR Field) {
    TPExprNode New;
    if (!IsPtrStruct(Left->pType)) {
        Error0("Arrow expected to be preceeded by a Pointer to Struct/Union\n","");
        return Left;
    }
    if (CalcStructElementOffset(Left->pType->Use.DecPtr.pTarget->Use.DecSpec.pPtr, Field) < 0) {
        Error0("Unknown struct/union field",Field);
        return Left;
    }
    New = NewExprNode(uDot);
    New->pType = CalcStructElementType(Left->pType->Use.DecPtr.pTarget->Use.DecSpec.pPtr, Field);
    New->Use.Dot.pRecord = Left;
    New->Use.Dot.pszField  = Field;
    return New;  
}


TPExprNode
MakeArrayNode(TPExprNode Vec,  TPExprNode Ind) {
    TPExprNode New;
    if (!IsReference(Vec->pType) && IsSimple(Ind->pType)) {
        Error0("Reference expected before [...]","");
        return Vec;
    }
    New = NewExprNode(uArray);
    New->Use.Array.pVector = Vec;
    if (IsPointer(Vec->pType)) {
        New->Use.Array.pIndex = Bmul(Ind, MakeExprConstI(CalcSizeOf(Vec->pType->Use.DecPtr.pTarget)));
        New->pType = Vec->pType->Use.DecPtr.pTarget;
    } else {
        New->Use.Array.pIndex = Bmul(Ind, MakeExprConstI(CalcSizeOf(Vec->pType->Use.DecArray.pTarget)));
        New->pType = Vec->pType->Use.DecArray.pTarget;
    }
    return New;
 }



TPExprNode
MakeFuncNode(TPExprNode Func,  TPExprNode Params) {
    TPExprNode New;
    if (!IsFunc(Func->pType)) {
        Error0("Function expected before (...)","");
        return Func;
    }
    New = NewExprNode(uFunc);
    New->pType = Func->pType->Use.DecFunc.pTarget;
    New->Use.pFunc.pFunc   = Func;                  // Funky !
    New->Use.pFunc.pParams = Params;
    return New;
 }


/* ************************************************** */
/*  Assignment */
/* *********** */

TPExprNode
MakeAssignNode(WORD Op, TPExprNode Lval, TPExprNode Rval) {
    TPExprNode New;
    New = NewExprNode(uAssign);
    New->Use.Assign.Op    = Op;
    New->pType             = Lval->pType;    
    New->Use.Assign.pLval  = Lval;
    New->Use.Assign.pRval  = Rval;
    return New;
}

/* ************************************************** */
/*  Cast  */
/* ****** */
static LONG
TypeConvert(TPDeclSpec NewType, TPDeclSpec OldType, LONG Const) {
    WORD SzOld, SzNew;
    if (IsStruct(NewType) || IsStruct(OldType)) {
        Error0("Casting to/from struct is not possible.\n","");
        return 0L;
    }
    SzOld = (WORD)CalcSizeOf(OldType);
    SzNew = (WORD)CalcSizeOf(NewType);
    if (IsReference(NewType) && IsReference(OldType) && (SzOld != SzNew)) {
        Warning0("Conversion between near & far pointers.","");
    }
    if (!(IsReference(NewType) || IsReference(OldType))) {
        if (SzNew > SzOld) {                                            // Cast up
            if (OldType->Use.DecSpec.Type & TypeUNSIGNED) {
                switch (SzOld) {                                        // Cast up Unsigned
                    case 1: Const &= 0x000000ff; break;
                    case 2: Const &= 0x0000ffff; break;
                    case 3: Const &= 0x00ffffff; break;
                    case 4: Const &= 0xffffffff; break;
                    default: Error0("Casting unsigned constant from an unsupported size.\n","");
                }
            } else {                                                    // Cast up signed
                switch (SzOld) {
                    case 1: if (Const & 0x00000080) Const |= 0xffffff00; else Const &= 0x000000ff; break;
                    case 2: if (Const & 0x00008000) Const |= 0xffff0000; else Const &= 0x0000ffff; break;
                    case 3: if (Const & 0x00800000) Const |= 0xff000000; else Const &= 0x00ffffff; break;
                    case 4: if (Const & 0x80000080) Const |= 0x00000000; else Const &= 0xffffffff; break;
                    default: Error0("Casting signed constant from an unsupported size.\n","");
                }
            }
        }
    }
    switch (SzNew) {
        case 1: Const &= 0x000000ff; break;
        case 2: Const &= 0x0000ffff; break;
        case 3: Const &= 0x00ffffff; break;
        case 4: Const &= 0xffffffff; break;
        default: Error0("Casting constant to an unsupported size.\n","");
    }
    return Const;
}

TPExprNode MakeCastNode(TPDeclSpec Type, TPExprNode Node) {
    TPExprNode New;
    if (Node->Usage == uConst) {
        Node->Use.Const.lInteger = TypeConvert(Type, Node->pType, Node->Use.Const.lInteger);
        Node->pType = Type;
        return Node;
    } else {
        New = NewExprNode(uCast);
        New->pType = Type;
        New->Use.Cast.pTarget = Node;
        return New;
    }
 }


TPExprNode MakeInitNode(TPExprNode pNode) {
    TPExprNode pNew;
    pNew = NewExprNode(uInit);
    pNew->Use.Init.pAssignment = pNode;
    pNew->Use.Init.pSibling    = NULL;
    pNew->Use.Init.pChildren   = NULL;
    return pNew;
}

TPExprNode MakeInitList(TPExprNode pNode) {
    TPExprNode pNew;
    pNew = NewExprNode(uInit);
    pNew->Use.Init.pAssignment = NULL;
    pNew->Use.Init.pSibling    = NULL;
    pNew->Use.Init.pChildren   = pNode;
    return pNew;
}

TPExprNode MakeInitConcat(TPExprNode Node, TPExprNode Brother) {
    TPExprNode n;
    for (n=Node; n->Use.Init.pSibling; n=n->Use.Init.pSibling);
    n->Use.Init.pSibling = Brother;
    return Node;
}

#ifdef _DEBUG
void PrintNode(TPExprNode n) {
    switch (n->Usage) {
        case uConst:printf("%lx ",  n->Use.Const.lInteger);
                    break;
        case uVar:  printf("<%s> ",  n->Use.Var.pszIdentifier);
                    break;
        default:    printf("Other ");
                    break;
    }
}

void PrintInit(TPExprNode n) {
    while (n) {
        if (n->Usage != uInit) printf("PrintInit: What !\n");
        if (n->Use.Init.pAssignment) {
            PrintNode(n->Use.Init.pAssignment);
        }
        if (n->Use.Init.pChildren) {
            printf("{ ");
            PrintInit(n->Use.Init.pChildren);
            printf("} ");
        }
        n=n->Use.Init.pSibling;
    }
}
#endif // _DEBUG


/* ****************************************************************** */

DWORD
ConstInt(TPExprNode E) {
    if (E->Usage != uConst) {
        Error0("Initializer must be a Constant value.","");
        return 0L;
    }
    return E->Use.Const.lInteger;
 }


/* ****************************************************************** */


void
CleanUp(TPExprNode n) {
    if (!n) {
        printf("Cleanup: Null\n");
        return;
    }
    switch (n->Usage) {
        case    uConst:
        case    uVar:       break;
        case    uUnary:     CleanUp(n->Use.Unary.pOperand);
                            break;
        case    uBinary:    CleanUp(n->Use.Binary.pLeft);
                            CleanUp(n->Use.Binary.pRight);
                            break;
        case    uTernary:   CleanUp(n->Use.Ternary.First);
                            CleanUp(n->Use.Ternary.Second);
                            CleanUp(n->Use.Ternary.Third);
                            break;
        default:            printf("CleanUp: More to clean ! [%d]\n", n->Usage);
                            break;
    }
    Dispose(n);
}

/* *************************************************** */



/* *************************************************** */


#ifdef _DEBUG

char *Uops[] = {  "-u",  "+u",  "~u",    "u++",  "++u",
                  "u--", "--u", "sizeof","addr", "ptr", "!u" };

char *Bops[] = {  "+b",  "-b",  "*b",    "/b",   "%b",
                  "&b",  "|b",  "^b",    "==b",  "!=b",
                  "<b",  "<=b", ">b",    ">=b",  "&&b",
                  "||b", ">>b", "<<b" };

void
PrintPack(int depth) {
    while (depth--) printf(".  ");
}

void
PrintType(TPExprNode n) {
    printf(" ==> ");
    ParseDeclSpec(n->pType,FALSE);
 }

void
ParseExpr(TPExprNode n,int depth) {
    if (!n) {
        printf("..Null\n");
        return;
    }
    
    switch (n->Usage) {
        case    uConst:     PrintPack(depth);
                            printf("%ld",    n->Use.Const.lInteger);
                            PrintType(n);
                            break;
        case    uVar:       PrintPack(depth);
                            printf("[%s]",  n->Use.Var.pszIdentifier);
                            PrintType(n);
                            break;
        case    uUnary:     PrintPack(depth);
                            printf("%s", Uops[n->Use.Unary.Op]);
                            PrintType(n);
                            ParseExpr(n->Use.Unary.pOperand,depth+1);
                            break;
        case    uBinary:    ParseExpr(n->Use.Binary.pLeft, depth+1);
                            PrintPack(depth);
                            printf("%s", Bops[n->Use.Unary.Op]);
                            PrintType(n);
                            ParseExpr(n->Use.Binary.pRight,depth+1);
                            break;
        case    uTernary:   PrintPack(depth);
                            printf("Tern");
                            PrintType(n);
                            ParseExpr(n->Use.Ternary.First, depth+1);
                            PrintPack(depth);
                            printf("Then\n");
                            ParseExpr(n->Use.Ternary.Second, depth+1);
                            PrintPack(depth);
                            printf("Else\n");
                            ParseExpr(n->Use.Ternary.Third, depth+1);
                            break;
        case    uDot:       ParseExpr(n->Use.Dot.pRecord, depth+1);
                            PrintPack(depth);
                            printf("Dot");
                            PrintType(n);
                            PrintPack(depth);
                            printf("[%s]\n",n->Use.Dot.pszField);
                            break;
        case    uArrow:     ParseExpr(n->Use.Arrow.pRecord, depth+1);
                            PrintPack(depth);
                            printf("Arrow");
                            PrintType(n);
                            PrintPack(depth);
                            printf("[%s]\n",n->Use.Arrow.pszField);
                            break;
        case    uArray:     ParseExpr(n->Use.Array.pVector, depth+1);
                            PrintPack(depth);
                            printf("Array");
                            PrintType(n);
                            ParseExpr(n->Use.Array.pIndex, depth+1);
                            break;
        case    uFunc:      ParseExpr(n->Use.pFunc.pFunc, depth+1);
                            PrintPack(depth);
                            printf("Function");
                            PrintType(n);
                            ParseExpr(n->Use.pFunc.pParams, depth+1);
                            break;
        case    uCast:      PrintPack(depth);
                            printf("Cast");
                            PrintType(n);
                            ParseExpr(n->Use.Cast.pTarget, depth+1);
                            break;
        default:            printf("ParseExpr: What [%d]\n", n->Usage);
                            break;
    }
}
#endif // _DEBUG

/* eof */

