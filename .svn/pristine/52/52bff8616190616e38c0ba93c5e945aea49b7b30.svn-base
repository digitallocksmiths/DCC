/* ****************** */
/* Data Element Sizes */
/* ****************** */

#define    SIZE_VOID            0           // basic types
#define    SIZE_CHAR            1
#define    SIZE_INT             2
#define    SIZE_SHORT           2
#define    SIZE_LONG            4
#define    SIZE_FLOAT           8
#define    SIZE_DOUBLE         16
#define    SIZE_LONGDOUBLE     32

#define    SIZE_FUNC            2           // reference types
#define    SIZE_PTR_DEFAULT     2
#define    SIZE_PTR_CONST       2
#define    SIZE_PTR_VOLATILE    2
#define    SIZE_PTR_NEAR        2
#define    SIZE_PTR_FAR         2

/* *************** */
/* Type structures */
/* *************** */
// forward ref from Expr.h
typedef struct TagExprNode ExprNode;
typedef ExprNode FAR *LpExprNode;


typedef enum { DecSpec, DecId, DecPtr, DecArray, DecFunc } Usage;

typedef struct TagDeclSpec DeclSpec;
typedef DeclSpec FAR *LpDeclSpec;
struct TagDeclSpec {
    Usage       Usage;
    LpDeclSpec  Chain;
    union {
        struct  {
            WORD    Class;                  // Base Type     !! Keep DecSpec first in union for initialization !! 
            WORD    Type;
            WORD    Qual;
            LPVOID  Ptr;
        } DecSpec;
        struct {
            LPSTR       pszName;            // Identifier
            LPSTR       pszInitializerStr;
            LpExprNode  pInitializer;
            LpDeclSpec  pTarget;
            LpDeclSpec  pBrother;
        } DecId;
        struct {                            // Pointers           
            LpDeclSpec  pTarget;
            WORD        Qual;            
        } DecPtr;
        struct {                            // Arrays
            DWORD       Size;
            LpDeclSpec  pTarget;
        } DecArray;
        struct {                            // Function
            LPVOID      PList;
            LPVOID      IdList;
            LpDeclSpec  pTarget;
        } DecFunc;
    } Use;
 };

/* ********** */
/* Base Types */
/* ********** */

#define ClassAUTO       (1<<0)              //  0x01
#define ClassREGISTER   (1<<1)              //  0x02
#define ClassSTATIC     (1<<2)              //  0x04
#define ClassEXTERN     (1<<3)              //  0x08
#define ClassTYPEDEF    (1<<4)              //  0x10

#define TypeVOID        (1<<0)              //  0x0001
#define TypeCHAR        (1<<1)              //  0x0002
#define TypeSHORT       (1<<2)              //  0x0004
#define TypeINT         (1<<3)              //  0x0008
#define TypeLONG        (1<<4)              //  0x0010
#define TypeFLOAT       (1<<5)              //  0x0020
#define TypeDOUBLE      (1<<6)              //  0x0040
#define TypeSIGNED      (1<<7)              //  0x0080
#define TypeUNSIGNED    (1<<8)              //  0x0100
#define TypeSTRUCT      (1<<9)              //  0x0200
#define TypeENUM        (1<<11)             //  0x0400
#define TypeTYPEDEF     (1<<12)             //  0x08000

#define QualCONST       (1<<0)              //  0x01
#define QualVOLATILE    (1<<1)              //  0x02
#define QualNEAR        (1<<2)              //  0x04
#define QualFAR         (1<<3)              //  0x08

//  0x10
LpDeclSpec NewSpecClass(WORD Class);
LpDeclSpec NewSpecType(WORD Class, LPVOID Ptr);
LpDeclSpec NewSpecQual(WORD Class);
LpDeclSpec ConcatDeclSpec(LpDeclSpec Old, LpDeclSpec New);

/* ********************************************* */

LpDeclSpec  NewIdentifier(LPSTR Name);
LpDeclSpec  NewPointer(LpDeclSpec Qualifier, LpDeclSpec Target);
LpDeclSpec  NewArray(LpDeclSpec Decl, struct TagExprNode FAR *Expr);
LpDeclSpec  NewFunc(LpDeclSpec Decl, LPVOID PList, LPVOID IdList);

LpDeclSpec  AppendDecl(LpDeclSpec a, LpDeclSpec b);
LpDeclSpec  MakeBrother(LpDeclSpec a, LpDeclSpec b);
LpDeclSpec  AddInitializer(LpDeclSpec pDecl, LpExprNode pInit);
LpDeclSpec  AddInitializerStr(LpDeclSpec pDec, LPSTR pStr);


DWORD       CalcSizeOf(LpDeclSpec Ptr);                     // storage required
BOOL        CompDecl(LpDeclSpec a, LpDeclSpec b);           // ? Same Type
BOOL        IsIntegralType(LpDeclSpec Type);                // can type be represented as an integer


#ifdef _DEBUG
void        ParseDeclSpec(LpDeclSpec Ptr, BOOL DoBrothers);
#endif // _DEBUG
  
/********************/
/* ENUM descriptors */
/********************/

typedef struct TagEnumElement EnumElement;
typedef EnumElement FAR *LpEnumElement;
struct TagEnumElement {
        LPSTR           ElementName;
        BOOL            Assigned;
        DWORD           Value;
        LpEnumElement   Next;
};

typedef struct TagEnumSet EnumSet;
typedef EnumSet FAR *LpEnumSet;
struct TagEnumSet {
        LPSTR           SetName;
        LpEnumElement   Elements;
        LpEnumSet       Next;
};

LpEnumElement   MakeEnumElement(LPSTR Name, struct TagExprNode FAR *Expr);
LpEnumElement   AddEnumElement(LpEnumElement List, LpEnumElement New);
LpEnumElement   FindEnumElement(LPSTR Name);
LpEnumSet       AddEnumSet(LPSTR Name, LpEnumElement Elements);

#ifdef _DEBUG
void            PrintEnumElements(LpEnumElement El);
void            PrintEnumSets(void);
#endif // _DEBUG

/****************************/
/* STRUCT/UNION descriptors */
/****************************/

typedef struct TagStructSet StructSet;
typedef StructSet FAR *LpStructSet;
struct TagStructSet {
         LPSTR          SetName;
         BOOL           Union;
         LpDeclSpec     Elements;
         LpStructSet    Next;
};

LpStructSet     AddStructSet(LPSTR Name, BOOL Union, LpDeclSpec Elements);
LONG            CalcStructElementOffset(LpStructSet Struct, LPSTR Field);
LpDeclSpec      CalcStructElementType(LpStructSet Struct, LPSTR Field);

#ifdef _DEBUG
void            PrintStructSets(void);
#endif // _DEBUG

/* ***************************************************************** */
/*  Declarations  */
/* ************** */

void        Declaration(LpDeclSpec Ptr, BOOL Global);
LpDeclSpec  FindType(LPSTR Name);
LpDeclSpec  FindGlobalObject(LPSTR Name);
LpDeclSpec  FindLocalObject(LPSTR Name);

#ifdef _DEBUG
void    ListGlobalTypes(void);
void    ListLocalTypes(void);
void    ListGlobalObjects(void);
void    ListLocalObjects(void);
#endif // _DEBUG

/* eof */
