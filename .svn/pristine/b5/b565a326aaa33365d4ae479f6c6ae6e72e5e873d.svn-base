// # $URL$
// # $Revision$


#pragma message("Todo: static is ignored for local vars.")
#pragma message("Todo: initializers are ignored for local vars.")
#pragma message("Todo: Local and parameters:  read before set warnings.")

#pragma message("Todo: Declaration function names to start with Decl? (tidy up the source code)")
//#pragma message("Todo: Globals dump to use depth and indent correctly")                               // Done
//#pragma message("Todo: Local and parameters:  allocate and remove as scope changes.")                 // Done
//#pragma message("ToDo: Casting should be case node with sub clasification of case type.")             // Done
//#pragma message("Todo: Local and parameters:  unused variable warnings.")                             // Done
//#pragma message("Todo: Local variables and parameters. how to find them when parsing expressions.")   // Done
//#pragma message("Todo: Local variables. generate expression code.")


#pragma message("Todo: No concept of alignmnent. All vars occupy their own size and no packing is generated.")   
// this is also true of parameters on the stack.
// Given we have an 8 bit target this is not considered to be a problem.

//#pragma message("Todo: void Foo(void). Parameters display incorrectly.")                              // Done
#pragma message("Todo: Subtraction of arrays looks odd. Debug and comment the code.")   

#pragma message("ToDo: C-parsing expression optimisation could be skipped and left for the optimizer?")
//#pragma message("ToDo: Array could be translated to arithmetic?")                                       // Done
#pragma message("ToDo: Arrow could be translated to arithmetic?")
//#pragma message("ToDo: Dot could be translated to arithmetic?")                                           // Done



#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <process.h>
#include <Windows.h>

//#include <ext\types.h>
#include "Utilities\Console.h"

#include "lex.h"
#include "typectrl.h"
#include "Expr.h"
#include "Gen.h"
#include "Main.h"
#include "C_Yacced.tab.h"

/* ******************************************* */

// int foo(int p1, int p2) {
//     int a=1;
//     int c=1;
//     for (;;) {
//         int a=0;
//         int p1;
//         a += c + p2;
//     }
// }

/* ******************************************* */

YYSTYPE     yylval;
void        yyparse(void);
FILE        *hGlbOut = NULL;               // target generation.

DWORD dwErrorCount   = 0;
DWORD dwWarningCount = 0;
int   iFinalColour   = 0;               // Colour of the error count summary.
    
void ErrorLocator0(int iColour) {
    WORD i;
    fprintf(stderr, "%6ld: %s\n",yylval.LineInfo.LineNo, CurrentLine);
    ConsoleSetColour(iColour);
    for (i=0; i<yylval.LineInfo.LinePos+7; i++) fprintf(stderr, " ");
    fprintf(stderr, "^\n");
    
}

void ErrorLocator1(int iColour) {
    WORD i;
    fprintf(stderr, "%6ld: %s\n",yylval.LineInfo.OldNo, PreviousLine);
    ConsoleSetColour(iColour);
    for (i=0; i<yylval.LineInfo.OldPos+7; i++) fprintf(stderr, " ");
    fprintf(stderr, "^\n");
}

void ErrorLocatorX(int iColour) {
    fprintf(stderr, "Somewhere on or before line %d: ", yylval.LineInfo.OldNo);
}


void Error(TErrorType e, const char *pbFormat, ...) {
char szOutString[256];
    va_list ArgList;
    int iColour;
    char *pszErrClass = "";

    switch (e) {
    case WARNING0:
    case WARNING1:
    case WARNINGX: dwWarningCount++;
                   iColour = CON_YELLOW; // +CON_BRIGHT;
                   iFinalColour = max(iFinalColour, 1);
                   pszErrClass = "Warning";
                   break;
    case ERROR0:
    case ERROR1:
    case ERRORX:   dwErrorCount++;
                   iColour = CON_RED; // +CON_BRIGHT;
                   iFinalColour = max(iFinalColour, 2);
                   pszErrClass = "Error";
                   break;
    case FATAL:
    default:       iColour = CON_MAGENTA + CON_BRIGHT;
                   iFinalColour = max(iFinalColour, 3);
                   pszErrClass = "Fatal";
                   break;
    }

    switch (e) {
    case WARNING0: 
    case ERROR0:   ErrorLocator0(iColour);          // current symbol
                   break;
    case WARNING1:  
    case ERROR1:   ErrorLocator1(iColour);          // previous symbol
                   break;

    case WARNINGX:                                  // long lost symbol
    case ERRORX:   ErrorLocatorX(iColour);
                   break;

    case FATAL:
    default:       if (hGlbOut == NULL) {      // no source to display if we are generating output.
                       ErrorLocator0(iColour);
                    }
                   break;
    }

    va_start(ArgList, pbFormat);
    _vsnprintf(szOutString, sizeof(szOutString), pbFormat, ArgList);
    ConsolePrintf(iColour, "%s: %s\n", pszErrClass, szOutString);
    if (e == FATAL) {
#ifdef _DEBUG
//        if (_getch() == 0x1b)
#endif // _DEBUG
        exit(-1);
    }
}


/* **************************************************************** */

char szSource[_MAX_PATH];
char szDest[_MAX_PATH];
char szDrive[_MAX_DRIVE];
char szDir[_MAX_DIR];
char szExt[_MAX_EXT];
char szFile[_MAX_FNAME];

void
SortOutFileNames(LPSTR pszIn, LPSTR pszOut) {

	if (pszIn == NULL) {
		pszIn = "Code";
	}

	_splitpath(pszIn, szDrive, szDir, szFile, szExt);
	_makepath(szSource, szDrive, szDir, szFile, ((*szExt == '.') && szExt[1]) ? szExt : ".c" );

	if (pszOut == NULL) {
		_makepath(  szDest,   szDrive, szDir, szFile, ".asm" );
	}
	else {
		_splitpath(pszOut, szDrive, szDir, szFile, szExt);
        _makepath(szDest, szDrive, szDir, szFile, ((*szExt == '.') && szExt[1]) ? szExt : ".asm");

	}
}

void Tidyup(void) {
    if (hGlbOut != NULL) {
        fclose(hGlbOut);
    }
}

void
main(int Argc, char *Argv[]) {
    // testing();
    // exit(0);


	if (Argc > 2)      { SortOutFileNames(Argv[1], Argv[2]); }
    else if (Argc > 1) { SortOutFileNames(Argv[1], NULL);    }
    else               { SortOutFileNames(NULL, NULL);       }
    
    if (!StartInput(szSource)) {
            fprintf(stderr, "Failed opening source file '%s'\n", szSource);
            exit(-1);
    }

    yyparse();
    EndInput();
     
    switch (iFinalColour) {
    case 0: iFinalColour = CON_GREEN + CON_BRIGHT; break;
    case 1: iFinalColour = CON_YELLOW + CON_BRIGHT; break;
    case 2: iFinalColour = CON_RED + CON_BRIGHT; break;
    }
    ConsolePrintf(iFinalColour, "%ld Errors, %ld Warnings.\n\n", dwErrorCount, dwWarningCount);


    if (dwErrorCount == 0) {
#ifdef _DEBUG
        EnumSetPrintList(0);
        PrintStructSets(0);
        ListGlobalTypes();
        ListGlobalObjects();
        ListParameterObjects();
        ListLocalObjects();
#endif // _DEBUG

        hGlbOut = fopen(szDest, "wt");
        atexit(Tidyup);
        GenIntro();
        GenConst(GlobalObjects);
        GenData(GlobalObjects);
        GenBss(GlobalObjects);
        GenText(GlobalObjects);
        GenTail();
        fclose(hGlbOut);
        hGlbOut = NULL;
    }

#ifdef _DEBUG
//    ConsolePrintf(CON_WHITE, "Press key to exit\n");
//    _getch();
#endif // _DEBUG

    if (dwErrorCount) {
        exit(-1);
    }
    else if (dwWarningCount) {
        exit(1);
    }
    else {
        exit(0);
    }
 }

/* eof */

