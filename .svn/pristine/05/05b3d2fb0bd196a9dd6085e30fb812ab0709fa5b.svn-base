// # $URL$
// # $Revision$


#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <setjmp.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <limits.h>
#include <float.h>
#include <Windows.h>

//#include <ext\types.h>
#include "Utilities\Console.h"

#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "gen.h"
#include "main.h"
#include "C_Yacced.tab.h"


/* ******************************************************* */
/*  General Expression Housekeeping  */
/* ********************************* */

static TPExprNode
NewExprNode(ExprUsage Use) {
    TPExprNode NewEl;
    NewEl = New(sizeof(TExprNode));
    NewEl->Usage    = Use;
    NewEl->pType    = NULL;
    NewEl->pSibling = NULL;
    return NewEl;
 }

TPExprNode
ExprMakeConstC(LONG Value) {
    TPExprNode New;
    New = NewExprNode(uConst);
    New->pType = NewSpecType(TypeCHAR,NULL);
    New->Use.Const.lInteger = Value;
    return New;
 }

TPExprNode
ExprMakeConstI(LONG Value) {
    TPExprNode New;
    New = NewExprNode(uConst);
    if      ((SCHAR_MIN <= Value) && (Value <= SCHAR_MAX)) New->pType = NewSpecType(TypeSIGNED|  TypeCHAR, NULL);
    else if ((0 <= Value)         && (Value <= UCHAR_MAX)) New->pType = NewSpecType(TypeUNSIGNED|TypeCHAR, NULL);
    else if ((SHRT_MIN <= Value)  && (Value <= SHRT_MAX))  New->pType = NewSpecType(TypeSIGNED|  TypeSHORT,NULL);
    else if ((0 <= Value)         && (Value <= USHRT_MAX)) New->pType = NewSpecType(TypeUNSIGNED|TypeSHORT,NULL);
    else if ((LONG_MIN <= Value)  && (Value <= LONG_MAX))  New->pType = NewSpecType(TypeSIGNED|  TypeLONG, NULL);
    else                                                   New->pType = NewSpecType(TypeUNSIGNED|TypeLONG, NULL);
    New->Use.Const.lInteger = Value;
    return New;
 }

TPExprNode
ExprMakeConstF(DOUBLE Value) {
    Error(WARNING0, "Floating point numbers are not supported.");
    return ExprMakeConstI((LONG)Value);
 }

TPExprNode
ExprMakeConstS(LPSTR Str) {
    LPSTR Lab = GenLabel("Str");
    TPDeclSpec p;
    p = NewIdentifier(Lab);
    p = NewArray(p,NULL);
    p->Use.DecId.pTarget->Use.DecArray.Size = strlen(Str)+1;
    p = AddInitializerStr(p,Str);
    p = AppendDecl(p,NewSpecType(TypeCHAR,NULL));
    Declaration(p);
    return ExprMakeVar(Lab);
 }

TPExprNode ExprMakeVar(LPSTR Variable) {                                        // new node to read a variable
    TPExprNode pNew;
    TPDeclSpec pV;
    pNew = NewExprNode(uVar);                                                   // new variable node
    pNew->Use.Var.pszIdentifier = Variable;                                     // the name is recorded here. 

    pV   = FindLocalObject(Variable);                                           // is it a local?
    if (pV != NULL) {                                                           //
        ASSERT(pV->Usage == DecId);                                             //
        pV->Use.DecId.UsedFlags |= DecId_UsedFlag_Local;                        // mark it as used
        //if ((pV->Use.DecId.UsedFlags & DecId_UsedFlag_Assigned) == 0) {                                             // test to see if this variable has had its contents set.
        //    Error(WARNING0, "Variable '%s' may be used before it is assigned a value\n", pV->Use.DecId.pszName);    // 
        //    pV->Use.DecId.UsedFlags |= DecId_UsedFlag_Assigned;                                                     // fake assignmnet will shut up future simlar complaints
        //}                                                                                                           //
        pNew->Use.Var.iOffset = pV->Use.DecId.iOffset;                          //
        pNew->pType = pV->Use.DecId.pTarget;                                    // type is defined here.
        return pNew;                                                            //
    }                                                                           //

    pV = FindParameterObject(Variable);                                         // if not then is it a parameter ?
    if (pV != NULL) {                                                           //
        ASSERT(pV->Usage == DecId);                                             //
        pNew->Use.Var.iOffset = pV->Use.DecId.iOffset;                          // 
        pNew->pType = pV->Use.DecId.pTarget;                                    // type is defined here.
        return pNew;                                                            //
    }                                                                           //
    
    pV = FindGlobalObject(Variable);                                            // if not then is it a global ?
    if (pV != NULL) {                                                           //
        pNew->Use.Var.iOffset = GLOBAL_VAR;                                     // -1 means it's global
        pNew->pType = pV->Use.DecId.pTarget;                                    // type is defined here.
        return pNew;                                                            //
    }                                                                           //

    Error(ERROR0, "Unknown Variable '%s'.", Variable);                          // if not then it's an unidentified variable
    pNew->Use.Var.iOffset = GLOBAL_VAR;                                         // -1 means it's global (no code will be generated after the error though!)
    pNew->pType = NewSpecType(TypeINT, NULL);                                   // fake integer type
    return pNew;                                                                //
}

/* *************************************************** */

#define IsStruct(n)    (((n)->Usage == DecSpec) &&  ((n)->Use.DecSpec.Type & TypeSTRUCT))
#define IsSimple(n)    (((n)->Usage == DecSpec) && !((n)->Use.DecSpec.Type & TypeSTRUCT))
#define IsUnsigned(n)  (((n)->Usage == DecSpec) &&  ((n)->Use.DecSpec.Type & TypeUNSIGNED))
#define IsSigned(n)    (((n)->Usage == DecSpec) && !((n)->Use.DecSpec.Type & TypeUNSIGNED))
#define IsPointer(n)    ((n)->Usage == DecPtr)
#define IsArray(n)      ((n)->Usage == DecArray)
#define IsFunc(n)       ((n)->Usage == DecFunc)
#define IsReference(n)  (IsPointer(n) || IsArray(n))
#define IsPtrStruct(n)  (IsPointer(n) && IsStruct((n)->Use.DecPtr.pTarget))

/* *************************************************** */
      
TDeclSpec    Std_Ubyte   = { DecSpec, NULL, { 0, TypeUNSIGNED|TypeCHAR, 0, NULL } } ;
TDeclSpec    Std_Sbyte   = { DecSpec, NULL, { 0, TypeSIGNED|TypeCHAR,   0, NULL } } ;
TDeclSpec    Std_Uword   = { DecSpec, NULL, { 0, TypeUNSIGNED|TypeSHORT,0, NULL } } ;
TDeclSpec    Std_Sword   = { DecSpec, NULL, { 0, TypeSIGNED|TypeSHORT,  0, NULL } } ;
TDeclSpec    Std_Ulong   = { DecSpec, NULL, { 0, TypeUNSIGNED|TypeLONG, 0, NULL } } ;
TDeclSpec    Std_Slong   = { DecSpec, NULL, { 0, TypeSIGNED|TypeLONG,   0, NULL } } ;

TPDeclSpec  LpStd_Ubyte = &Std_Ubyte;
TPDeclSpec  LpStd_Sbyte = &Std_Sbyte;
TPDeclSpec  LpStd_Uword = &Std_Uword;
TPDeclSpec  LpStd_Sword = &Std_Sword;
TPDeclSpec  LpStd_Ulong = &Std_Ulong;
TPDeclSpec  LpStd_Slong = &Std_Slong;




//static LpExprNode
//Cast(LpExprNode Left, LpDeclSpec Newtype) {
//#pragma message("Cast:  insert convert operand size code.")
//    return Left;
//}

///* ************************************************************ */
///*  pointer and node return the smallest integral pointer type  */
///* ************************************************************ */
//
//static LpDeclSpec
//CastToValidPointer(LpDeclSpec Ptr) {
//    if      (CalcSizeOf(Ptr) <= SIZE_CHAR)  return NewSpecType(TypeUNSIGNED|TypeCHAR,NULL);
//    else if (CalcSizeOf(Ptr) <= SIZE_SHORT) return NewSpecType(TypeUNSIGNED|TypeSHORT,NULL);
//    else                                    return NewSpecType(TypeUNSIGNED|TypeLONG,NULL);
//}

///* ************************************************************ */
///*  Make a binary node and insert the required castings         */
///* ************************************************************ */
//
//static LpExprNode
//FixCastings(LpExprNode New, LpExprNode Left, LpExprNode Right) {
//    if (!CompDecl(New->Type,Left->Type))  Left = MakeCastNode(New->Type, Left);
//    if (!CompDecl(New->Type,Right->Type)) Right= MakeCastNode(New->Type, Right);
//    New->Use.Binary.Left  = Left;
//    New->Use.Binary.Right = Right;
//    return New;
// }

/* ************************************************** */
/*  Unary  */
/* ******* */

static TPExprNode
NewUnary(WORD Op,  TPExprNode Node) {
    TPExprNode New;
    New = NewExprNode(uUnary);
    New->Use.Unary.Op = Op;             // operation  
    New->Use.Unary.pOperand = Node;      // target of operation
    New->pType = Node->pType;             // assume no change in type.
    return New;
 }
 
static TPExprNode
UMinus(TPExprNode Node) {
    TPExprNode New;
    if (!IsSimple(Node->pType)) {
        Error(WARNING0, "Unary arithmetic is only posible on simple types.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Node->Use.Const.lInteger = -(Node->Use.Const.lInteger);
        return Node;
    } else {
        New = NewUnary(Minus, Node);
        return  New;
    }
 }
 
static TPExprNode
UPlus(TPExprNode Node) {
    if (!IsSimple(Node->pType)) {
        Error(WARNING0, "Unary arithmetic is only posible on simple types.");
        return Node;
    }
    return Node;
 }
 
static TPExprNode
UNeg(TPExprNode Node) {
    TPExprNode New;
    if (!IsSimple(Node->pType)) {
        Error(WARNING0, "Unary arithmetic is only posible on simple types.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Node->Use.Const.lInteger = ~(Node->Use.Const.lInteger);
        return Node;
    } else {
        New = NewUnary(Neg, Node);
        return  New;
    }
 }
 
static TPExprNode
UNot(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Error(WARNING0, "Unary logic is not possible on struct/union.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Node->Use.Const.lInteger = !(Node->Use.Const.lInteger);
        return Node;
    } else {
        New = NewUnary(Not, Node);
        New->pType = LpStd_Ubyte;
        return  New;
    }
 }
 
static TPExprNode
UPostInc(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Error(WARNING0, "Cannot perform '++'/'--' on a structure.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error(ERROR0, "'++' or '--' on a Constant is bit dumb.");
        return Node;
    } else {
        New = NewUnary(PostInc, Node);
        return  New;
    }
 }
 
static TPExprNode
UPreInc(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Error(WARNING0, "Cannot perform '++'/'--' on a structure.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error(ERROR0, "'++' or '--' on a Constant is bit dumb.");
        return Node;
    } else {
        New = NewUnary(PreInc, Node);
        return  New;
    }
 }
 
static TPExprNode
UPostDec(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Error(WARNING0, "Cannot perform '++'/'--' on a structure.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error(ERROR0, "'++' or '--' on a Constant is bit dumb.");
        return Node;
    } else {
        New = NewUnary(PostDec, Node);
        return  New;
    }
 }
 
static TPExprNode
UPreDec(TPExprNode Node) {
    TPExprNode New;
    if (IsStruct(Node->pType)) {
        Error(WARNING0, "Cannot perform '++'/'--' on a structure.");
        return Node;
    }
    if (Node->Usage == uConst)  {
        Error(ERROR0, "'++' or '--' on a Constant is bit dumb.");
        return Node;
    } else {
        New = NewUnary(PreDec, Node);
        return  New;
    }
 }
 
static TPExprNode
USizeof(TPExprNode Node) {
    return ExprMakeConstI(CalcSizeOf(Node->pType));
 }
 
static TPExprNode
UAddr(TPExprNode Node) {
    TPExprNode New;
    if (Node->Usage == uConst) {
        Error(ERROR0, "Address of constant is meaningless.");
        return Node;
    }
    if (Node->Usage == uUnary && Node->Use.Unary.Op == Ptr) {                // wanting & of * of X
        return Node->Use.Unary.pOperand;                                    //  this is X
    }
    
    New = NewUnary(Addr, Node);
    New->pType = NewPointer(NULL,Node->pType);
    return  New;

 }

                          
static TPExprNode
UPtr(TPExprNode Node) {
    TPExprNode New;
    if (Node->pType->Usage == DecPtr) {
        New = NewUnary(Ptr, Node);
        New->pType = Node->pType->Use.DecPtr.pTarget;
        return  New;
    } else if (Node->pType->Usage == DecArray) {
        New = NewUnary(Ptr, Node);
        New->pType = Node->pType->Use.DecArray.pTarget;
        return  New;
    } else {
        Error(ERROR0, "De-Reference of a Non pointer type.");
        return Node;
    }
 }


TPExprNode
ExprMakeUnaryNode(TIdExprUnOp Op,  TPExprNode Node) {
    switch (Op) {
        case    Minus:      return UMinus(Node);
        case    Plus:       return UPlus(Node);
        case    Neg:        return UNeg(Node);
        case    Not:        return UNot(Node);
        case    PostInc:    return UPostInc(Node);
        case    PreInc:     return UPreInc(Node);
        case    PostDec:    return UPostDec(Node);
        case    PreDec:     return UPreDec(Node);
        case    SizeOf:     return USizeof(Node);
        case    Addr:       return UAddr(Node);
        case    Ptr:        return UPtr(Node);
        default:            Error(FATAL, "MakeUnaryNode(): UnKnown Unary Operator %d\n", Op);
                            return Node;
    }
 }

/* ************************************************** */
/*  Binary  */
/* ******** */

static TPDeclSpec ResultingType(TPDeclSpec pLeft, TPDeclSpec pRight) {
//    printf("Left  = "); ParseDeclSpec(0, pLeft, FALSE);
//    printf("Right = "); ParseDeclSpec(0, pRight, FALSE);
    
    if ((pLeft->Usage == DecPtr) && (pRight->Usage == DecPtr)) {                // ptr : prr  => trouble
        Error(ERROR1, "ResultingType(): Arithmetic on two pointers");
        return pLeft;
    }
    if (IsStruct(pLeft) || IsStruct(pRight)) {                                   //  can't cope with structures either.
        Error(ERROR1, "ResultingType(): Can't do Arithmetic on structures");
        return pLeft;
    }

    if ((pLeft->Usage == DecPtr) && (pRight->Usage == DecSpec)) {               // ptr : base => ptr
        return pLeft;
    }
    if ((pLeft->Usage == DecSpec) && (pRight->Usage == DecPtr)) {               // base : ptr => ptr
        return pRight;
    }
    if ((pLeft->Usage == DecSpec) && (pRight->Usage == DecSpec)) {              // base : base => biggest of the two
        if (CalcSizeOf(pLeft) > CalcSizeOf(pRight)) {                           //
            return pLeft;
        }
        if (CalcSizeOf(pLeft) < CalcSizeOf(pRight)) {
            return pRight;
        }
        return pLeft;
    }
    Error(ERROR1, "ResultingType(): Casting uncastable types.");
    ASSERT(FALSE); // should not get here.
    return pLeft;
}


static TPExprNode
NewBinary(TPDeclSpec pType, WORD Op,  TPExprNode Left, TPExprNode Right) {
    TPExprNode New;
    New = NewExprNode(uBinary);
    New->Use.Binary.Op    = Op;                         // operation  
    New->Use.Binary.pLeft  = Left;                      // target of operation
    New->Use.Binary.pRight = Right;                     // target of operation
    New->pType = pType;
    return New;
 }

static TPExprNode Badd (TPExprNode Left, TPExprNode Right);
static TPExprNode Bsub (TPExprNode Left, TPExprNode Right);
static TPExprNode Bmul (TPExprNode Left, TPExprNode Right);
static TPExprNode Bdiv (TPExprNode Left, TPExprNode Right);
static TPExprNode Bmod (TPExprNode Left, TPExprNode Right);
static TPExprNode Bband(TPExprNode Left, TPExprNode Right);
static TPExprNode Bbor (TPExprNode Left, TPExprNode Right);
static TPExprNode Bbxor(TPExprNode Left, TPExprNode Right);
static TPExprNode Bceq (TPExprNode Left, TPExprNode Right);
static TPExprNode Bcne (TPExprNode Left, TPExprNode Right);
static TPExprNode Bclt (TPExprNode Left, TPExprNode Right);
static TPExprNode Bcle (TPExprNode Left, TPExprNode Right);
static TPExprNode Bcgt (TPExprNode Left, TPExprNode Right);
static TPExprNode Bcge (TPExprNode Left, TPExprNode Right);
static TPExprNode Bland(TPExprNode Left, TPExprNode Right);
static TPExprNode Blor (TPExprNode Left, TPExprNode Right);
static TPExprNode Bbsr (TPExprNode Left, TPExprNode Right);
static TPExprNode Bbsl (TPExprNode Left, TPExprNode Right);



static TPExprNode
Badd (TPExprNode Left, TPExprNode Right) {
    TPExprNode New;
    TPDeclSpec NewType;
    if (IsStruct(Left->pType) || IsStruct(Right->pType)) {                                      // we can't add structures
        Error(ERROR0, "Addition of Structures is not possible.");
        return Left;
    }
    if (IsReference(Left->pType) && IsReference(Right->pType)) {                                // we can't add two references
        Error(ERROR0, "Addition of References is not possible.");
        return Left;
    }
    if (IsSimple(Left->pType) && IsReference(Right->pType)) {                                   // if one simple and one ref (swap them)
        New   = Right;
        Right = Left;
        Left  = New;
        /* fall through (then pass) next test */                                                //           
    }
    if (IsReference(Left->pType) && IsSimple(Right->pType)) {                                   // Left reference and right simple 
        if (IsPointer(Left->pType)) {
            Right = Bmul(Right, ExprMakeConstI(CalcSizeOf(Left->pType->Use.DecPtr.pTarget)));   //       simple * sizeof what we point to
            return NewBinary(Left->pType, Add, Left, Right);
        }
        else {
            ASSERT(FALSE); // never?
            Right = Bmul(Right, ExprMakeConstI(CalcSizeOf(Left->pType->Use.DecArray.pTarget))); //    or simple * size of array element.
            return NewBinary(Left->pType->Use.DecArray.pTarget, Add, UAddr(Left), Right);
        }
    }
    
    ASSERT(IsSimple(Left->pType) && IsSimple(Right->pType));
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger += Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } 

    NewType = ResultingType(Left->pType,Right->pType);
    Left    = ExprMakeCastNode(NewType, Left);
    Right   = ExprMakeCastNode(NewType, Right);
    return NewBinary(NewType, Add,Left,Right);
 }

static TPExprNode
Bsub(TPExprNode Left, TPExprNode Right) {
    TPExprNode New;
    TPDeclSpec NewType;
    if (IsStruct(Left->pType) || IsStruct(Right->pType)) {
        Error(ERROR0, "Subtraction of Structures is not possible.");
        return Left;
    }
    if (IsReference(Left->pType) && IsReference(Right->pType)) {
        if (!CompDecl(Left->pType, Right->pType)) {
            Error(ERROR0, "Subtraction of dissimilar references is not possible.");
            return Left;
        }
        if (Left->Usage == uConst && Right->Usage == uConst) {
            Left->Use.Const.lInteger -= Right->Use.Const.lInteger;
            Left->Use.Const.lInteger /= CalcSizeOf(Right->pType->Use.DecPtr.pTarget);
            switch (CalcSizeOf(Left->pType)) {
            case 1: Left = ExprMakeCastNode(LpStd_Ubyte, Left); break;
            case 2: Left = ExprMakeCastNode(LpStd_Uword, Left); break;
            default:Left = ExprMakeCastNode(LpStd_Ulong, Left); break;
            }
            ExprCleanUp(Right);
            return Left;
        }
        else {
            New = NewBinary(Left->pType->Use.DecArray.pTarget, Sub, Left, Right);
            New = NewBinary(Left->pType->Use.DecArray.pTarget, Div, New, ExprMakeConstI(CalcSizeOf(Left->pType->Use.DecArray.pTarget)));
            switch (CalcSizeOf(New->pType)) {
            case 1: New = ExprMakeCastNode(LpStd_Ubyte, New); break;
            case 2: New = ExprMakeCastNode(LpStd_Uword, New); break;
            default:New = ExprMakeCastNode(LpStd_Ulong, New); break;
            }
            return New;
        }
    }
    if (IsReference(Right->pType)) {
        Error(ERROR0, "Subtraction of a reference is not possible.");
        return Left;
    }
    if (IsReference(Left->pType) && IsSimple(Right->pType)) {
        if (IsPointer(Left->pType)) Right = Bmul(Right, ExprMakeConstI(CalcSizeOf(Left->pType->Use.DecPtr.pTarget)));
        else                        Right = Bmul(Right, ExprMakeConstI(CalcSizeOf(Left->pType->Use.DecArray.pTarget)));
        /* fall through to simple sub */
    }
//    if (Left->Usage == uConst && Right->Usage == uConst) {
//        Left->Use.Const.lInteger -= Right->Use.Const.lInteger;
//        ExprCleanUp(Right);
//        return Left;
//    }

    NewType = ResultingType(Left->pType, Right->pType);
    Left = ExprMakeCastNode(NewType, Left);
    Right = ExprMakeCastNode(NewType, Right);
    return NewBinary(NewType, Sub, Left, Right);

}

static TPExprNode
Bmul (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Multiplication of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger   *= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } 

    NewType = ResultingType(Left->pType,Right->pType);
    Left    = ExprMakeCastNode(NewType,Left);
    Right   = ExprMakeCastNode(NewType,Right);
    return NewBinary(NewType, Mul, Left, Right);
 }

static TPExprNode
Bdiv (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Division of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        if (Right->Use.Const.lInteger == 0) {
            Error(ERROR1, "Division by zero.");
            Left->Use.Const.lInteger = -1;
            return Left;
        }
        Left->Use.Const.lInteger /= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } 

    NewType = ResultingType(Left->pType,Right->pType);
    Left    = ExprMakeCastNode(NewType,Left);
    Right   = ExprMakeCastNode(NewType,Right);
    return NewBinary(NewType, Div,Left,Right);
 }


static TPExprNode
Bmod (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Modulus of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger %= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } 

    NewType = ResultingType(Left->pType,Right->pType);
    Left    = ExprMakeCastNode(NewType,Left);
    Right   = ExprMakeCastNode(NewType,Right);
    return NewBinary(NewType, Mod,Left,Right);
 }


static TPExprNode
Bband(TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Bitwise-And of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger &= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize And")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, BAnd,Left,Right);
    }
 }

static TPExprNode
Bbor (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Bitwise-Or of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger |= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Or")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, BOr,Left,Right);
    }
 }

static TPExprNode
Bbxor(TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Bitwise-Xor of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger ^= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize Xor")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, BXor,Left,Right);
    }
 }

static TPExprNode
Bbsr (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Shift-Right of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger >>= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize >>")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, BSR,Left,Right);
    }
 }

static TPExprNode
Bbsl (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (!IsSimple(Left->pType) || !IsSimple(Right->pType)) {
            Error(ERROR0, "Shift-Left of non-simple types is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger <<= Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize <<")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, BSL,Left,Right);
    }
 }

static TPExprNode
Bceq (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {
        Error(ERROR0, "Comparison of structures is not possible.");                                           
        return Left;
    }                                                                                                      
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                             
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                          
            Error(ERROR0, "Comparison a reference to a non-reference is not possible.");                     
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger == Right->Use.Const.lInteger) ? TRUE : FALSE;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize ==")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, CEQ,Left,Right);
    }
}

static TPExprNode
Bcne (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {
        Error(ERROR0, "Comparison of structures is not possible.");
        return Left;
    }
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {
            Error(ERROR0, "Comparison a reference to a non-reference is not possible.");
            return Left;
    }
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger != Right->Use.Const.lInteger) ? TRUE : FALSE;
        ExprCleanUp(Right);
        return Left;
    } else {
#pragma message("Optimize !=")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, CNE,Left,Right);
    }
}                                                                                                          

static TPExprNode
Bclt (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                              
       Error(ERROR0, "Comparison of structures is not possible.");                                       
        return Left;                                                                                     
    }                                                                                                    
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                         
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                      
            Error(ERROR0, "Comparison a reference to a non-reference is not possible.");                 
            return Left;                                                                                 
    }                                                                                                    
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger < Right->Use.Const.lInteger) ? TRUE : FALSE;
        ExprCleanUp(Right);                                                                              
        return Left;
    } else {
#pragma message("Optimize <")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, CLT,Left,Right);
    }
}                                                                                                          

static TPExprNode
Bcle (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                
        Error(ERROR0, "Comparison of structures is not possible.");                                        
        return Left;                                                                                       
    }                                                                                                      
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                           
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                        
            Error(ERROR0, "Comparison a reference to a non-reference is not possible.");                   
            return Left;                                                                                   
    }                                                                                                      
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger <= Right->Use.Const.lInteger) ? TRUE : FALSE; 
        ExprCleanUp(Right);                                                                                
        return Left;
    } else {
#pragma message("Optimize <=")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, CLE,Left,Right);
    }
}                                                                                                        

static TPExprNode
Bcgt (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                              
       Error(ERROR0, "Comparison of structures is not possible.");                                       
        return Left;                                                                                     
    }                                                                                                    
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                         
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                      
            Error(ERROR0, "Comparison a reference to a non-reference is not possible.");                 
            return Left;                                                                                 
    }                                                                                                    
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger > Right->Use.Const.lInteger) ? TRUE : FALSE;
        ExprCleanUp(Right);                                                                              
        return Left;
    } else {
#pragma message("Optimize >")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, CGT,Left,Right);
    }
}                                                                                                         

static TPExprNode
Bcge (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                               
       Error(ERROR0, "Comparison of structures is not possible.\n","");                                   
        return Left;                                                                                      
    }                                                                                                     
    if ((IsReference(Left->pType)  && IsSimple(Right->pType)) ||                                          
        (IsSimple(Left->pType)     && IsReference(Right->pType))) {                                       
            Error(ERROR0, "Comparison a reference to a non-reference is not possible.");                  
            return Left;                                                                                  
    }                                                                                                     
    if (Left->Usage == uConst && Right->Usage == uConst) {
#pragma message("Comparisons need to note the sign")
        Left->Use.Const.lInteger = (Left->Use.Const.lInteger >= Right->Use.Const.lInteger) ? TRUE : FALSE;
        ExprCleanUp(Right);                                                                               
        return Left;
    } else {
#pragma message("Optimize >=")
        NewType = ResultingType(Left->pType,Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, CGE,Left,Right);
    }
}                                                                                                     



static TPExprNode
Bland(TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                           
       Error(ERROR0, "Logical Operations on structures is not possible.");                            
        return Left;                                                                                  
    }                                                                                                 
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger = Left->Use.Const.lInteger && Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        Left->pType = LpStd_Ubyte;
        return Left;
    } else {
#pragma message("Optimize &&")
        NewType = ResultingType(Left->pType, Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, LAnd,Left,Right);
    }
}                                                                                                          

static TPExprNode
Blor (TPExprNode Left, TPExprNode Right) {
    TPDeclSpec NewType;
    if (IsStruct(Left->pType)  || IsStruct(Right->pType)) {                                                
       Error(ERROR0, "Logical Operations on structures is not possible.");                                 
        return Left;                                                                                       
    }                                                                                                      
    if (Left->Usage == uConst && Right->Usage == uConst) {
        Left->Use.Const.lInteger = Left->Use.Const.lInteger || Right->Use.Const.lInteger;
        ExprCleanUp(Right);
        Left->pType = LpStd_Ubyte;
        return Left;
    } else {
#pragma message("Optimize ||")
        NewType = ResultingType(Left->pType, Right->pType);
        Left    = ExprMakeCastNode(NewType,Left);
        Right   = ExprMakeCastNode(NewType,Right);
        return NewBinary(NewType, LOr,Left,Right);
    }
}


TPExprNode
ExprMakeBinaryNode(TIdExprBiOp Op, TPExprNode Left, TPExprNode Right) {
    switch (Op) {
        case    Add:    return Badd (Left,Right);
        case    Sub:    return Bsub (Left,Right);
        case    Mul:    return Bmul (Left,Right);
        case    Div:    return Bdiv (Left,Right);
        case    Mod:    return Bmod (Left,Right);
        case    BAnd:   return Bband(Left,Right);
        case    BOr:    return Bbor (Left,Right);
        case    BXor:   return Bbxor(Left,Right);
        case    CEQ:    return Bceq (Left,Right);
        case    CNE:    return Bcne (Left,Right);
        case    CLT:    return Bclt (Left,Right);
        case    CLE:    return Bcle (Left,Right);
        case    CGT:    return Bcgt (Left,Right);
        case    CGE:    return Bcge (Left,Right);
        case    LAnd:   return Bland(Left,Right);
        case    LOr:    return Blor (Left,Right);
        case    BSR:    return Bbsr (Left,Right);
        case    BSL:    return Bbsl (Left,Right);
        default:        Error(FATAL, "MakeBinaryNode: UnKnown Binary Operator %d\n", Op);
                        return Left;
    }
 }



/* ************************************************** */
/*  Ternary  */
/* ********* */

TPExprNode
TernaryCondExp(TPExprNode First, TPExprNode Second, TPExprNode Third) {
    TPExprNode New;
    if (First->Usage == uConst) {
        if (First->Use.Const.lInteger) {
            ExprCleanUp(First);
            ExprCleanUp(Third);
            return Second;
        } else {
            ExprCleanUp(First);
            ExprCleanUp(Second);
            return Third;
        }
    }
    New = NewExprNode(uTernary);
    New->pType = ResultingType(Second->pType,Third->pType);
    New->Use.Ternary.Op     = CondExp;
    New->Use.Ternary.First  = First;
    New->Use.Ternary.Second = ExprMakeCastNode(New->pType,Second);
    New->Use.Ternary.Third  = ExprMakeCastNode(New->pType,Third);
    return New;
 }

TPExprNode
ExprMakeTernaryNode(TIdExprTriOp Op,  TPExprNode First, TPExprNode Second, TPExprNode Third) {
    switch (Op) {
        case  CondExp:  return TernaryCondExp(First,Second,Third);
                        break;
        default:        Error(FATAL, "MakeTernaryNode: UnKnown Ternary Operator %d\n", Op);
                        return First;
    }
}



/* *************************************************************************** */
/*  Action Nodes                                                               */
/*  need some run time action to be performed in order to determin the result  */
/* *************************************************************************** */


    

TPExprNode
ExprMakeDotNode(TPExprNode Left,  LPSTR Field) {
    TPExprNode New;
    int iOffset;
    if (!IsStruct(Left->pType)) {
        Error(ERROR0, "Dot expected to be preceeded by a Struct/Union.");
        return Left;
    }
    ASSERT(Left->pType->Usage == DecSpec);
    iOffset = CalcStructElementOffset(Left->pType->Use.DecSpec.pPtr, Field);
    if (iOffset < 0) {
        Error(ERROR0, "Unknown struct/union field '%s'.",Field);
        return Left;
    }
    New = NewExprNode(uDot);
    New->pType = CalcStructElementType(Left->pType->Use.DecSpec.pPtr, Field);
    New->Use.Dot.pRecord = Left;
    New->Use.Dot.pszField  = Field;
    New->Use.Dot.iOffset = iOffset;
    return New;  
}

TPExprNode
ExprMakeArrowNode(TPExprNode Left,  LPSTR Field) {
    TPExprNode New;
    int iOffset;
    if (!IsPtrStruct(Left->pType)) {
        Error(ERROR0, "Arrow expected to be preceeded by a Pointer to Struct/Union.");
        return Left;
    }
    ASSERT(Left->pType->Usage == DecPtr);
    ASSERT(Left->pType->Use.DecPtr.pTarget && Left->pType->Use.DecPtr.pTarget->Usage == DecSpec);

    iOffset = CalcStructElementOffset(Left->pType->Use.DecPtr.pTarget->Use.DecSpec.pPtr, Field);
    if (iOffset < 0) {
        Error(ERROR0, "Unknown struct/union field '%s'.",Field);
        return Left;
    }
    New = NewExprNode(uArrow);
    New->pType = CalcStructElementType(Left->pType->Use.DecPtr.pTarget->Use.DecSpec.pPtr, Field);
    New->Use.Arrow.pRecord = Left;
    New->Use.Arrow.pszField  = Field;
    New->Use.Arrow.iOffset = iOffset;
    return New;  
}


TPExprNode ExprMakeArrayNode(TPExprNode Vec,  TPExprNode Ind) {
    TPExprNode pNew;
    if (!IsReference(Vec->pType) && IsSimple(Ind->pType)) {
        Error(ERROR0, "Reference expected before [...].");
        return Vec;
    }
    pNew = NewExprNode(uArray);
    pNew->Use.Array.pVector = Vec;
    if (IsPointer(Vec->pType)) {
        pNew->Use.Array.pIndex = ExprMakeCastNode(NewSpecType(TypeUNSIGNED | TypeSHORT, NULL), Bmul(Ind, ExprMakeConstI(CalcSizeOf(Vec->pType->Use.DecPtr.pTarget))));
        pNew->pType = Vec->pType->Use.DecPtr.pTarget;
    }
    else {
        pNew->Use.Array.pIndex = ExprMakeCastNode(NewSpecType(TypeUNSIGNED | TypeSHORT, NULL), Bmul(Ind, ExprMakeConstI(CalcSizeOf(Vec->pType->Use.DecArray.pTarget))));
        pNew->pType = Vec->pType->Use.DecArray.pTarget;
    }
    return pNew;
 }


 TPExprNode
     ExprMakeFuncNode(TPExprNode Func, TPExprNode Params) {
     TPExprNode New;
     if (!IsFunc(Func->pType)) {
         Error(ERROR0, "Function expected before (...).");
         return Func;
     }
     New = NewExprNode(uFunc);
     New->pType = Func->pType->Use.DecFunc.pReturnType;
     New->Use.pFunc.pFunc = Func;                  // Funky !
     New->Use.pFunc.pParams = Params;
     return New;
 }


 /* ************************************************** */
 /*  Assignment */
 /* *********** */

 TPExprNode
     ExprMakeAssignNode(TIdExprAssign Op, TPExprNode Lval, TPExprNode Rval) {
     TPExprNode New;
     New = NewExprNode(uAssign);
     New->Use.Assign.Op = Op;
     New->pType = Lval->pType;
     New->Use.Assign.pLval = Lval;
     New->Use.Assign.pRval = Rval;
     return New;
 }

 /* ************************************************** */
 /*  Cast  */
 /* ****** */
 static LONG
     TypeConvert(TPDeclSpec NewType, TPDeclSpec OldType, LONG Const) {
     WORD SzOld, SzNew;
     if (IsStruct(NewType) || IsStruct(OldType)) {
         Error(ERROR0, "Casting to/from struct is not possible.");
         return 0L;
     }
     SzOld = (WORD)CalcSizeOf(OldType);
     SzNew = (WORD)CalcSizeOf(NewType);
     if (IsReference(NewType) && IsReference(OldType) && (SzOld != SzNew)) {
         Error(WARNING0, "Conversion between near & far pointers.");
     }
     if (!(IsReference(NewType) || IsReference(OldType))) {
         if (SzNew > SzOld) {                                            // Cast up
             if (OldType->Use.DecSpec.Type & TypeUNSIGNED) {
                 switch (SzOld) {                                        // Cast up Unsigned
                 case 1: Const &= 0x000000ff; break;
                 case 2: Const &= 0x0000ffff; break;
                 case 3: Const &= 0x00ffffff; break;
                 case 4: Const &= 0xffffffff; break;
                 default: Error(ERROR0, "Casting unsigned constant from an unsupported size.");
                 }
             }
             else {                                                    // Cast up signed
                 switch (SzOld) {
                 case 1: if (Const & 0x00000080) Const |= 0xffffff00; else Const &= 0x000000ff; break;
                 case 2: if (Const & 0x00008000) Const |= 0xffff0000; else Const &= 0x0000ffff; break;
                 case 3: if (Const & 0x00800000) Const |= 0xff000000; else Const &= 0x00ffffff; break;
                 case 4: if (Const & 0x80000080) Const |= 0x00000000; else Const &= 0xffffffff; break;
                 default: Error(ERROR0, "Casting signed constant from an unsupported size.");
                 }
             }
         }
     }
     switch (SzNew) {
     case 1: Const &= 0x000000ff; break;
     case 2: Const &= 0x0000ffff; break;
     case 3: Const &= 0x00ffffff; break;
     case 4: Const &= 0xffffffff; break;
     default: Error(ERROR0, "Casting constant to an unsupported size.");
     }
     return Const;
 }

 static BOOL CompatibleTypes(TPDeclSpec pType1, TPDeclSpec pType2) {            // TRUE if no cast is needed. FALSE is cast is not required.
     ASSERT(pType1);
     ASSERT(pType2);

     if (((pType1->Usage == DecSpec) && (pType1->Use.DecSpec.Type == TypeVOID)) ||
         ((pType2->Usage == DecSpec) && (pType2->Use.DecSpec.Type == TypeVOID))) {                                          // VOID is not castable
         Error(ERROR1, "CompatibleTypes(): Arithmetic on a void value is impossible");
         return FALSE;
     }
     if ((pType1->Usage == DecSpec) && (pType2->Usage == DecSpec)) {                                                        // Both basic types
         if (pType1->Use.DecSpec.Type == pType2->Use.DecSpec.Type) {                                                        //      perfect match
             return TRUE;
         }
         if (((pType1->Use.DecSpec.Type & TypeUNSIGNED) ^ (pType2->Use.DecSpec.Type&TypeUNSIGNED)) == TypeUNSIGNED) {       //      one SIGNED one UNSIGNED
             Error(WARNING0, "CompatibleTypes(): Arithmetic with Signed & Unsigned inputs");
             return FALSE;
         }
         if (((pType1->Use.DecSpec.Type | pType2->Use.DecSpec.Type) & (TypeSHORT | TypeINT)) == (TypeSHORT | TypeINT)) {    //      INT & SHORT are the same.
             return TRUE;
         }
         if (((pType1->Use.DecSpec.Type | pType2->Use.DecSpec.Type) & (TypeLONG | TypeFLOAT | TypeDOUBLE)) != 0) {          //      unsuported type
             Error(ERROR0, "CompatibleTypes(): Long, float and double are not suported (yet)");
             return FALSE;
         }
     }
     return FALSE;                                                                                                          //      cast will be needed.
}

TPExprNode ExprMakeCastNode(TPDeclSpec pType, TPExprNode pNode) {
    TPExprNode New = NULL;
    ASSERT(pType && ((pType->Usage == DecSpec) || (pType->Usage == DecPtr)));
    if (pNode->Usage == uConst) {
        pNode->Use.Const.lInteger = TypeConvert(pType, pNode->pType, pNode->Use.Const.lInteger);
        pNode->pType = pType;
        return pNode;
    } else {
        if (CompatibleTypes(pType, pNode->pType)) {
            return pNode;
        }
        DWORD dwSizeNew = CalcSizeOf(pType);
        DWORD dwSizeOld = CalcSizeOf(pNode->pType);
        if (dwSizeNew == dwSizeOld) {                                               // ** size not changing **
            return pNode;                                                           //      no action
        }                                                                           //
        if (dwSizeNew > dwSizeOld) {                                                // ** Increasing **
            if (IsSigned(pNode->pType)) {                                           //
                if (dwSizeOld == 1) {                                               //      from Char
                    switch (dwSizeNew) {                                            //
                    case 2: New = NewExprNode(uCast_c2s); break;                    //          to short
                    case 4: New = NewExprNode(uCast_c2l); break;                    //          to long
                    default:                                                        //
                        Error(FATAL, "ExprMakeCastNode(); s8 to something silly");  //          to trouble
                    }                                                               //
                }                                                                   //
                else if (dwSizeOld == 2) {                                          //      from Short
                    switch (dwSizeNew) {                                            //
                    case 4: New = NewExprNode(uCast_s2l); break;                    //          to long
                    default:                                                        //
                        Error(FATAL, "ExprMakeCastNode(); s16 to something silly"); //          to trouble
                    }                                                               //
                }                                                                   //
                else {                                                              //      from problem
                    Error(FATAL, "ExprMakeCastNode(); from something silly");       //
                }                                                                   //
            }                                                                       //
            else {                                                                  //
                if (dwSizeOld == 1) {                                               //      from unsigned char
                    switch (dwSizeNew) {                                            //
                    case 2: New = NewExprNode(uCast_b2s); break;                    //          to short
                    case 4: New = NewExprNode(uCast_b2l); break;                    //          to long
                    default:                                                        //
                        Error(FATAL, "ExprMakeCastNode(); u8 to something silly");  //          to trouble
                    }                                                               //
                }                                                                   //
                else if (dwSizeOld == 2) {                                          //      from unsigned Short
                    switch (dwSizeNew) {                                            //
                    case 4: New = NewExprNode(uCast_u2l); break;                    //          to long
                    default:                                                        //
                        Error(FATAL, "ExprMakeCastNode(); u16 to something silly"); //          to trouble
                    }                                                               //
                }                                                                   //
                else {                                                              //
                    Error(FATAL, "ExprMakeCastNode(); from something silly");       //      from unsigned problem
                }                                                                   //
            }                                                                       //
        }
        else {                                                                      // ** Shrinking **
            if (dwSizeOld == 4) {                                                   //      from long
                switch (dwSizeNew) {                                                //
                case 2: New = NewExprNode(uCast_l2s); break;                        //          to short
                case 1: New = NewExprNode(uCast_l2b); break;                        //          to byte
                default:                                                            //
                    Error(FATAL, "ExprMakeCastNode(); long to something silly");    //          to trouble
                }                                                                   //
            }                                                                       //
            else if (dwSizeOld == 2) {                                              //      from short
                switch (dwSizeNew) {                                                //
                case 1: New = NewExprNode(uCast_s2b); break;                        //          to byte
                default:                                                            //
                    Error(FATAL, "ExprMakeCastNode(); short to something silly");   //          to trouble
                }                                                                   //
            }                                                                       //
            else {                                                                  //
                Error(FATAL, "ExprMakeCastNode(); shrinking silly size");           //      from trouble
            }                                                                       //
        }
        ASSERT(New != NULL);
        New->pType = pType;
        New->Use.Cast.pTarget = pNode;
        return New;
    }
 }


TPExprNode ExprMakeInitNode(TPExprNode pNode) {         // initializer element
    TPExprNode pNew;
    pNew = NewExprNode(uInit);
    pNew->Use.Init.pAssignment = pNode;
    //pNew->Use.Init.pSibling    = NULL;
    pNew->Use.Init.pChildren   = NULL;
    return pNew;
}

TPExprNode ExprMakeInitList(TPExprNode pNode) {         // braketed set of elements
    TPExprNode pNew;
    pNew = NewExprNode(uInit);
    pNew->Use.Init.pAssignment = NULL;
    //pNew->Use.Init.pSibling    = NULL;
    pNew->Use.Init.pChildren   = pNode;
    return pNew;
}

/*
TPExprNode ExprInitConcat(TPExprNode pNode, TPExprNode pSibling) {
    TPExprNode n;
    for (n=pNode; n->Use.Init.pSibling; n=n->Use.Init.pSibling);
    n->Use.Init.pSibling = pSibling;
    return pNode;
}
*/

TPExprNode  ExprConcat(TPExprNode pNode, TPExprNode pSibling) {
    TPExprNode n;
    for (n = pNode; n->pSibling; n = n->pSibling);
    n->pSibling = pSibling;
    return pNode;
}


/* ****************************************************************** */

DWORD ExprConstInt(TPExprNode E) {
    if (E->Usage != uConst) {
        Error(ERROR0, "Initializer must be a Constant value.");
        return 0L;
    }
    return E->Use.Const.lInteger;
 }


/* ****************************************************************** */

void
ExprCleanUp(TPExprNode n) {
    switch (n->Usage) {
        case    uConst:
        case    uVar:       break;
        case    uUnary:     ExprCleanUp(n->Use.Unary.pOperand);
                            break;
        case    uBinary:    ExprCleanUp(n->Use.Binary.pLeft);
                            ExprCleanUp(n->Use.Binary.pRight);
                            break;
        case    uTernary:   ExprCleanUp(n->Use.Ternary.First);
                            ExprCleanUp(n->Use.Ternary.Second);
                            ExprCleanUp(n->Use.Ternary.Third);
                            break;
        default:            Error(FATAL, "CleanUp: More to clean ! [%d]\n", n->Usage);
                            break;
    }
    Dispose(n);
}


/* eof */

