// # $URL$
// # $Revision$


#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <setjmp.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <limits.h>
#include <float.h>
#include <Windows.h>

//#include <ext\types.h>
#include "Utilities\Console.h"

#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "gen.h"
#include "main.h"
#include "C_Yacced.tab.h"
#include "GenStatements.h"

static int GenExpr(FILE *hOut, int iReg, TPExprNode pExpr);     // forward;


#ifdef _DEBUG

char *Uops[] = { "-u",  "+u",  "~u",    "u++",  "++u", "u--", "--u", "sizeof","addr", "ptr", "!u" };

char *Bops[] = { "+b",  "-b",  "*b",    "/b",   "%b", "&b",  "|b",  "^b",    "==b",  "!=b", "<b",  "<=b", ">b",    ">=b",  "&&b", "||b", ">>b", "<<b" };


void PrintNode(TPExprNode pN) {
    switch (pN->Usage) {
        case uConst:    printf("%lx ",  pN->Use.Const.lInteger);
                        break;
        case uVar:      printf("<%s> ",  pN->Use.Var.pszIdentifier);
                        break;
        case uUnary:    printf("(op ");
                        PrintNode(pN->Use.Unary.pOperand);
                        printf(")");
                        break;
        default:    Error(WARNING0, "Other ");
                    break;
    }
}

void ExprPrintInit(TPExprNode n) {
    while (n) {
        if (n->Usage != uInit) {
            Error(FATAL, "PrintInit: What !\n");
        }
        if (n->Use.Init.pAssignment) {
            PrintNode(n->Use.Init.pAssignment);
        }
        if (n->Use.Init.pChildren) {
            printf("{ ");
            ExprPrintInit(n->Use.Init.pChildren);
            printf("} ");
        }
        n=n->pSibling;
    }
}


void PrintType(int iDepth, TPExprNode n) {
    ASSERT(n->pType && ((n->pType->Usage == DecSpec) || (n->pType->Usage == DecPtr) || (n->pType->Usage == DecArray)));
    ParseDeclSpec(0, n->pType, FALSE);
 }

char *pszCasts[] = {
    "s8 to s16",
    "s8 to s32",
    "s16 to s32",
    "u8 to u16",
    "u8 to u32",
    "u16 to u32",
    "32 to 16",
    "32 to 8",
    "32 to BOOL",
    "16 to 8",
    "16 to BOOL"
};



void GenExpressionPrettyPrint(int iDepth, TPExprNode n) {
    if (!n) {
        printf("..Null\n");
        return;
    }
    
    switch (n->Usage) {
        case    uConst:     ConsoleIndent(iDepth);
                            ConsolePrintf(CON_MAGENTA_BRIGHT, "0x%x ",    n->Use.Const.lInteger);
                            PrintType(iDepth, n);
                            break;
        case    uVar:       ConsoleIndent(iDepth);
                            ConsolePrintf(CON_YELLOW_BRIGHT, "[%s",  n->Use.Var.pszIdentifier);
                            if (n->Use.Var.iFrameOffset != GLOBAL_VAR) ConsolePrintf(CON_YELLOW_BRIGHT, ":%d] ", n->Use.Var.iFrameOffset);       // variable offset
                            else                                       ConsolePrintf(CON_YELLOW_BRIGHT, "] ");                                   // variable is global
                            PrintType(iDepth, n);
                            break;
        case    uUnary:     ConsoleIndent(iDepth);
                            printf("%s ", Uops[n->Use.Unary.Op]);
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Unary.pOperand);
                            break;
        case    uBinary:    GenExpressionPrettyPrint(iDepth + 1, n->Use.Binary.pLeft);
                            ConsoleIndent(iDepth);
                            printf("%s ", Bops[n->Use.Unary.Op]);
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Binary.pRight);
                            break;
        case    uTernary:   ConsoleIndent(iDepth);
                            printf("Tern ");
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Ternary.First);
                            ConsoleIndent(iDepth);
                            printf("Then\n");
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Ternary.Second);
                            ConsoleIndent(iDepth);
                            printf("Else\n");
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Ternary.Third);
                            break;
        case    uDot:       GenExpressionPrettyPrint(iDepth + 1, n->Use.Dot.pRecord);
                            ConsoleIndent(iDepth);
                            printf("Dot ");
                            PrintType(iDepth, n);
                            ConsoleIndent(iDepth);
                            printf("[%s:%d]\n", n->Use.Dot.pszField, n->Use.Dot.iOffset);
                            break;
        case    uArrow:     GenExpressionPrettyPrint(iDepth + 1, n->Use.Arrow.pRecord);
                            ConsoleIndent(iDepth);
                            printf("Arrow ");
                            PrintType(iDepth, n);
                            ConsoleIndent(iDepth);
                            printf("[%s:%d]\n",n->Use.Arrow.pszField, n->Use.Arrow.iOffset);
                            break;
        case    uArray:     GenExpressionPrettyPrint(iDepth + 1, n->Use.Array.pVector);
                            ConsoleIndent(iDepth);
                            printf("Array ");
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Array.pIndex);
                            break;
        case    uFunc:      GenExpressionPrettyPrint(iDepth + 1, n->Use.pFunc.pFunc);
                            ConsoleIndent(iDepth);
                            printf("Function ");
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.pFunc.pParams);
                            break;
        case    uCast:      ConsoleIndent(iDepth);
                            printf("Cast %s", pszCasts[n->Use.Cast.Op]);
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Cast.pTarget);
                            break;
        case    uAssign:    ConsoleIndent(iDepth);
                            printf("Assign ");
                            PrintType(iDepth, n);
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Assign.pLval);
                            ConsoleIndent(iDepth);
                            printf("<==\n");
                            GenExpressionPrettyPrint(iDepth + 1, n->Use.Assign.pRval);
                            break;
        default:            Error(FATAL, "ParseExpr: What [%d]\n", n->Usage);
                            break;
    }
}
#endif // _DEBUG

// ############################################################################################
static LPSTR OperandRegImmediate(int iR1, unsigned char bVal) {
    static char caRegVal[16];
    sprintf_s(caRegVal, sizeof(caRegVal), "r%d, 0x%02x", iR1, bVal);
    return caRegVal;
}

static LPSTR OperandRegVar(int iR1, LPSTR pszVar) {
    static char caRegStr[256];
    if ((iR1 & 0x01) == 0) {
        sprintf_s(caRegStr, sizeof(caRegStr), "r%d, lo8(%s)", iR1, pszVar);
    }
    else {
        sprintf_s(caRegStr, sizeof(caRegStr), "r%d, hi8(%s)", iR1, pszVar);
    }
    return caRegStr;
}

static LPSTR OperandRegStr(int iR1, LPSTR pszStr) {
    static char caRegVal[16];
    sprintf_s(caRegVal, sizeof(caRegVal), "r%d, %s", iR1, pszStr);
    return caRegVal;
}

static LPSTR OperandStrReg(LPSTR pszStr, int iR1) {
    static char caRegVal[16];
    sprintf_s(caRegVal, sizeof(caRegVal), "%s, r%d", pszStr, iR1);
    return caRegVal;
}

static LPSTR OperandRegDisp(int iR1, LPSTR pszStr, int iDisp) {
    static char caRegVal[16];
    if (iDisp < 0) {
        sprintf_s(caRegVal, sizeof(caRegVal), "r%d, %s%d", iR1, pszStr, iDisp);
    }
    else {
        sprintf_s(caRegVal, sizeof(caRegVal), "r%d, %s+%d", iR1, pszStr, iDisp);
    }
    return caRegVal;
}

static LPSTR OperandDispReg(LPSTR pszStr, int iDisp, int iR1) {
    static char caRegVal[16];
    if (iDisp < 0) {
        sprintf_s(caRegVal, sizeof(caRegVal), "%s%d, r%d", pszStr, iDisp, iR1);
    }
    else {
        sprintf_s(caRegVal, sizeof(caRegVal), "%s+%d, r%d", pszStr, iDisp, iR1);
    }
    return caRegVal;
}

static LPSTR OperandReg(int iR) {
    static char caRegPair[16];
    sprintf_s(caRegPair, sizeof(caRegPair), "r%d", iR);
    return caRegPair;
}

static LPSTR OperandRegReg(int iR1, int iR2) {
    static char caRegPair[16];
    sprintf_s(caRegPair, sizeof(caRegPair), "r%d, r%d", iR1, iR2);
    return caRegPair;
}

static LPSTR CommentNumber(int iCycles, LPSTR pszT, long lValue) {
    static char caComment[256];
    sprintf_s(caComment, sizeof(caComment), "%3d: %s%ld", iCycles, pszT, lValue);
    return caComment;
}

static LPSTR CommentString(int iCycles, LPSTR pszT, LPSTR pszM) {
    static char caComment[256];
    sprintf_s(caComment, sizeof(caComment), "%3d: %s%s", iCycles, pszT, pszM);
    return caComment;
}

int AVR_LoadImmediate8(FILE *hOut, int iReg, unsigned char bValue) {
    GenAsmOut(hOut, "", "ldi",  OperandRegImmediate(26, bValue), CommentNumber(1, "", bValue), TRUE, FALSE);
    GenAsmOut(hOut, "", "mov",  OperandRegReg(iReg, 26),         "  1:",                       TRUE, FALSE);
    return iReg + 1;
}
int  AVR_LoadImmediate16(FILE *hOut, int iReg, unsigned short nValue) {
    GenAsmOut(hOut, "", "ldi",  OperandRegImmediate(26, (nValue & 0xFF)),        CommentNumber(1, "", nValue), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi",  OperandRegImmediate(27, ((nValue >> 8) & 0xFF)), "  1:",                       TRUE, FALSE);
    GenAsmOut(hOut, "", "movw", OperandRegReg(iReg, 26),                         "  1:",                       TRUE, FALSE);
    return iReg + 2;
}
int  AVR_LoadImmediate32(FILE *hOut, int iReg, unsigned long lValue) {
    GenAsmOut(hOut, "", "ldi",  OperandRegImmediate(26, (lValue & 0xFF)),         CommentNumber(1, "", lValue), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi",  OperandRegImmediate(27, ((lValue >> 8) & 0xFF)),  "  1:",                       TRUE, FALSE);
    GenAsmOut(hOut, "", "movw", OperandRegReg(iReg, 26),                          "  1:",                       TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi",  OperandRegImmediate(26, ((lValue >> 16) & 0xFF)), "  1:",                       TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi",  OperandRegImmediate(27, ((lValue >> 24) & 0xFF)), "  1:",                       TRUE, FALSE);
    GenAsmOut(hOut, "", "movw", OperandRegReg(iReg+2, 26),                        "  1:",                       TRUE, FALSE);
    return iReg + 4;
}

int AVR_LoadRom8(FILE *hOut, int iReg, LPSTR pszVar) {
    GenAsmOut(hOut, "", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi", OperandRegVar(31, pszVar), "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "lpm", OperandRegStr(iReg, "Z"),  "  3:", TRUE, FALSE);
    return iReg + 1;
}
int  AVR_LoadRom16(FILE *hOut, int iReg, LPSTR pszVar) {
    GenAsmOut(hOut, "", "ldi", OperandRegVar(30, pszVar),     CommentString(1, "Z = ", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi", OperandRegVar(31, pszVar),     "  1:",                           TRUE, FALSE);
    GenAsmOut(hOut, "", "lpm", OperandRegStr(iReg,     "Z+"), "  3:",                           TRUE, FALSE);
    GenAsmOut(hOut, "", "lpm", OperandRegStr(iReg + 1, "Z"),  "  3:",                           TRUE, FALSE);
    return iReg + 2;
}
int  AVR_LoadRom32(FILE *hOut, int iReg, LPSTR pszVar) {
    GenAsmOut(hOut, "", "ldi", OperandRegVar(30, pszVar),     CommentString(1, "Z = ", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi", OperandRegVar(31, pszVar),     "  1:",                           TRUE, FALSE);
    GenAsmOut(hOut, "", "lpm", OperandRegStr(iReg,     "Z+"), "  3:",                           TRUE, FALSE);
    GenAsmOut(hOut, "", "lpm", OperandRegStr(iReg + 1, "Z+"), "  3:",                           TRUE, FALSE);
    GenAsmOut(hOut, "", "lpm", OperandRegStr(iReg + 2, "Z+"), "  3:",                           TRUE, FALSE);
    GenAsmOut(hOut, "", "lpm", OperandRegStr(iReg + 3, "Z"),  "  3:",                           TRUE, FALSE);
    return iReg + 4;
}

int AVR_LoadRam8(FILE *hOut, int iReg, LPSTR pszVar) {
    GenAsmOut(hOut, "", "ldi", OperandRegVar(30, pszVar), CommentString(1, "Z = ", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi", OperandRegVar(31, pszVar), "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "ld", OperandRegStr(iReg, "Z"), "  1:", TRUE, FALSE);
    return iReg + 1;
    ;
}

int  AVR_LoadRam16(FILE *hOut, int iReg, LPSTR pszVar) {
    GenAsmOut(hOut, "", "ldi", OperandRegVar(30, pszVar),        CommentString(1, "Z = ", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi", OperandRegVar(31, pszVar),        "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "ld",  OperandRegStr(iReg, "Z"),         "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "ldd", OperandRegDisp(iReg + 1, "Z", 1), "  2:", TRUE, FALSE);
    return iReg + 2;
}

int  AVR_LoadRam32(FILE *hOut, int iReg, LPSTR pszVar) {
    GenAsmOut(hOut, "", "ldi", OperandRegVar(30, pszVar),        CommentString(1, "Z = ", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi", OperandRegVar(31, pszVar),        "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "ld",  OperandRegStr(iReg, "Z"),         "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "ldd", OperandRegDisp(iReg + 1, "Z", 1), "  2:", TRUE, FALSE);
    GenAsmOut(hOut, "", "ldd", OperandRegDisp(iReg + 2, "Z", 2), "  2:", TRUE, FALSE);
    GenAsmOut(hOut, "", "ldd", OperandRegDisp(iReg + 3, "Z", 3), "  2:", TRUE, FALSE);
    return iReg + 4;
}

int AVR_StoreRam8(FILE *hOut, LPSTR pszVar, int iReg) {
    GenAsmOut(hOut, "", "ldi", OperandRegVar(30, pszVar),        CommentString(1, "Z = ", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi", OperandRegVar(31, pszVar),        "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "st",  OperandStrReg("Z", iReg),         "  1:", TRUE, FALSE);
    return iReg + 1;
    ;
}
int  AVR_StoreRam16(FILE *hOut, LPSTR pszVar, int iReg) {
    GenAsmOut(hOut, "", "ldi", OperandRegVar(30, pszVar),        CommentString(1, "Z = ", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi", OperandRegVar(31, pszVar),        "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "st",  OperandStrReg("Z", iReg),         "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "std", OperandDispReg("Z", 1, iReg + 1), "  2:", TRUE, FALSE);
    return iReg + 2;
}
int  AVR_StoreRam32(FILE *hOut, LPSTR pszVar, int iReg) {
    GenAsmOut(hOut, "", "ldi", OperandRegVar(30, pszVar),        CommentString(1, "Z = ", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldi", OperandRegVar(31, pszVar),        "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "st",  OperandStrReg("Z", iReg),         "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "std", OperandDispReg("Z", 1, iReg + 1), "  2:", TRUE, FALSE);
    GenAsmOut(hOut, "", "std", OperandDispReg("Z", 2, iReg + 2), "  2:", TRUE, FALSE);
    GenAsmOut(hOut, "", "std", OperandDispReg("Z", 3, iReg + 3), "  2:", TRUE, FALSE);
    return iReg + 2;
}



int AVR_LoadFrame8(FILE *hOut, int iReg, int iOffset, LPSTR pszVar) {
    GenAsmOut(hOut, "", "ldd", OperandRegDisp(iReg, "Y", iGlbLocalSize + iOffset), CommentString(2, "", pszVar), TRUE, FALSE);
    return iReg + 1;
}
int  AVR_LoadFrame16(FILE *hOut, int iReg, int iOffset, LPSTR pszVar) {
    GenAsmOut(hOut, "", "ldd", OperandRegDisp(iReg,      "Y", iGlbLocalSize + iOffset),   CommentString(2, "", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldd", OperandRegDisp(iReg + 1 , "Y", iGlbLocalSize + iOffset+1), "  2:",                       TRUE, FALSE);
    return iReg + 2;
}
int  AVR_LoadFrame32(FILE *hOut, int iReg, int iOffset, LPSTR pszVar) {
    GenAsmOut(hOut, "", "ldd", OperandRegDisp(iReg,     "Y", iGlbLocalSize + iOffset),     CommentString(2, "", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "ldd", OperandRegDisp(iReg + 1, "Y", iGlbLocalSize + iOffset + 1), "  2:", TRUE, FALSE);
    GenAsmOut(hOut, "", "ldd", OperandRegDisp(iReg + 2, "Y", iGlbLocalSize + iOffset + 2), "  2:", TRUE, FALSE);
    GenAsmOut(hOut, "", "ldd", OperandRegDisp(iReg + 3, "Y", iGlbLocalSize + iOffset + 3), "  2:", TRUE, FALSE);
    return iReg + 4;
}

int AVR_StoreFrame8(FILE *hOut, int iOffset, int iReg, LPSTR pszVar) {
    GenAsmOut(hOut, "", "std", OperandDispReg("Y", iGlbLocalSize + iOffset, iReg), CommentString(2, "", pszVar), TRUE, FALSE);
    return iReg + 1;
}
int  AVR_StoreFrame16(FILE *hOut, int iOffset, int iReg, LPSTR pszVar) {
    GenAsmOut(hOut, "", "std", OperandDispReg("Y", iGlbLocalSize + iOffset,   iReg),   CommentString(2, "", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "std", OperandDispReg("Y", iGlbLocalSize + iOffset+1, iReg+1), "  2:",                       TRUE, FALSE);
    return iReg + 2;
}
int  AVR_StoreFrame32(FILE *hOut, int iOffset, int iReg, LPSTR pszVar) {
    GenAsmOut(hOut, "", "std", OperandDispReg("Y", iGlbLocalSize + iOffset,   iReg),   CommentString(2, "", pszVar), TRUE, FALSE);
    GenAsmOut(hOut, "", "std", OperandDispReg("Y", iGlbLocalSize + iOffset+1, iReg+1), "  2:", TRUE, FALSE);
    GenAsmOut(hOut, "", "std", OperandDispReg("Y", iGlbLocalSize + iOffset+2, iReg+2), "  2:", TRUE, FALSE);
    GenAsmOut(hOut, "", "std", OperandDispReg("Y", iGlbLocalSize + iOffset+3, iReg+3), "  2:", TRUE, FALSE);
    return iReg + 4;
}

// ############################################################################################

int GenAdd(FILE *hOut, int iReg, int iSize) {
    switch (iSize) {
    case 1: 
        GenAsmOut(hOut, "", "add", OperandRegReg(iReg - 2, iReg - 1), "  1: Add8", TRUE, FALSE);
        break;
    case 2:
        GenAsmOut(hOut, "", "add", OperandRegReg(iReg - 4, iReg - 2), "  1: Add16", TRUE, FALSE);
        GenAsmOut(hOut, "", "adc", OperandRegReg(iReg - 3, iReg - 1), "  1:", TRUE, FALSE);
        break;
    case 4:
        GenAsmOut(hOut, "", "add", OperandRegReg(iReg - 8, iReg - 4), "  1: Add32", TRUE, FALSE);
        GenAsmOut(hOut, "", "adc", OperandRegReg(iReg - 7, iReg - 3), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "adc", OperandRegReg(iReg - 6, iReg - 2), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "adc", OperandRegReg(iReg - 5, iReg - 1), "  1:", TRUE, FALSE);
        break;
    default:
        Error(FATAL, "GenAdd: size not supported (%d)\n", iSize);
    }
    return iReg - iSize;
}

int GenSub(FILE *hOut, int iReg, int iSize) {
    switch (iSize) {
    case 1:
        GenAsmOut(hOut, "", "sub", OperandRegReg(iReg - 2, iReg - 1), "  1: Sub8", TRUE, FALSE);
        break;
    case 2:
        GenAsmOut(hOut, "", "sub", OperandRegReg(iReg - 4, iReg - 2), "  1: Sub16", TRUE, FALSE);
        GenAsmOut(hOut, "", "sbc", OperandRegReg(iReg - 3, iReg - 1), "  1:", TRUE, FALSE);
        break;
    case 4:
        GenAsmOut(hOut, "", "sub", OperandRegReg(iReg - 8, iReg - 4), "  1: Sub32", TRUE, FALSE);
        GenAsmOut(hOut, "", "sbc", OperandRegReg(iReg - 7, iReg - 3), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "sbc", OperandRegReg(iReg - 6, iReg - 2), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "sbc", OperandRegReg(iReg - 5, iReg - 1), "  1:", TRUE, FALSE);
        break;
    default:
        Error(FATAL, "GenSub: size not supported (%d)\n", iSize);
    }
    return iReg - iSize;
}

int GenMul(FILE *hOut, int iReg, int iSize) {
    LPSTR   szMulLoop = GenLabel("_MulMult_");
    LPSTR   szMulDone = GenLabel("_MulDone_");

    switch (iSize) {
    case 1:
        GenAsmOut(hOut, "",        "clr",  OperandReg(0),                  "  1: Mul 8", TRUE, FALSE);
        GenAsmOut(hOut, szMulLoop, "sbrc", OperandRegImmediate(iReg-2, 0), "1/3:", TRUE, FALSE);
        GenAsmOut(hOut, "",        "add",  OperandRegReg(0, iReg-1),       "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "",        "lsl",  OperandReg(iReg - 1),           "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "",        "breq", szMulDone,                      "1/2:", TRUE, FALSE);
        GenAsmOut(hOut, "",        "lsr",  OperandReg(iReg - 2),           "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "",        "brne", szMulLoop,                      "1/2:", TRUE, FALSE);
        GenAsmOut(hOut, szMulDone, "mov",  OperandRegReg(iReg - 2, 0),     "  1:", TRUE, FALSE);
        break;
    case 2:
        if ((iReg & 1) == 1) {
            GenAsmOut(hOut, "", "movw", OperandRegReg(24, iReg - 4), "  1: Mul 16", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", OperandRegReg(26, iReg - 2), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "rcall","SysMul16",                  " +3:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", OperandRegReg(iReg - 4, 0),  "  1:",        TRUE, FALSE);
        }
        else {
            GenAsmOut(hOut, "", "mov",  OperandRegReg(24, iReg - 4), "  1: Mul 16", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",  OperandRegReg(25, iReg - 3), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",  OperandRegReg(26, iReg - 2), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",  OperandRegReg(27, iReg - 1), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "rcall","SysMul16",                  " +3:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",  OperandRegReg(iReg - 4, 0),  "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",  OperandRegReg(iReg - 3, 1),  "  1:",        TRUE, FALSE);
        }
        break;
    case 4:
        if ((iReg & 1) == 1) {
            GenAsmOut(hOut, "", "movw", OperandRegReg(20, iReg - 8), "  1: Mul 32", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", OperandRegReg(22, iReg - 6), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", OperandRegReg(24, iReg - 4), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", OperandRegReg(26, iReg - 2), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "rcall", "SysMul32",                 " +3:", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", OperandRegReg(iReg - 8, 0),  "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", OperandRegReg(iReg - 6, 2),  "  1:", TRUE, FALSE);
        }
        else {
            GenAsmOut(hOut, "", "mov", OperandRegReg(20, iReg - 8), "  1: Mul 32", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(21, iReg - 7), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(22, iReg - 6), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(23, iReg - 5), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(24, iReg - 4), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(25, iReg - 3), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(26, iReg - 2), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(27, iReg - 1), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "rcall", "SysMul32",                " +3:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(iReg - 8, 0),  "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(iReg - 7, 1),  "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(iReg - 6, 2),  "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(iReg - 5, 3),  "  1:", TRUE, FALSE);
        }
        break;
    default:
        Error(FATAL, "GenSub: size not supported (%d)\n", iSize);
    }
        
    return iReg - iSize;
}


int GenDiv(FILE *hOut, int iReg, int iSize, BOOL fSignedL, BOOL fSignedR) {
    LPSTR   szDivLoop = GenLabel("_DivLoop_");
    LPSTR   szDivEntr = GenLabel("_DivEntr_");

    switch (iSize) {
    case 1:
        GenAsmOut(hOut, "",        "clr",  OperandReg(25),            "  1: Div 8", TRUE, FALSE);   // unsigned
        GenAsmOut(hOut, "",        "ldi",  OperandRegImmediate(23,9), "  1:",       TRUE, FALSE);
        GenAsmOut(hOut, "",        "rjmp", szDivEntr,                 "  2:",       TRUE, FALSE);
        GenAsmOut(hOut, szDivLoop, "rol",  OperandReg(25),            "  1:",       TRUE, FALSE);
        GenAsmOut(hOut, "",        "cp",   OperandRegReg(25, iReg-1), "  1:",       TRUE, FALSE);
        GenAsmOut(hOut, "",        "brcs", szDivEntr,                 "1/3:",       TRUE, FALSE);
        GenAsmOut(hOut, "",        "sub",  OperandRegReg(25, iReg-1), "  1:",       TRUE, FALSE);
        GenAsmOut(hOut, szDivEntr, "rol",  OperandReg(iReg-2),        "  1:",       TRUE, FALSE);
        GenAsmOut(hOut, "",        "dec",  OperandReg(23),            "  1:",       TRUE, FALSE);
        GenAsmOut(hOut, "",        "brne", szDivLoop,                 "  1:",       TRUE, FALSE);
        GenAsmOut(hOut, "",        "com",  OperandReg(iReg-2),        "  1:",       TRUE, FALSE);
        break;
    case 2:
        if ((iReg & 1) == 1) {
            GenAsmOut(hOut, "", "movw",  OperandRegReg(24, iReg - 4), "  1: Div 16", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw",  OperandRegReg(26, iReg - 2), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "rcall", "SysDiv16",                  " +3:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "movw",  OperandRegReg(iReg - 4, 24), "  1:",        TRUE, FALSE);
        }
        else {
            GenAsmOut(hOut, "", "mov",   OperandRegReg(24, iReg - 4), "  1: Div 16", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(25, iReg - 3), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(26, iReg - 2), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(27, iReg - 1), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "rcall", "SysDiv16",                  " +3:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(iReg - 4, 24), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(iReg - 3, 25), "  1:",        TRUE, FALSE);
        }
        break;
    case 4:
        if ((iReg & 1) == 1) {
            GenAsmOut(hOut, "", "movw", OperandRegReg(20, iReg - 8), "  1: Div 32", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", OperandRegReg(22, iReg - 6), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", OperandRegReg(24, iReg - 4), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", OperandRegReg(26, iReg - 2), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "rcall", "SysDiv32",                 " +3:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", OperandRegReg(iReg - 8, 24), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "movw", OperandRegReg(iReg - 6, 26), "  1:",        TRUE, FALSE);
        }
        else {
            GenAsmOut(hOut, "", "mov", OperandRegReg(20, iReg - 8), "  1: Div 32", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(21, iReg - 7), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(22, iReg - 6), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(23, iReg - 5), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(24, iReg - 4), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(25, iReg - 3), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(26, iReg - 2), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(27, iReg - 1), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "rcall", "SysDiv32",                " +3:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(iReg - 8, 24), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(iReg - 7, 25), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(iReg - 6, 26), "  1:",        TRUE, FALSE);
            GenAsmOut(hOut, "", "mov", OperandRegReg(iReg - 5, 27), "  1:",        TRUE, FALSE);
        }
        break;
    default:
        Error(FATAL, "GenDiv: size not supported (%d)\n", iSize);
    }

    return iReg - iSize;
}

int GenMod(FILE *hOut, int iReg, int iSize, BOOL fSignedL, BOOL fSignedR) {
    LPSTR   szModLoop = GenLabel("_ModLoop_");
    LPSTR   szModEntr = GenLabel("_ModEntr_");

    switch (iSize) {
    case 1:
        GenAsmOut(hOut, "",        "clr",  OperandReg(25),              "  1: Mod8", TRUE, FALSE);
        GenAsmOut(hOut, "",        "ldi",  OperandRegImmediate(23, 9),  "  1:",      TRUE, FALSE);
        GenAsmOut(hOut, "",        "rjmp", szModEntr,                   "  2:",      TRUE, FALSE);
        GenAsmOut(hOut, szModLoop, "rol",  OperandReg(25),              "  1:",      TRUE, FALSE);
        GenAsmOut(hOut, "",        "cp",   OperandRegReg(25, iReg - 1), "  1:",      TRUE, FALSE);
        GenAsmOut(hOut, "",        "brcs", szModEntr,                   "1/3:",      TRUE, FALSE);
        GenAsmOut(hOut, "",        "sub",  OperandRegReg(25, iReg - 1), "  1:",      TRUE, FALSE);
        GenAsmOut(hOut, szModEntr, "rol",  OperandReg(iReg - 2),        "  1:",      TRUE, FALSE);
        GenAsmOut(hOut, "",        "dec",  OperandReg(23),              "  1:",      TRUE, FALSE);
        GenAsmOut(hOut, "",        "brne", szModLoop,                   "  1:",      TRUE, FALSE);
        GenAsmOut(hOut, "",        "mov",  OperandRegReg(iReg - 2, 0),  "  1:",      TRUE, FALSE);
        break;
    case 2:
        if ((iReg & 1) == 1) {
            GenAsmOut(hOut, "", "movw",  OperandRegReg(24, iReg - 4), "  1: Mod16", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw",  OperandRegReg(26, iReg - 2), "  1:",       TRUE, FALSE);
            GenAsmOut(hOut, "", "rcall", "SysDiv16",                  " +3:",       TRUE, FALSE);
            GenAsmOut(hOut, "", "movw",  OperandRegReg(iReg - 4, 0),  "  1:",       TRUE, FALSE);
        }
        else {
            GenAsmOut(hOut, "", "mov",   OperandRegReg(24, iReg - 4), "  1: Mod16", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(25, iReg - 3), "  1:",       TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(26, iReg - 2), "  1:",       TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(27, iReg - 1), "  1:",       TRUE, FALSE);
            GenAsmOut(hOut, "", "rcall", "SysDiv16",                  " +3:",       TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(iReg - 4, 0),  "  1:",       TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(iReg - 3, 1),  "  1:",       TRUE, FALSE);
        }
        break;
    case 4:
        if ((iReg & 1) == 1) {
            GenAsmOut(hOut, "", "movw",  OperandRegReg(20, iReg - 8), "  1: Mod32", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw",  OperandRegReg(22, iReg - 6), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw",  OperandRegReg(24, iReg - 4), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw",  OperandRegReg(26, iReg - 2), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "rcall", "SysDiv32",                  " +3:", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw",  OperandRegReg(iReg - 8, 0),  "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "movw",  OperandRegReg(iReg - 6, 2),  "  1:", TRUE, FALSE);
        }
        else {
            GenAsmOut(hOut, "", "mov",   OperandRegReg(20, iReg - 8), "  1: Mod32", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(21, iReg - 7), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(22, iReg - 6), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(23, iReg - 5), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(24, iReg - 4), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(25, iReg - 3), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(26, iReg - 2), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(27, iReg - 1), "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "rcall", "SysDiv32",                  " +3:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(iReg - 8, 0),  "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(iReg - 7, 1),  "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(iReg - 6, 2),  "  1:", TRUE, FALSE);
            GenAsmOut(hOut, "", "mov",   OperandRegReg(iReg - 5, 3),  "  1:", TRUE, FALSE);
        }
        break;
    default:
        Error(FATAL, "GenMod: size not supported (%d)\n", iSize);
    }

    return iReg - iSize;
}

int GenAnd(FILE *hOut, int iReg, int iSize) {
    switch (iSize) {
    case 1:
        GenAsmOut(hOut, "", "and", OperandRegReg(iReg - 2, iReg - 1), "  1: And8", TRUE, FALSE);
        break;
    case 2:
        GenAsmOut(hOut, "", "and", OperandRegReg(iReg - 4, iReg - 2), "  1: And16", TRUE, FALSE);
        GenAsmOut(hOut, "", "and", OperandRegReg(iReg - 3, iReg - 1), "  1:", TRUE, FALSE);
        break;
    case 4:
        GenAsmOut(hOut, "", "and", OperandRegReg(iReg - 8, iReg - 4), "  1: And32", TRUE, FALSE);
        GenAsmOut(hOut, "", "and", OperandRegReg(iReg - 7, iReg - 3), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "and", OperandRegReg(iReg - 6, iReg - 2), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "and", OperandRegReg(iReg - 5, iReg - 1), "  1:", TRUE, FALSE);
        break;
    default:
        Error(FATAL, "GenAnd: size not supported (%d)\n", iSize);
    }
    return iReg - iSize;
}

int GenXor(FILE *hOut, int iReg, int iSize) {
    switch (iSize) {
    case 1:
        GenAsmOut(hOut, "", "eor", OperandRegReg(iReg - 2, iReg - 1), "  1: Xor8", TRUE, FALSE);
        break;
    case 2:
        GenAsmOut(hOut, "", "eor", OperandRegReg(iReg - 4, iReg - 2), "  1: Xor16", TRUE, FALSE);
        GenAsmOut(hOut, "", "eor", OperandRegReg(iReg - 3, iReg - 1), "  1:", TRUE, FALSE);
        break;
    case 4:
        GenAsmOut(hOut, "", "eor", OperandRegReg(iReg - 8, iReg - 4), "  1: Xor32", TRUE, FALSE);
        GenAsmOut(hOut, "", "eor", OperandRegReg(iReg - 7, iReg - 3), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "eor", OperandRegReg(iReg - 6, iReg - 2), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "eor", OperandRegReg(iReg - 5, iReg - 1), "  1:", TRUE, FALSE);
        break;
    default:
        Error(FATAL, "GenXor: size not supported (%d)\n", iSize);
    }
    return iReg - iSize;
}

int GenOr(FILE *hOut, int iReg, int iSize) {
    switch (iSize) {
    case 1:
        GenAsmOut(hOut, "", "Or", OperandRegReg(iReg - 2, iReg - 1), "  1: Or8", TRUE, FALSE);
        break;
    case 2:
        GenAsmOut(hOut, "", "Or", OperandRegReg(iReg - 4, iReg - 2), "  1: Or16", TRUE, FALSE);
        GenAsmOut(hOut, "", "Or", OperandRegReg(iReg - 3, iReg - 1), "  1:", TRUE, FALSE);
        break;
    case 4:
        GenAsmOut(hOut, "", "Or", OperandRegReg(iReg - 8, iReg - 4), "  1: Or32", TRUE, FALSE);
        GenAsmOut(hOut, "", "Or", OperandRegReg(iReg - 7, iReg - 3), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "Or", OperandRegReg(iReg - 6, iReg - 2), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "Or", OperandRegReg(iReg - 5, iReg - 1), "  1:", TRUE, FALSE);
        break;
    default:
        Error(FATAL, "GenOr: size not supported (%d)\n", iSize);
    }
    return iReg - iSize;
}

int GenShiftL(FILE *hOut, int iReg, int iSize) {
    LPSTR   szRotDone = GenLabel("_LSLdone_");
    LPSTR   szRepeat = GenLabel("_LSLagain_");
    GenAsmOut(hOut, "", "Tst",  OperandReg(iReg - 1),         "  1: Shift Left", TRUE, FALSE);
    GenAsmOut(hOut, "", "breq", szRotDone,                    "2/3:",            TRUE, FALSE);
    switch (iSize) {
    case 1:
        GenAsmOut(hOut, szRepeat, "lsl", OperandReg(iReg - 2), "  1: << 8", TRUE, FALSE);
        break;
    case 2:
        GenAsmOut(hOut, szRepeat, "lsl", OperandReg(iReg - 3), "  1: << 16", TRUE, FALSE);
        GenAsmOut(hOut, "",       "rol", OperandReg(iReg - 2), "  1:", TRUE, FALSE);
        break;
    case 4:
        GenAsmOut(hOut, szRepeat, "lsl", OperandReg(iReg - 5), "  1: << 32", TRUE, FALSE);
        GenAsmOut(hOut, "",       "rol", OperandReg(iReg - 4), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "",       "rol", OperandReg(iReg - 3), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "",       "rol", OperandReg(iReg - 2), "  1:", TRUE, FALSE);
        break;
    default:
        Error(FATAL, "GenShiftL: size not supported (%d)\n", iSize);
    }
    GenAsmOut(hOut, "", "dec", OperandReg(iReg - 1), "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "brne", szRepeat, "2/3:", TRUE, FALSE);
    GenAsmOut(hOut, szRotDone, "", "", "---: Shift left done.", TRUE, FALSE);
    return iReg - 1;
}

int GenShiftR(FILE *hOut, int iReg, int iSize, BOOL fSigned) {
    LPSTR   szRotDone = GenLabel("_RSLdone_");
    LPSTR   szRepeat = GenLabel("_RSLagain_");
    GenAsmOut(hOut, "", "Tst", OperandReg(iReg - 1), "  1: Shift Right", TRUE, FALSE);
    GenAsmOut(hOut, "", "breq", szRotDone, "2/3:", TRUE, FALSE);
    switch (iSize) {
    case 1:
        if (fSigned) GenAsmOut(hOut, szRepeat, "asr", OperandReg(iReg - 2), "  1: >> 8 (signed)", TRUE, FALSE);
        else         GenAsmOut(hOut, szRepeat, "lsr", OperandReg(iReg - 2), "  1: >> 8 (unsigned)", TRUE, FALSE);
        break;
    case 2:
        if (fSigned) GenAsmOut(hOut, szRepeat, "asr", OperandReg(iReg - 2), "  1: >> 16 (signed)", TRUE, FALSE);
        else         GenAsmOut(hOut, szRepeat, "lsr", OperandReg(iReg - 2), "  1: >> 16 (unsigned)", TRUE, FALSE);
        GenAsmOut(hOut, "", "ror", OperandReg(iReg - 3), "  1:", TRUE, FALSE);
        break;
    case 4:
        if (fSigned) GenAsmOut(hOut, szRepeat, "asr", OperandReg(iReg - 2), "  1: >> 32 (signed)", TRUE, FALSE);
        else         GenAsmOut(hOut, szRepeat, "lsr", OperandReg(iReg - 2), "  1: >> 32 (unsigned)", TRUE, FALSE);
        GenAsmOut(hOut, "", "ror", OperandReg(iReg - 3), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "ror", OperandReg(iReg - 4), "  1:", TRUE, FALSE);
        GenAsmOut(hOut, "", "ror", OperandReg(iReg - 5), "  1:", TRUE, FALSE);
        break;
    default:
        Error(FATAL, "GenShiftR: size not supported (%d)\n", iSize);
    }
    GenAsmOut(hOut, "", "dec", OperandReg(iReg - 1), "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "brne", szRepeat, "2/3:", TRUE, FALSE);
    GenAsmOut(hOut, szRotDone, "", "", "---: Shift Right done.", TRUE, FALSE);
    return iReg - 1;
}


// ##########################################################################
// #  Function: GenExprConst
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenExprConst(FILE *hOut, int iReg, TPExprNode pExpr) {
    switch (CalcSizeOf(pExpr->pType)) {
    case 1:     return AVR_LoadImmediate8(hOut, iReg, (unsigned char)pExpr->Use.Const.lInteger);
    case 2:     return AVR_LoadImmediate16(hOut, iReg, (unsigned short)pExpr->Use.Const.lInteger);
    case 4:     return AVR_LoadImmediate32(hOut, iReg, (unsigned long)pExpr->Use.Const.lInteger);
    default:    Error(FATAL, "GenExprConst: Size?\n");
        return 0;
    }
}

// ##########################################################################
// #  Function: GenExprVar
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenExprVar(FILE *hOut, int iReg, TPExprNode pExpr) {
    if (pExpr->Use.Var.iFrameOffset == GLOBAL_VAR) {
        if ((pExpr->pType->Use.DecSpec.Qual & QualCONST) == QualCONST) {
            switch (CalcSizeOf(pExpr->pType)) {
            case 1:     return AVR_LoadRom8(hOut, iReg, pExpr->Use.Var.pszIdentifier);
            case 2:     return AVR_LoadRom16(hOut, iReg, pExpr->Use.Var.pszIdentifier);
            case 4:     return AVR_LoadRom32(hOut, iReg, pExpr->Use.Var.pszIdentifier);
            default:    Error(FATAL, "GenExprVar Rom: Size?\n");
                return 0;
            }
        }
        else {
            switch (CalcSizeOf(pExpr->pType)) {
            case 1:     return AVR_LoadRam8(hOut, iReg, pExpr->Use.Var.pszIdentifier);
            case 2:     return AVR_LoadRam16(hOut, iReg, pExpr->Use.Var.pszIdentifier);
            case 4:     return AVR_LoadRam32(hOut, iReg, pExpr->Use.Var.pszIdentifier);
            default:    Error(FATAL, "GenExprVar Ram: Size?\n");
                return 0;
            }
        }

    }
    else {
        switch (CalcSizeOf(pExpr->pType)) {
        case 1:     return AVR_LoadFrame8(hOut,  iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
        case 2:     return AVR_LoadFrame16(hOut, iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
        case 4:     return AVR_LoadFrame32(hOut, iReg, pExpr->Use.Var.iFrameOffset, pExpr->Use.Var.pszIdentifier);
        default:    Error(FATAL, "GenExprVar frame: Size?\n");
            return 0;
        }
    }
}


// ##########################################################################
// #  Function: GenExprCast
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int SignExtend(FILE *hOut, int iReg, int iExtra) {
    char szComment[32];
    sprintf_s(szComment, sizeof(szComment), "  1: Signed extend by %d bytes", iExtra);
    GenAsmOut(hOut, "", "mov", OperandRegReg(0, iReg - 1),  szComment, TRUE, FALSE);
    GenAsmOut(hOut, "", "lsl", OperandReg(0),       "  1:", TRUE, FALSE);
    GenAsmOut(hOut, "", "clr", OperandReg(0),       "  1: ", TRUE, FALSE);
    GenAsmOut(hOut, "", "sbc", OperandRegReg(0, 0), "  1:", TRUE, FALSE);
    while (iExtra--) {
        GenAsmOut(hOut, "", "mov", OperandRegReg(iReg++, 0), "  1:", TRUE, FALSE);
    }
    return iReg;
}

int UnsignExtend(FILE *hOut, int iReg, int iExtra) {
    char szComment[32];
    sprintf_s(szComment, sizeof(szComment), "  1: Unsigned extend by %d bytes", iExtra--);
    GenAsmOut(hOut, "", "clr", OperandReg(iReg++), szComment, TRUE, FALSE);
    while (iExtra--) {
        GenAsmOut(hOut, "", "clr", OperandReg(iReg++), "  1:", TRUE, FALSE);
    }
    return iReg;
}

int GenExprCast(FILE *hOut, int iReg, TPExprNode pExpr) {
    iReg = GenExpr(hOut, iReg, pExpr->Use.Cast.pTarget);                        // Calculate whatever it is we are casting.
    switch (pExpr->Use.Cast.Op) {
    case Cast_c2s: return SignExtend(hOut, iReg,   (SIZE_SHORT - SIZE_CHAR));   //   signed  8 to 16
    case Cast_c2l: return SignExtend(hOut, iReg,   (SIZE_LONG - SIZE_CHAR));    //   signed  8 to 32
    case Cast_s2l: return SignExtend(hOut, iReg,   (SIZE_LONG - SIZE_SHORT));   //   signed 16 to 32
    case Cast_b2s: return UnsignExtend(hOut, iReg, (SIZE_SHORT - SIZE_CHAR));   // unsigned  8 to 16
    case Cast_b2l: return UnsignExtend(hOut, iReg, (SIZE_LONG - SIZE_CHAR));    // unsigned  8 to 32
    case Cast_u2l: return UnsignExtend(hOut, iReg, (SIZE_LONG - SIZE_SHORT));   // unsigned 16 to 32
    case Cast_l2s: return iReg - (SIZE_LONG  - SIZE_SHORT);                     //          32 to 16
    case Cast_l2b: return iReg - (SIZE_LONG  - SIZE_CHAR);                      //          32 to  8
    case Cast_l2f: return iReg - (SIZE_LONG  - SIZE_BOOL);                      //          32 to size of flag
    case Cast_s2b: return iReg - (SIZE_SHORT - SIZE_CHAR);                      //          16 to  8
    case Cast_s2f: return iReg - (SIZE_SHORT - SIZE_BOOL);                      //          16 to size of flag
    default:
        Error(FATAL, "GenExprCast: Unknown cast (%d)\n", pExpr->Use.Cast.Op);
        return iReg;
    }
}

// ##########################################################################
// #  Function: GenExprAssign
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
int GenExprAssign(FILE *hOut, int iReg, TPExprNode pExpr) {
    TPExprNode pLval = pExpr->Use.Assign.pLval;
    TPExprNode pRval = pExpr->Use.Assign.pRval;
#pragma message("    GenExprAssign: var = const is a common special case.\n")
    int iTargetSize = CalcSizeOf(pLval->pType);
    int iSourceSize = CalcSizeOf(pRval->pType);

    // this will fail on shifts!
    ASSERT((iTargetSize == iSourceSize) || ((pExpr->Use.Assign.Op == AsSL) || (pExpr->Use.Assign.Op == AsSR)));                                 // confirm sizes match. 

    if ((pLval->pType->Use.DecSpec.Qual & QualCONST) == QualCONST) {
        Error(WARNINGX, "Write to const is not possible.");
        return iReg + iTargetSize;
    }

    if (pExpr->Use.Assign.Op != AsNop) {
        iReg = GenExpr(hOut, iReg, pLval);
        iReg = GenExpr(hOut, iReg, pRval);

        switch (pExpr->Use.Assign.Op) {
        case AsAdd:  iReg = GenAdd(hOut, iReg, iTargetSize); break;
        case AsSub:  iReg = GenSub(hOut, iReg, iTargetSize); break;
        case AsMul:  iReg = GenMul(hOut, iReg, iTargetSize); break;
        case AsDiv:  iReg = GenDiv(hOut, iReg, iTargetSize, TypeIsSigned(pLval->pType), TypeIsSigned(pRval->pType)); break;
        case AsMod:  iReg = GenMod(hOut, iReg, iTargetSize, TypeIsSigned(pLval->pType), TypeIsSigned(pRval->pType)); break;
        case AsBAnd: iReg = GenAnd(hOut, iReg, iTargetSize); break;
        case AsBXor: iReg = GenXor(hOut, iReg, iTargetSize); break;
        case AsBOr:  iReg = GenOr(hOut, iReg,  iTargetSize); break;
        case AsSL:   iReg = GenShiftL(hOut, iReg, iTargetSize); break;
        case AsSR:   iReg = GenShiftR(hOut, iReg, iTargetSize, TypeIsSigned(pLval->pType)); break;
        default:
            Error(FATAL, "Un recognized Op Assign");
            return iReg - iSourceSize;
        }
    }
    else {
        iReg = GenExpr(hOut, iReg, pRval);
    }

    if (pLval->Usage = uVar) {                                              // simple case          Var = <expr>
        if (pLval->Use.Var.iFrameOffset == GLOBAL_VAR) {
            switch (CalcSizeOf(pLval->pType)) {
            case 1:     return AVR_StoreRam8(hOut, pLval->Use.Var.pszIdentifier, iReg- iTargetSize);
            case 2:     return AVR_StoreRam16(hOut, pLval->Use.Var.pszIdentifier, iReg - iTargetSize);
            case 4:     return AVR_StoreRam32(hOut, pLval->Use.Var.pszIdentifier, iReg - iTargetSize);
            default:    Error(FATAL, "GenExprAssign Ram: Size?\n");
                return 0;
            }
        }
        else {
            switch (CalcSizeOf(pExpr->pType)) {
            case 1:     return AVR_StoreFrame8(hOut, pLval->Use.Var.iFrameOffset, iReg - iTargetSize, pLval->Use.Var.pszIdentifier);
            case 2:     return AVR_StoreFrame16(hOut, pLval->Use.Var.iFrameOffset, iReg - iTargetSize, pLval->Use.Var.pszIdentifier);
            case 4:     return AVR_StoreFrame32(hOut, pLval->Use.Var.iFrameOffset, iReg - iTargetSize, pLval->Use.Var.pszIdentifier);
            default:    Error(FATAL, "GenExprAssign frame: Size?\n");
                return 0;

            }
        }
    }
    else {
        Error(FATAL, "GenExprAssign: Assign to tricky destination.");
        return iReg + iTargetSize;
    }
}

// ##########################################################################
// #  Function: <todo: name>
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static int GenExpr(FILE *hOut, int iReg, TPExprNode pExpr) {
    if (!pExpr) {
        printf("..Null\n");
        Error(FATAL, "GenExpr() - NULL\n");
        return 0;
    }

    int iSize = CalcSizeOf(pExpr->pType);
    if ((iSize != 1) && (iSize != 2) && (iSize != 4)) {
        Error(FATAL, "GenExpr: Size?\n");
    }

    switch (pExpr->Usage) {
    case    uConst: return GenExprConst(hOut, iReg, pExpr);
    case    uVar:   return GenExprVar(hOut, iReg, pExpr);
    case    uUnary:
        Error(FATAL, "GenExpr() - uUnary needs implementing\n");
        break;
    case    uBinary:
        Error(FATAL, "GenExpr() - uBinary needs implementing\n");
        break;
    case    uTernary:
        Error(FATAL, "GenExpr() - uTernary needs implementing\n");
        break;
    case    uDot:
        Error(FATAL, "GenExpr() - uDot needs implementing\n");
        break;
    case    uArrow:
        Error(FATAL, "GenExpr() - uArrow needs implementing\n");
        break;
    case    uArray:
        Error(FATAL, "GenExpr() - uArray needs implementing\n");
        break;
    case    uFunc:
        Error(FATAL, "GenExpr() - uFunc needs implementing\n");
        break;
    case    uCast:
        return GenExprCast(hOut, iReg, pExpr);
        break;
    case    uAssign:
        return GenExprAssign(hOut, iReg, pExpr);
        break;
    default:
        Error(FATAL, "GenExpr() - [%d]\n", pExpr->Usage);
        break;
    }
    return 0;

}

// ##########################################################################
// #  Function: GenExpression
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void    GenExpression(FILE *hOut, TPExprNode pExpr) {

    ConsolePrintf(CON_YELLOW_BRIGHT, "Expression generation.\n");
    GenExpressionPrettyPrint(0, pExpr);
    ConsolePrintf(CON_YELLOW_BRIGHT, "\n");

    GenExpr(hOut, EXP_REG_BASE, pExpr);

}

/* eof */

