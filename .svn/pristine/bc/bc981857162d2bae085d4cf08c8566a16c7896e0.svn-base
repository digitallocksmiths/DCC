// # $URL$
// # $Revision$


#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <Windows.h>

#include "lex.h"
#include "typectrl.h"
#include "expr.h"
#include "Gen.h"
#include "GenData.h"
#include "main.h"


static LPSTR sign_unsign(WORD T) {
    if ((T & TypeUNSIGNED) == TypeUNSIGNED) return "unsigned ";
    if ((T & TypeSIGNED) == TypeSIGNED)   return "signed ";
    return "";
}


#define TT(D,T) (((D) & (T)) == (T))

static void GenObjectComment(FILE *hOut, TPDeclSpec pDecl) {
    while (pDecl) {
        switch (pDecl->Usage) {
        case    DecId:          // Id
        case    DecFunc:        // Function 
            Error(FATAL, "GenBssObjectComment():  Unexpected Useage '%d'\n", pDecl->Usage);
            return;

        case    DecArray:
            fprintf(hOut, "Array[%ld] of ", pDecl->Use.DecArray.Size);
            pDecl = pDecl->Use.DecArray.pTarget;
            break;

        case    DecPtr:
            switch (pDecl->Use.DecPtr.Qual) {
            case QualCONST:    fprintf(hOut, "constant pointer\n");  break;
            case QualVOLATILE: fprintf(hOut, "volatile pointer\n");  break;
            case QualNEAR:     fprintf(hOut, "near pointer\n");      break;
            case QualFAR:      fprintf(hOut, "far pointer\n");       break;
            default:           fprintf(hOut, "(generic) pointer\n");   break;
            }
            return;

        case    DecSpec:
            if ((pDecl->Use.DecSpec.Type) & TypeSTRUCT) {
                TPStructSet p = pDecl->Use.DecSpec.pPtr;
                if (p->fUnion) fprintf(hOut, "union '%s'\n", p->szSetName);
                else           fprintf(hOut, "structure '%s'\n", p->szSetName);
                return;
            }
            else if ((pDecl->Use.DecSpec.Type) & TypeENUM) {
                TPEnumSet e = pDecl->Use.DecSpec.pPtr;
                fprintf(hOut, "enum '%s'\n", e->pszSetName);
                return;
            }
            else if ((pDecl->Use.DecSpec.Type) & TypeTYPEDEF) {
                fprintf(hOut, "typedef not yet supported\n");
                //ParseDeclSpec(pDecl->Use.DecSpec.Ptr, fDoBrothers); 
                return;
            }
            else {
                if   TT(pDecl->Use.DecSpec.Type, (TypeLONG | TypeDOUBLE))fprintf(hOut, "long double");
                else if TT(pDecl->Use.DecSpec.Type, TypeDOUBLE)          fprintf(hOut, "double");
                else if TT(pDecl->Use.DecSpec.Type, TypeFLOAT)           fprintf(hOut, "float");
                else if TT(pDecl->Use.DecSpec.Type, TypeLONG)            fprintf(hOut, "%slong", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeSHORT)           fprintf(hOut, "%sshort ", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeINT)             fprintf(hOut, "%sint", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeCHAR)            fprintf(hOut, "%schar", sign_unsign(pDecl->Use.DecSpec.Type));
                else if TT(pDecl->Use.DecSpec.Type, TypeSIGNED)          fprintf(hOut, "signed");
                else if TT(pDecl->Use.DecSpec.Type, TypeUNSIGNED)        fprintf(hOut, "unsigned");
                else if TT(pDecl->Use.DecSpec.Type, TypeVOID)            fprintf(hOut, "void");
                else                                                     fprintf(hOut, "unknown type 0x%04x", pDecl->Use.DecSpec.Type);

                //              DescClass(pDecl->Use.DecSpec.Class); 
                //              DescQual(pDecl->Use.DecSpec.Qual); 
                fprintf(hOut, "\n");
            }
            return;

        default:
            Error(FATAL, "GenBssObjectComment(): Unknown Useage '%d'\n", pDecl->Usage);
            return;
        }
    }
}

// ##########################################################################################
// Data segment generator


static void SetupConstInitializer(TPDeclSpec T, LPSTR pszOpcode, LPSTR pszOperand, LPSTR pszComment, __int64 nVal, LPSTR pszName) {

    ASSERT(T->Usage == DecSpec || T->Usage == DecPtr);

    switch (CalcSizeOf(T)) {

    case 1: sprintf(pszOpcode, ASM_DIRECTIVE_BYTE);                                                                             // size = byte
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED) sprintf(pszOperand, "%hhu", (unsigned char)(nVal & 0xFF));    //          unsigned
        else                                                      sprintf(pszOperand, "%hhd", (signed char)(nVal & 0xFF));      //          signed
        if (pszComment != NULL) {                                                                                               // ? comment wanted?
            if (isprint((unsigned char)(nVal & 0xFF))) {                                                                        //
                sprintf(pszComment, "      '%c' 0x%02x -> %s", (char)nVal, (unsigned char)(nVal & 0xFF), pszName);              //          with prontable charater
            }                                                                                                                   //                
            else {                                                                                                              //
                sprintf(pszComment, "          0x%02x -> %s", (unsigned char)(nVal & 0xFF), pszName);                           //          without printable character
            }                                                                                                                   //
        }                                                                                                                       //
        return;                                                                                                                 //  return happy

    case 2: 
#ifdef ASM_DIRECTIVE_SHORT
        sprintf(pszOpcode, ASM_DIRECTIVE_SHORT);                                                                                // size = short
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED)  sprintf(pszOperand, "%hu", (unsigned short)(nVal & 0xFFFF)); //          unsigned
        else                                                       sprintf(pszOperand, "%hd", (signed short)(nVal & 0xFFFF));   //          signed
#else 
        sprintf(pszOpcode, ASM_DIRECTIVE_BYTE);                                                                                 // size = short
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED)  sprintf(pszOperand, "%hhu, %hhu", LOBYTE((unsigned short)(nVal & 0xFFFF)), HIBYTE((unsigned short)(nVal & 0xFFFF))); //          unsigned
        else                                                       sprintf(pszOperand, "%hhd, %hhd", LOBYTE((signed short)(nVal & 0xFFFF)),   LOBYTE((signed short)(nVal & 0xFFFF)));   //          signed
#endif // ASM_DIRECTIVE_SHORT
        if (pszComment != NULL) {                                                                                               // ? comment wanted?
            sprintf(pszComment, "        0x%04x -> %s", (unsigned short)(nVal & 0xFFFF), pszName);                              //
        }                                                                                                                       //
        return;                                                                                                                 //  return happy

    case 4: 
#ifdef ASM_DIRECTIVE_LONG
        sprintf(pszOpcode, ASM_DIRECTIVE_LONG); ;                                                                               // size = long
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED)  sprintf(pszOperand, "%u", (unsigned int)nVal);               //          unsigned
        else                                                       sprintf(pszOperand, "%d", (signed int)nVal);                 //          signed
#else
        sprintf(pszOpcode, ASM_DIRECTIVE_BYTE); ;                                                                               // size = long
        if ((T->Use.DecSpec.Type & TypeUNSIGNED) == TypeUNSIGNED)  sprintf(pszOperand, "%hhu, %hhu, %hhu, %hhu", LOBYTE(LOWORD((unsigned int)nVal)), HIBYTE(LOWORD((unsigned int)nVal)), LOBYTE(HIWORD((unsigned int)nVal)), HIBYTE(HIWORD((unsigned int)nVal)));   // unsigned
        else                                                       sprintf(pszOperand, "%hhd, %hhd, %hhd, %hhd", LOBYTE(LOWORD((signed int)nVal)),   HIBYTE(LOWORD((signed int)nVal)),   LOBYTE(HIWORD((signed int)nVal)),   HIBYTE(HIWORD((signed int)nVal)));     // signed
#endif // ASM_DIRECTIVE_LONG
        if (pszComment != NULL) {                                                                                               // ? comment wanted?
            sprintf(pszComment, "    0x%08x -> %s", (unsigned int)(nVal & 0xFFFFFFFFL), pszName);                               //
        }                                                                                                                       //
        return;                                                                                                                 //  return happy

    default: sprintf(pszOpcode, "; unknown size");                                                                              // size unknown.
        Error(FATAL, "SetupConstInitializer(): Unsuported size of variable '%s', %d", pszName, CalcSizeOf(T));
        return ;                                                                                                                //  return not happy 
    }
}


static void SetupVarInitializer(TPDeclSpec T, LPSTR pszOpcode, LPSTR pszOperand, LPSTR pszComment, LPSTR pszVar, LPSTR pszName) {       // when the operand is a string (no need to calculate it or look it up)

    ASSERT(T->Usage == DecSpec || T->Usage == DecPtr);

    sprintf(pszOperand, "%s", pszVar);
    if (pszComment != NULL) {
            sprintf(pszComment, "               -> %s",  pszName);
    }

    switch (CalcSizeOf(T)) {
    case 1: sprintf(pszOpcode, ASM_DIRECTIVE_BYTE);
        break;
    case 2: sprintf(pszOpcode, ASM_DIRECTIVE_SHORT);
        break;
    case 4: sprintf(pszOpcode, ASM_DIRECTIVE_LONG);
        break;
    default: sprintf(pszOpcode, "; unknown size");
        Error(FATAL, "SetupVarInitializer(): Unknown size of variable '%s' %d", pszName, CalcSizeOf(T));
    }
}

static DWORD InitializerCount(TPExprNode pInit) {           // get the length of the initializer list.
    DWORD n = 0;
    while (pInit != 0) {
        n++;
        pInit = pInit->pSibling;
    }
    return n;
}

// ######################################################################################################################
static void GenDataObject(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit);     // forward declaration for recursion in struct definitions.


                                                                                    
// ##########################################################################
// #  Function: GenDataObjectString
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void GenDataObjectString(FILE *hOut, TPDeclSpec pTarget, LPSTR pszInit, LPSTR pszName) {         // Arrays Initialized by Strings
    char szOpcode[32];
    char szOperand[32];
    char szComment[256];
    char szName[256];
    DWORD dwPadding;

    DWORD dwIndex = 0;
    ASSERT(pTarget->Usage == DecArray);
//#pragma message("************** GenDataObjectString() where is the defined array size taken from?")



    int iNameLen = strlen(pszName);
    sprintf_s(szName, sizeof(szName), "%s[%ld]", pszName, dwIndex);

    DWORD dwArraySize = pTarget->Use.DecArray.Size;
    DWORD dwLen = strlen(pszInit)+1;                       // number of initializers
    if (dwArraySize == 0) {
        dwArraySize = dwLen;
        pTarget->Use.DecArray.Size = dwArraySize;
    }

    if (dwArraySize < dwLen) {
        //WarningGen("To many initializers", pszName);
        dwLen = dwArraySize;
    }
    dwPadding = dwArraySize - dwLen;
    
    while (dwLen--) {
        sprintf_s(&szName[iNameLen], sizeof(szName)- iNameLen, "[%ld]", dwIndex++);
        SetupConstInitializer(pTarget->Use.DecArray.pTarget, szOpcode, szOperand, szComment, *pszInit, szName);
        GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE, FALSE);
        if (dwIndex == 1) {
            memset(szName, '-', iNameLen);
        }
        pszInit++;
    }

    //sprintf_s(szComment, sizeof(szComment), "               -> packed to %lu elements", dwSize);
    memset(szName, ' ', iNameLen);
    while (dwPadding--) {
        sprintf_s(&szName[iNameLen], sizeof(szName) - iNameLen, "[%ld]", dwIndex++);
        SetupConstInitializer(pTarget->Use.DecArray.pTarget, szOpcode, szOperand, szComment, 0, szName);
        GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE, FALSE);
    }
}


// ##########################################################################
// #  Function: GenDataObjectPointer
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void GenDataObjectPointer(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {                                                           // Initialized pointers

    char szOpcode[32];
    char szOperand[32];
    char szComment[64];

    szOpcode[0] = 0;
    szOperand[0] = 0;
    szComment[0] = 0;

    if (pInit != NULL) {
        ASSERT(pInit->Usage == uInit);
        TPExprNode Val = pInit->Use.Init.pAssignment;

        if (pInit->Use.Init.pChildren != NULL) {                            // start of bracketed set when singleton is expected
            //WarningGen("Unexpected structure in initializer data for variable/field ", pszName);
            SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, 0, pszName);
        }

        if (Val->Usage == uConst) {                                                                     // Const = OK
            unsigned __int64    nVal;
            nVal = Val->Use.Const.lInteger;
            SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, nVal, pszName);
            GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE, FALSE);
            return;
        }
        if ((Val->Usage == uVar) &&                                                                    // var, only if it is an array = OK.
            (Val->pType->Usage == DecArray)) {
            SetupVarInitializer(pTarget, szOpcode, szOperand, szComment, Val->Use.Var.pszIdentifier, pszName);
            GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE, FALSE);
            return;
        }
        if ((Val && Val->Usage == uUnary) &&                                                            // addr of var = OK
            (Val->Use.Unary.Op == unAddr)) {
            TPExprNode E = Val->Use.Unary.pOperand;
            ASSERT(E->Usage == uVar);
            SetupVarInitializer(pTarget, szOpcode, szOperand, szComment, E->Use.Var.pszIdentifier, pszName);
            GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE, FALSE);
            return;

        }
        Error(FATAL, "GenDataObjectPointer(): Non constant pointer value in initialization of ");
    }
    else {
        SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, 0, pszName);
    }

    GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE, FALSE);
}

// ##########################################################################
// #  Function: GenDataObjectArray
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void GenDataObjectArray(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {                      // *** Initialized Arrays ***
    char szName[256];

    ASSERT(pInit == NULL || pInit->Usage == uInit);
    ASSERT(pTarget->Usage == DecArray);                                                             // we have an array for sure.

    DWORD      dwSize = pTarget->Use.DecArray.Size;
    DWORD      dwInit;
    TPDeclSpec pElement = pTarget->Use.DecArray.pTarget;
    ASSERT(pElement != NULL);

                                                                                                    // Specical behavior when init is from a string  *** It's Complicated ! ***
    if ((pElement->Usage == DecSpec) &&                                                             // If its and array of simple types (not an array of arrays) && 
        ((pElement->Use.DecSpec.Type & TypeSTRUCT) == 0) &&                                         //    its not a structure  &&
        (pInit != NULL && pInit->Use.Init.pAssignment)) {                                           //    we also have initialization via assignment
        TPExprNode  pA = pInit->Use.Init.pAssignment;                                               //      
        if (pA->Usage == uVar) {                                                                    //      If we have an asignment from a variable
            TPDeclSpec V = FindGlobalObject(pA->Use.Var.pszIdentifier);                             //          we can find it ...
            if (V != NULL) {                                                                        //
                if (V->Usage == DecId && V->Use.DecId.pszInitializedStr != 0) {                     //          is this  variable initialized by a string.
                    ASSERT(pTarget->Usage == DecArray);                                             //              so far so good.
                    //if (dwSize == 0) {                                                            //              if our array has no given size then
                    //    dwSize = strlen(V->Use.DecId.pszInitializedStr) + 1;                      //                  it's the string length (incl zero terminator)
                    //    pTarget->Use.DecArray.Size = dwSize;                                      //
                    //}                                                                             //
                    GenDataObjectString(hOut, pTarget, V->Use.DecId.pszInitializedStr, pszName);    //              create the initialized data from the string data.          
                    return;
                }
            }
        }
    }

    if (pInit != NULL && pInit->Use.Init.pChildren) {                                               // would expect bracketed list of initializers (but may be missing)
        pInit = pInit->Use.Init.pChildren;
    }
    dwInit = InitializerCount(pInit);                                                               // initializer count
    if (dwSize == 0) {                                                                              // if the declared count is zero
        dwSize = dwInit;                                                                            //      we use the initializers to fix up the count.
        pTarget->Use.DecArray.Size = dwSize;                                                        //
    }
    //else if (dwSize < dwInit) {                                                                     // if more initializers than we want 
    //    WarningGen("GenDataObjectArray(): Too many initializors for ", pszName);                    //      have a good moan at the user.
    //}                                                                                               //

    int iNameLen = strlen(pszName);
    sprintf_s(szName, sizeof(szName), "%s", pszName);
    for (DWORD dwIndex = 0; dwIndex < dwSize; dwIndex++) {                                          // for all the elements we want
        sprintf_s(&szName[iNameLen], sizeof(szName)-iNameLen, "[%ld]", dwIndex);                    //      text stuff to make variable name+index
        if (dwIndex == 1) {                                                                         //
            memset(szName, '-', iNameLen);                                                          //
        }                                                                                           //
                                                                                                    //
        ASSERT(pInit == NULL || pInit->Usage == uInit);                                             //
                                                                                                    //
        GenDataObject(hOut, szName, pElement, pInit);                                               //      recurse to define each array element            
                                                                                                    //
        //pElement = pElement->Use.DecId.pBrother;                                                  //
        if (pInit != NULL) {                                                                        //      
            pInit = pInit->pSibling;                                                                //      consume one initialization parameter per array element.
        }                                                                                           //
    }
}


// ##########################################################################
// #  Function: GenDataObjectUnion
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectUnion(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {
    char szName[256];

    ASSERT(pInit == NULL || pInit->Usage == uInit);
    ASSERT(pTarget->Usage == DecSpec);

    TPStructSet S = pTarget->Use.DecSpec.pPtr;
    TPDeclSpec pElement = S->pElements;

    if (pInit != NULL && pInit->Use.Init.pChildren) {
        pInit = pInit->Use.Init.pChildren;
    }

    DWORD dwUnionSize = CalcSizeOf(pTarget);
    DWORD dwFirstFieldSize = 0L;

    if (pElement != NULL) {
        ASSERT(pElement->Usage == DecId);
        dwFirstFieldSize = CalcSizeOf(pElement->Use.DecId.pTarget);
        sprintf_s(szName, sizeof(szName), "%s.%s", pszName, pElement->Use.DecId.pszName);
        GenDataObject(hOut, szName, pElement->Use.DecId.pTarget, pInit);
    }
    
    if (dwUnionSize > dwFirstFieldSize) {                                                       // if the field we generated is smaller than the union
        char szComment[256];
        DWORD dwPacking = dwUnionSize - dwFirstFieldSize;
        sprintf_s(szComment, sizeof(szComment), "               -> %s packed to size %lu", pszName, dwUnionSize);
        while (dwPacking--) {
            GenAsmOut(hOut, NULL, ASM_DIRECTIVE_BYTE, "0", szComment, TRUE, FALSE);
            szComment[0] = 0;
        }
    }
}

// ##########################################################################
// #  Function: GenDataObjectStructure
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectStructure(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {           // Structure generation.
    char szName[256];
    
    ASSERT(pInit == NULL || pInit->Usage == uInit);
    ASSERT(pTarget->Usage == DecSpec);

    TPStructSet S = pTarget->Use.DecSpec.pPtr;
    TPDeclSpec pElement = S->pElements;
    
    if (pInit != NULL && pInit->Use.Init.pChildren) {
        pInit = pInit->Use.Init.pChildren;
    }

    while (pElement != NULL) {
        ASSERT(pElement->Usage == DecId);
        sprintf_s(szName, sizeof(szName), "%s.%s", pszName, pElement->Use.DecId.pszName);
        GenDataObject(hOut, szName, pElement->Use.DecId.pTarget, pInit);
        pElement = pElement->Use.DecId.pBrother;
        if (pInit != NULL) {
            pInit = pInit->pSibling;
        }
    }

}

// ##########################################################################
// #  Function: GenDataObjectEnum
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectEnum(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {                        // Enum value
    char szOpcode[32];
    char szOperand[32];
    char szComment[32];

#pragma message("    **** GenDataObjectEnum(): improvement. Comment could be the enum symbol name?")
    ASSERT(pInit->Usage == uInit);
    TPExprNode Val = pInit->Use.Init.pAssignment;

    int        nVal;
    if (Val->Usage != uConst) {
        Error(FATAL, "GenDataObjectEnum():  Non constant interger in Enum initialization of ");
        nVal = 0;
    }
    else {
        nVal = Val->Use.Const.lInteger;
    }

    SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, nVal, pszName);
    GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE, FALSE);
}

// ##########################################################################
// #  Function: GenDataObjectTypedef
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectTypedef(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {
    Error(FATAL, "GenDataObjectTypedef(): Unimplemented");
}

// ##########################################################################
// #  Function: GenDataObjectBasetype
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void    GenDataObjectBasetype(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {
    
    char szOpcode[32];
    char szOperand[32];
    char szComment[256];
    unsigned __int64   nVal = 0L;

    if (pInit != NULL) {
        ASSERT(pInit->Usage == uInit);
       
        if (pInit->Use.Init.pChildren != NULL) {                            // start of braketed set whee singleton is expected
            // WarningGen("Unexpected structure in initializer data for variable/field ", pszName);
            nVal = 0;
        }
        else {
            TPExprNode pVal = pInit->Use.Init.pAssignment;
            ASSERT(pVal != NULL);
            if (pVal->Usage != uConst) {
                //Error(FATAL, "GenDataObjectBasetype(): Non constant integer in initialization.");
                nVal = 0;
            }
            else {
                nVal = pVal->Use.Const.lInteger;
            }
        }
    }
    SetupConstInitializer(pTarget, szOpcode, szOperand, szComment, nVal, pszName);

    GenAsmOut(hOut, NULL, szOpcode, szOperand, szComment, TRUE, FALSE);
}


// ##########################################################################
// #  Function: GenDataObject
// #        <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
static void GenDataObject(FILE *hOut, LPSTR pszName, TPDeclSpec pTarget, TPExprNode pInit) {
    
    ASSERT(pInit == NULL || pInit->Usage == uInit);

    switch (pTarget->Usage) {
        case    DecId:          // Id
        case    DecFunc:        // Function 
            Error(FATAL, "GenDataObject():  Unexpected Useage '%d'\n", pTarget->Usage);
            return;

        case    DecArray:
            GenDataObjectArray(hOut, pszName, pTarget, pInit);
            return;

        case    DecPtr:
            GenDataObjectPointer(hOut, pszName, pTarget, pInit);
            return;

        case    DecSpec:
            // consider using BOOL IsIntegralType()????
            if ((pTarget->Use.DecSpec.Type) & TypeSTRUCT) {
                TPStructSet p = pTarget->Use.DecSpec.pPtr;
                if (p->fUnion) GenDataObjectUnion(hOut, pszName, pTarget, pInit);
                else           GenDataObjectStructure(hOut, pszName, pTarget, pInit);
                return;
            }
            else if ((pTarget->Use.DecSpec.Type) & TypeENUM) {
                TPEnumSet e = pTarget->Use.DecSpec.pPtr;
                GenDataObjectEnum(hOut, pszName, pTarget, pInit);
                return;
            }
            else if ((pTarget->Use.DecSpec.Type) & TypeTYPEDEF) {
                GenDataObjectTypedef(hOut, pszName, pTarget, pInit);
                return;
            }
            else {
                GenDataObjectBasetype(hOut, pszName, pTarget, pInit);
                return;
            }
            return;

        default:
            Error(FATAL, "GenDataObject(): Unknown Useage '%d'\n", pTarget->Usage);
            return;
        }

}


// ##########################################################################
// #  Function: GenData
// #        *public* <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void    GenConst(FILE *hOut, TPDeclSpec pDeclList) {
    //char szOperand[32];
    TPDeclSpec pDecl;

    GenAsmOut(hOut, NULL, NULL, NULL, "##########################", TRUE, FALSE);
    GenAsmOut(hOut, NULL, NULL, NULL, "# Start of CONST segment #", TRUE, FALSE);
    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_BEGIN_CONST, "", "##########################", TRUE, FALSE);

    for (pDecl = pDeclList; pDecl; pDecl = pDecl->pChain) {                                 // auto generated string initializers
        if ((pDecl->Usage == DecId) &&                                                              // Must be DecId
            GenIsData(pDecl->Use.DecId.pTarget->Usage) &&                                           // Id's use must be storage rather than definition or code.
            (pDecl->Use.DecId.pszInitializedStr)) {                                                 // If sz pointer used here it's an auto-gen string.

            TPDeclSpec pTarget = pDecl->Use.DecId.pTarget;
            ASSERT(pTarget->Usage == DecArray);
            if (pDecl->Use.DecId.UsedFlags == DecId_Used) {                                         //  we can skip this initialization because the array contents will be used to initialize a defined variable array.
                ;
            }
            else if (pDecl->Use.DecId.UsedFlags == DecId_Refed) {                                   // we need a ROM copy of the data to be referenced by an initialized pointer.
                GenAsmOut(hOut, pDecl->Use.DecId.pszName, NULL, NULL, "", FALSE, TRUE);
                GenObjectComment(hOut, pTarget);
                GenDataObjectString(hOut, pTarget, pDecl->Use.DecId.pszInitializedStr, "");
            }
            else {
//                Error(FATAL, "GenConst(): odd variable UsedFlags setting  = %x", pDecl->Use.DecId.UsedFlags);
            }
        }
    }

    for (pDecl = pDeclList; pDecl; pDecl = pDecl->pChain) {
        if (pDecl->Usage == DecId) {
            TPDeclSpec pTarget = pDecl->Use.DecId.pTarget;
            if (GenIsData(pTarget->Usage) && IsTypeQualifierConst(pTarget)) {
                GenAsmOut(hOut, pDecl->Use.DecId.pszName, NULL, NULL, "", FALSE, TRUE);
                GenObjectComment(hOut, pTarget);
                GenDataObject(hOut, pDecl->Use.DecId.pszName, pTarget, pDecl->Use.DecId.pInitializer);
            }
        }
    }

//     if ((pDeclList->Usage == DecId) &&
//            GenIsData(pDeclList->Use.DecId.pTarget->Usage) &&
//            (pDeclList->Use.DecId.pInitializer)) {
//
//            TPDeclSpec pTarget = pDeclList->Use.DecId.pTarget;
//            ASSERT(pTarget);
//            if (IsTypeQualifierConst(pTarget)) {
//                GenAsmOut(hOut, pDeclList->Use.DecId.pszName, NULL, NULL, "", FALSE, TRUE);
//                GenObjectComment(hOut, pTarget);
//                GenDataObject(hOut, pDeclList->Use.DecId.pszName, pTarget, pDeclList->Use.DecId.pInitializer);
//            }
//        }
//    }
    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_END, NULL, "=== End of CONST segment ===\n\n", TRUE, FALSE);

}


// ##########################################################################
// #  Function: GenData
// #        *public* <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenData(FILE *hOut, TPDeclSpec pDeclList) {
    char szOperand[32];
    TPDeclSpec pDecl;

    GenAsmOut(hOut, NULL, NULL, NULL, "#########################", TRUE, FALSE);
    GenAsmOut(hOut, NULL, NULL, NULL, "# Start of INIT segment #", TRUE, FALSE);
    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_BEGIN_INIT, "", "#########################", TRUE, FALSE);

    GenAsmOut(hOut, "", "", "", "This is the source of the initialization data", TRUE, FALSE);
    for (pDecl = pDeclList; pDecl; pDecl = pDecl->pChain) {
        if (pDecl->Usage == DecId) {
            TPDeclSpec pTarget = pDecl->Use.DecId.pTarget;
            if (GenIsData(pTarget->Usage) && !IsTypeQualifierConst(pTarget) && (pDecl->Use.DecId.pInitializer)) {
                TPDeclSpec pTarget = pDecl->Use.DecId.pTarget;
                ASSERT(pTarget);
                GenAsmOut(hOut, ";", pDecl->Use.DecId.pszName, NULL, "", FALSE, FALSE);
                GenObjectComment(hOut, pTarget);
                GenDataObject(hOut, pDecl->Use.DecId.pszName, pTarget, pDecl->Use.DecId.pInitializer);
            }
        }
    }

    GenAsmOut(hOut, NULL, NULL, NULL, "#########################", TRUE, FALSE);
    //GenAsmOut(hOut, NULL, NULL, NULL, "# Start of DATA segment #", TRUE, FALSE);
    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_BEGIN_DATA, "", "# Start of DATA segment #", TRUE, FALSE);
    GenAsmOut(hOut, NULL, "", "", "#########################", TRUE, FALSE);

    GenAsmOut(hOut, "", "", "", "This is where the initialization data will be copied to", TRUE, FALSE);

    for (pDecl = pDeclList; pDecl; pDecl = pDecl->pChain) {
        if (pDecl->Usage == DecId) {
            TPDeclSpec pTarget = pDecl->Use.DecId.pTarget;
            if (GenIsData(pTarget->Usage) && !IsTypeQualifierConst(pTarget) && (pDecl->Use.DecId.pInitializer)) {
                TPDeclSpec pTarget = pDecl->Use.DecId.pTarget;
                DWORD dwSz = CalcSizeOf(pDecl->Use.DecId.pTarget);
                TPDeclSpec pD = pDecl->Use.DecId.pTarget;
                while (pD->Usage == DecArray) pD = pD->Use.DecArray.pTarget;
                ASSERT(pD->Usage == DecSpec);
                WORD bClass = pD->Use.DecSpec.Class;
                BOOL fGlobal = ((bClass & ClassSTATIC) != ClassSTATIC);
                if (dwSz == 0) {
                    GenAsmOut(hOut, pDecl->Use.DecId.pszName, "", "", "", FALSE, fGlobal);
                }
                else {
                    sprintf(szOperand, "%4d", dwSz);
                    GenAsmOut(hOut, pDecl->Use.DecId.pszName, ASM_DIRECTIVE_SPACE, szOperand, "", FALSE, fGlobal);
                }
                GenObjectComment(hOut, pDecl->Use.DecId.pTarget);
            }
        }
    }


    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_END, NULL, "=== End of DATA segment ===\n\n", TRUE, FALSE);

}

// ##########################################################################################
// Bss segment generator


// ##########################################################################
// #  Function: GenBss
// #        *public* <todo: task brief description>
// #
// #        <todo: task detailed description>
// #
// #  Parameters:
// #        <todo: params >
// #
// #  Returns:
// #        <todo: return Value>
// #
// #  See Also:
// #
// ##########################################################################
void GenBss(FILE *hOut, TPDeclSpec pDeclList) {
    char szOperand[32];
    TPDeclSpec pDecl;

    GenAsmOut(hOut, NULL, NULL, NULL, "########################", TRUE, FALSE);
    //GenAsmOut(hOut, NULL, NULL, NULL, "# Start of BSS segment #", TRUE, FALSE);
    //GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_BEGIN_BSS, "", "########################", TRUE, FALSE);
    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_BEGIN_BSS, "", "# Start of BSS segment #", TRUE, FALSE);
    GenAsmOut(hOut, NULL, "", "", "########################", TRUE, FALSE);

    GenAsmOut(hOut, "", "", "", "Here starts the uninitialized data", TRUE, FALSE);
    for (pDecl = pDeclList; pDecl; pDecl = pDecl->pChain) {
        if (pDecl->Usage == DecId) {
            TPDeclSpec pTarget = pDecl->Use.DecId.pTarget;
            if (GenIsData(pTarget->Usage) && !IsTypeQualifierConst(pTarget) && !(pDecl->Use.DecId.pInitializer) && !(pDecl->Use.DecId.pszInitializedStr)) {
                DWORD dwSz = CalcSizeOf(pDecl->Use.DecId.pTarget);
                TPDeclSpec pD = pDecl->Use.DecId.pTarget;
                while (pD->Usage == DecArray) pD = pD->Use.DecArray.pTarget;
                ASSERT(pD->Usage == DecSpec);
                WORD bClass = pD->Use.DecSpec.Class;
                if ((bClass & ClassEXTERN) == ClassEXTERN) {
                    GenAsmOut(hOut, "", ".extern", pDecl->Use.DecId.pszName, "", FALSE, FALSE);
                }
                else {
                    BOOL fGlobal = ((bClass & ClassSTATIC) != ClassSTATIC);
                    if (dwSz == 0) {
                        GenAsmOut(hOut, pDecl->Use.DecId.pszName, "", "", "", FALSE, fGlobal);
                    }
                    else {
                        sprintf(szOperand, "%4d", dwSz);
                        GenAsmOut(hOut, pDecl->Use.DecId.pszName, ASM_DIRECTIVE_SPACE, szOperand, "", FALSE, fGlobal);
                    }
                }
                GenObjectComment(hOut, pDecl->Use.DecId.pTarget);
            }
        }
    }

    GenAsmOut(hOut, NULL, ASM_DIRECTIVE_SEGMENT_END, NULL, "=== End of BSS segment ===\n\n", TRUE, FALSE);

}

/* eof */
